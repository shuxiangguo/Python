{"title": "微信小程序开发，如何优雅地兼容 ", "author": "Rolan", "pub_time": "2018-9-19 00:02", "content": "关于单个 API 如何兼容，微信官方提供了兼容文档，因此我们这里不再赘述。下面主要讨论在整个项目如何优雅地处理兼容问题。问题如果在每处需要兼容的地方都写上一堆兼容相关的代码，随着代码量增加，会出现以下问题：代码难以阅读兼容方案有变动时，需要改动多处随着时间推移，你的代码才是最需要并且是最难兼容的思考最理想的情况是不需要任何兼容处理，因此可以反推出兼容性处理的代码并不是代码正常流程中的一部分，基于此：兼容的细节不必暴露兼容的方案应该统一兼容的方案可方便地变动解决方案1.将兼容方案隐藏，对外提供接口即可比如 wx.showLoading 是在 1.1.0 版本之后才提供的，对于之前的版本需要兼容。我们选择将其放在 show-loading.js 中，内部进行兼容性相关处理，并对外提供 showLoading 方法。这样调用者只需调用 showLoading 方法即可，不用考虑兼容性的问题，而且如果兼容的方式有变动，只需改动 show-loading.js 一处即可。2.兼容的处理还有共性可以抽象兼容处理多了之后我们会发现，对兼容所做的处理无非两方面：支持该方法时，直接使用对应方法不支持该方法时，做一些兼容处理因此这种模式我们又可以抽离出来，这样做当然有一些好处：减少重复代码做一些共性的处理时，我们又只用改动一处（比如当不兼容官方 API 时加上对应统计，用于分析当前应用跨版本的情况）比如我们抽离出这样一个简单的 compatible.js 用于处理兼容时的共性问题：之前的 showLoading.js 我们可以这样写：简单吧 :)，这种写法的意思是兼容时正常展示 loading 即可，不兼容时则不展示。当然可能有完美主义者会觉得『怎么能不展示呢？我就是要展示！』 那么我们可以这样写：用 wx.showToast 伪造了一个 showLoading。3.文件组织兼容性的文件可能会越来越多，对于我这种有收拾的人，看到所有东西散乱地扔在一个抽屉里肯定是不能忍的...因此我们可以多用几个小盒子把它们分门别类地装起来。小盒子怎么选呢？其实官方已经给出了答案，官方 API 是按照不同的功用分组的，因此我们拿分组当『盒子』即可。最终的文件组织像这样："}
{"title": "两种方案开发小程序动画 ", "author": "Rolan", "pub_time": "2018-11-12 00:32", "content": "在普通的网页开发中，动画效果可以通过css3来实现大部分需求，在小程序开发中同样可以使用 css3 ，同时也可以通过 api 方式来实现。指路： 小程序animatiom动画APIAPI解读小程序中，通过调用 api 来创建动画，需要先创建一个实例对象。这个对象通过 wx.createAnimation 返回, animation 的一系列属性都基于这个实例对象。创建这个对象let animation = wx.createAnimation({\r\n        duration: 2000,\r\n        delay: 0,\r\n        timingFunction: \"linear\",\r\n    });\r\n复制代码这个 animation 就是通过 wx.createAnimation 之后返回的实例。在创建过程中，可以给这个实例添加一些属性，如以上代码所示，等同于 css3 中 animation:$name 2s linear 的写法。添加动效实例创建完成之后，基于该实例，添加需要的动态效果，动态类型可以查阅文档得知，以最常见的移动，旋转为例：animation.translate($width, 0).rotate($deg);\r\n复制代码结束动画.step() 表示一组动画的结束animation.step();\r\n复制代码导出动画动画效果添加完成了，如何给想要的dom添加动效呢。这里需要用到 .export() 导出动画队列，赋值给某个dom对象。this.setData({ moveOne: animation.export() })\r\n复制代码<view  animation=\"{{moveOne}}\"></view>\r\n复制代码例子以下将通过2组动画，来对比一下 css3 与 api 实现方式的不同。一、模块移动动画动画效果：下图有两组动画，分别为 api 方式（上）与 css3 方式（下）完成的效果，点击move按钮，动画启动。代码实现以下分别为 css3 与 api 的核心代码：css3：<!-- wxml -->\r\n    <view class='border'>\r\n        <view class='css-block {{isMove && \"one\"}}'></view>\r\n        <view class='css-block {{isMove && \"two\"}}'></view>\r\n        <view class='css-block {{isMove && \"three\"}}'></view>\r\n        <view class='css-block {{isMove && \"four\"}}'></view>\r\n    </view>\r\n复制代码// scss\r\n    @mixin movePublic($oldLeft,$oldTop,$left,$top) {\r\n        from {\r\n          transform:translate($oldLeft,$oldTop);\r\n        }\r\n        to {\r\n          transform:translate($left,$top);\r\n        }\r\n    }\r\n    \r\n    @mixin blockStyle($color,$name) {\r\n        background: $color;\r\n        animation:$name 2s linear infinite alternate;\r\n    }\r\n    .one {\r\n        @include blockStyle(lightsalmon,onemove);\r\n    }\r\n    \r\n    @keyframes onemove {\r\n        @include movePublic(50rpx,-25rpx,-150rpx,0rpx);\r\n    }\r\n    \r\n    .two {\r\n        @include blockStyle(lightblue,twomove);\r\n    }\r\n    \r\n    @keyframes twomove {\r\n        @include movePublic(0rpx,25rpx,-50rpx,0rpx);\r\n    }\r\n    \r\n    .three {\r\n        @include blockStyle(lightgray,threemove);\r\n    }\r\n    \r\n    @keyframes threemove {\r\n        @include movePublic(0rpx,25rpx,50rpx,0rpx);\r\n    }\r\n    \r\n    .four {\r\n        @include blockStyle(grey,fourmove);\r\n    }\r\n    \r\n    @keyframes fourmove {\r\n        @include movePublic(-50rpx,-25rpx,150rpx,0rpx);\r\n    }\r\n复制代码// js\r\n    moveFunction(){\r\n        this.setData({\r\n            isMove: true\r\n        })\r\n    }\r\n复制代码css3 中通过动态改变 class 类名来达到动画的效果，如上代码通过 one 、 two 、 three 、 four 来分别控制移动的距离，通过sass可以避免代码过于冗余的问题。 （纠结如何在小程序中使用 sass 的童鞋请看这里哦： wechat-mina-template ）api：moveClick(){\r\n        this.move(-75,-12.5,25,'moveOne');\r\n        this.move(-25,12.5, 0,'moveTwo');\r\n        this.move(25, 12.5,0,'moveThree');\r\n        this.move(75, -12.5,-25,'moveFour');\r\n        this.moveFunction(); // 该事件触发css3模块进行移动\r\n    },\r\n\r\n    // 模块移动方法\r\n    move: function (w,h,m,ele) {\r\n        let self = this;\r\n        let moveFunc = function () {\r\n        let animation = wx.createAnimation({\r\n            duration: 2000,\r\n            delay: 0,\r\n            timingFunction: \"linear\",\r\n        });\r\n    \r\n        animation.translate(w, 0).step()\r\n        self.setData({ [ele]: animation.export() })\r\n        let timeout = setTimeout(function () {\r\n            animation.translate(m, h).step();\r\n            self.setData({\r\n                // [ele] 代表需要绑定动画的数组对象\r\n                [ele]: animation.export()\r\n            })\r\n          }.bind(this), 2000)\r\n        }\r\n        moveFunc();\r\n        let interval = setInterval(moveFunc,4000)\r\n    }\r\n复制代码效果图可见，模块之间都是简单的移动，可以将他们的运动变化写成一个公共的事件，通过向事件传值，来移动到不同的位置。其中的参数 w,h,m,ele 分别表示发散水平方向移动的距离、聚拢时垂直方向、水平方向的距离以及需要修改 animationData 的对象。通过这种方法产生的动画，无法按照原有轨迹收回，所以在事件之后设置了定时器，定义在执行动画2s之后，执行另一个动画。同时 动画只能执行一次 ，如果需要循环的动效，要在外层包裹一个重复执行的定时器到。查看源码，发现 api 方式是通过 js 插入并改变内联样式来达到动画效果，下面这张动图可以清晰地看出样式变化。打印出赋值的 animationData ， animates 中存放了动画事件的类型及参数； options 中存放的是此次动画的配置选项， transition 中存放的是 wx.createAnimation 调用时的配置， transformOrigin 是默认配置，意为以对象的中心为起点开始执行动画，也可在 wx.createAnimation时进行配置。二、音乐播放动画上面的模块移动动画不涉及逻辑交互，因此新尝试了一个音乐播放动画，该动画需要实现暂停、继续的效果。动画效果：两组不同的动画效果对比，分别为 api （上）实现与 css3 实现（下）：代码实现以下分别是 css3 实现与 api 实现的核心代码：css3：<!-- wxml -->\r\n    <view class='music musicTwo musicRotate {{playTwo ? \" \": \"musicPaused\"}} ' bindtap='playTwo'>\r\n        <text class=\"iconfont has-music\" wx:if=\"{{playTwo}}\"></text>\r\n        <text class=\"iconfont no-music\" wx:if=\"{{!playTwo}}\"></text>\r\n    </view>\r\n复制代码// scss\r\n    .musicRotate{\r\n        animation: rotate 3s linear infinite;\r\n    }\r\n    \r\n    @keyframes rotate{\r\n        from{\r\n            transform: rotate(0deg)\r\n        }\r\n        to{\r\n            transform: rotate(359deg)\r\n        }\r\n    }\r\n    \r\n    .musicPaused{\r\n        animation-play-state: paused;\r\n    }\r\n复制代码// js\r\n    playTwo(){\r\n        this.setData({\r\n            playTwo: !this.data.playTwo\r\n        },()=>{\r\n            let back = this.data.backgroundAudioManager;\r\n            if(this.data.playTwo){\r\n                back.play();\r\n            } else {\r\n                back.pause();\r\n            }\r\n        })\r\n    }\r\n复制代码通过 playTwo 这个属性来判断是否暂停，并控制 css 类的添加与删除。当为 false 时，添加 .musicPaused 类，动画暂停。api:<!-- wxml -->\r\n    <view class='music' bindtap='play'  animation=\"{{play && musicRotate}}\">\r\n        <text class=\"iconfont has-music\" wx:if=\"{{play}}\"></text>\r\n        <text class=\"iconfont no-music\" wx:if=\"{{!play}}\"></text>\r\n    </view>\r\n复制代码// js\r\n    play(){\r\n        this.setData({\r\n            play: !this.data.play\r\n        },()=>{\r\n            let back = this.data.backgroundAudioManager;\r\n            if (!this.data.play) {\r\n                back.pause();\r\n               // 跨事件清除定时器\r\n               clearInterval(this.data.rotateInterval);\r\n            } else {\r\n                back.play();\r\n                // 继续旋转，this.data.i记录了旋转的程度\r\n                this.musicRotate(this.data.i);\r\n            }\r\n        })\r\n    },\r\n    musicRotate(i){\r\n        let self = this;\r\n        let rotateFuc = function(){\r\n            i++;\r\n            self.setData({\r\n                i:i++\r\n            });\r\n            let animation = wx.createAnimation({\r\n                duration: 1000,\r\n                delay: 0,\r\n                timingFunction: \"linear\",\r\n            });\r\n            animation.rotate(30*(i++)).step()\r\n            self.setData({ musicRotate: animation.export() });\r\n        }\r\n        rotateFuc();\r\n        let rotateInterval = setInterval(\r\n            rotateFuc,1000\r\n        );\r\n        // 全局定时事件\r\n        this.setData({\r\n            rotateInterval: rotateInterval\r\n        })\r\n    }\r\n复制代码通过 api 实现的方式是通过移除 animationData 来控制动画，同时暂停动画也需要清除定时器，由于清除定时器需要跨事件进行操作，所以定了一个全局方法 rotateInterval 。api 方式定义了旋转的角度，但旋转到该角度之后便会停止，如果需要实现重复旋转效果，需要通过定时器来完成。因此定义了变量i，定时器每执行一次便加1，相当于每1s旋转30°，对 animation.rotate() 中的度数动态赋值。暂停之后继续动画,需要从原有角度继续旋转，因此变量i需要为全局变量。代码变化下图可以看出， api 方式旋转是通过不断累加角度来完成，而非 css3 中循环执行。对比通过上述两个小例子对比，无论是便捷度还是代码量，通过 css3 来实现动画效果相对来说是更好的选择。 api 方式存在较多局限性：动画只能执行一次，循环效果需要通过定时器完成。无法按照原有轨迹返回，需要返回必须定义定时器。频繁借助定时器在性能上有硬伤。综合以上，推荐通过 css3 来完成动画效果。"}
{"title": "微信小程序组件封装 ", "author": "Rolan", "pub_time": "2018-11-13 00:36", "content": "概述自己封装的一个比较简单微信弹窗小组件，主要就是教会大家对微信小组件的用法和理解，因为微信小程序对组件介绍特别少，所以我就把自己的理解分享给大家。一前言相信大家在开发小程序时会遇到某个功能多次使用的情况，比如弹出框。这个时候大家首先想到的是组件化开发，就是把弹出框封装成一个组件，然后哪里使用哪里就调用，对，看来大家都是有思路的人，但是要怎样实现呢。可能你会去看官方文档，但是微信的官方文档也是说的不太清楚，所以写起来也是非常痛苦。今天就和大家一起开发微信组件，坐稳了，老司机要开车了。二具体实现我们先实现个简单的弹窗组件，详情图如下：1.新建component文件夹存放我们的组件，里边存放的就是我们所用的组件，我们今天要做的事弹出框，新建文件夹popup存放我们的组件模板，点击右键选择新建component，就会自动生成组件的模板wxss、wxml、json、js，如图2.我们可以写一些组件样式和布局，跟页面写法类似，我就不多说了，直接把代码贴出 :popup.wxml<view class=\"wx-popup\" hidden=\"{{flag}}\">  <view class='popup-container'>    <view class=\"wx-popup-title\">{{title}}</view>    <view class=\"wx-popup-con\">{{content}}</view>    <view class=\"wx-popup-btn\">      <text class=\"btn-no\" bindtap='_error'>{{btn_no}}</text>      <text class=\"btn-ok\" bindtap='_success'>{{btn_ok}}</text>    </view>  </view></view>复制代码popup.wxss/* component/popup.wxss */.wx-popup {  position: absolute;  left: 0;  top: 0;   width: 100%;  height: 100%;  background: rgba(0, 0, 0, .5);} .popup-container {  position: absolute;  left: 50%;  top: 50%;   width: 80%;  max-width: 600rpx;  border: 2rpx solid #ccc;  border-radius: 10rpx;  box-sizing: bordre-box;  transform: translate(-50%, -50%);   overflow: hidden;  background: #fff;} .wx-popup-title {  width: 100%;  padding: 20rpx;  text-align: center;  font-size: 40rpx;  border-bottom: 2rpx solid red;} .wx-popup-con {  margin: 60rpx 10rpx;  text-align: center;} .wx-popup-btn {  display: flex;  justify-content: space-around;  margin-bottom: 40rpx;} .wx-popup-btn text {  display: flex;  align-items: center;  justify-content: center;  width: 30%;  height: 88rpx;  border: 2rpx solid #ccc;  border-radius: 88rpx;}复制代码样式和布局和布局已经写好了接下来要介绍的就是Component构造器Component构造器可用于定义组件，调用Component构造器时可以指定组件的属性、数据、方法等。定义段类型是否必填描述propertiesObject Map否组件的对外属性，是属性名到属性设置的映射表，属性设置中可包含三个字段， type 表示属性类型、 value 表示属性初始值、 observer 表示属性值被更改时的响应函数dataObject否组件的内部数据，和 properties 一同用于组件的模版渲染methodsObject否组件的方法，包括事件响应函数和任意的自定义方法，关于事件响应函数的使用，参见组件事件behaviorsString Array否类似于mixins和traits的组件间代码复用机制，参见behaviorscreatedFunction否组件生命周期函数，在组件实例进入页面节点树时执行，注意此时不能调用 setDataattachedFunction否组件生命周期函数，在组件实例进入页面节点树时执行readyFunction否组件生命周期函数，在组件布局完成后执行，此时可以获取节点信息（使用SelectorQuery ）movedFunction否组件生命周期函数，在组件实例被移动到节点树另一个位置时执行detachedFunction否组件生命周期函数，在组件实例被从页面节点树移除时执行relationsObject否组件间关系定义，参见组件间关系externalClassesString Array否组件接受的外部样式类，参见外部样式类optionsObject Map否一些组件选项，请参见文档其他部分的说明Tips:Component 构造器构造的组件也可以作为页面使用。使用 this.data 可以获取内部数据和属性值，但不要直接修改它们，应使用 setData 修改。生命周期函数无法在组件方法中通过 this 访问到。属性名应避免以 data 开头，即不要命名成 dataXyz 这样的形式，因为在 WXML 中， data-xyz=\"\" 会被作为节点 dataset 来处理，而不是组件属性。在一个组件的定义和使用时，组件的属性名和data字段相互间都不能冲突（尽管它们位于不同的定义段中）。component介绍完后就是最为关键的js了popup.js:Component({  options: {    multipleSlots: true // 在组件定义时的选项中启用多slot支持  },  /**   * 组件的属性列表   */  properties: {    title: {            // 属性名      type: String,     // 类型（必填），目前接受的类型包括：String, Number, Boolean, Object, Array, null（表示任意类型）      value: '标题'     // 属性初始值（可选），如果未指定则会根据类型选择一个    },    // 弹窗内容    content: {      type: String,      value: '内容'    },    // 弹窗取消按钮文字    btn_no: {      type: String,      value: '取消'    },    // 弹窗确认按钮文字    btn_ok: {      type: String,      value: '确定'    }   },   /**   * 组件的初始数据   */  data: {    flag: true,  },   /**   * 组件的方法列表   */  methods: {    //隐藏弹框    hidePopup: function () {      this.setData({        flag: !this.data.flag      })    },    //展示弹框    showPopup () {      this.setData({        flag: !this.data.flag      })    },    /*    * 内部私有方法建议以下划线开头    * triggerEvent 用于触发事件    */    _error () {      //触发取消回调      this.triggerEvent(\"error\")    },    _success () {      //触发成功回调      this.triggerEvent(\"success\");    }  }})复制代码上边会用到一个triggerEvent下面我们就来介绍下：自定义组件触发事件时，需要使用 triggerEvent 方法，指定事件名、detail对象和事件选项。触发事件的选项包括：选项名类型是否必填默认值描述bubblesBoolean否false事件是否冒泡composedBoolean否false事件是否可以穿越组件边界，为false时，事件将只能在引用组件的节点树上触发，不进入其他任何组件内部capturePhaseBoolean否false事件是否拥有捕获阶段现在一个弹窗的组件就封装好了接下来就是调用了。调用的时候需要在调用的页面新建一个json文件，json文件里需要配置usingComponents就是引用组件，看代码：index.json{  \"usingComponents\": {    \"popup\": \"/component/popup/popup\"  }}复制代码现在基本上完成了需要的就是在首页引用了。<!--index.wxml--><view class=\"container\">  <view class=\"userinfo\">    <button bindtap=\"showPopup\"> 点我 </button>  </view>  <popup id='popup'       title='小组件'       content='学会了吗'       btn_no='没有'       btn_ok='学会了'      bind:error=\"_error\"        bind:success=\"_success\">  </popup></view>复制代码配置index.js加上点击事件//index.js//获取应用实例const app = getApp() Page({  onReady: function () {    //获得popup组件    this.popup = this.selectComponent(\"#popup\");  },   showPopup() {    this.popup.showPopup();  },   //取消事件  _error() {    console.log('你点击了取消');    this.popup.hidePopup();  },  //确认事件  _success() {    console.log('你点击了确定');    this.popup.hidePopup();  }})复制代码一个弹窗组件就完成了，看下效果："}
{"title": "使用高德地图微信小程序SDK开发案例-输入提示（附源码） ", "author": "Rolan", "pub_time": "2018-11-13 00:40", "content": "闲来无事写一篇使用高德地图的微信小程序SDK开发应用的实例。接下来先看需求：我们要做的是，根据用户输入的关键词，给出相应的提示信息，列表中显示地方的名称，地方的详细地址以及对应的经纬度坐标。当然在UI上我们尽量做到理想的视觉与较好的用户体验。最终的效果我们希望是像这样的，如下图：有了目标，我们直接代码撸起来～我们先从高德开放平台获取微信小程序SDK以及开发需要的key。完成一些基础工作后我们先规划下页面布局。我们需要一个输入框可以让用户输入，和一个存放列表的容器来显示提示信息。<input type=\"text\" value='{{inputVal}}' bindinput='input' placeholder='请输入搜索关键字'></input>好了，我们为它添加1个监听事件，bindinput='input'，来监听用户的键盘输入。接着我们来做存放列表的容器。<view class=\"list\">\r\n    <view class=\"list-item\" wx:for=\"{{searchList}}\" >  \r\n        <view class='title'>{{item.name}}</view>\r\n        <view class='address'>{{item.district}}{{item.address}}</view>\r\n    </view>\r\n</view>在接下去调用高德接口的过程中，我们将会从接口中获得一个数组，我们将这个数组赋值给searchList，因此我们需要给容器内的列表项添加for循环。这样就能达到我们预期的效果。接着我们为输入框绑定的监听事件添加对应的方法  input: function (e) {\r\n      this.setData({\r\n        inputVal: e.detail.value\r\n      })\r\n  }同时将输入的关键字赋值给inputVal，这样我们就能在页面上看到我们输入的文字了。获取到输入的关键字，我们就可以将关键字作为参数传到高德提供的接口中，使其返回数据。我们写一个公共方法，将调用接口方法封装起来。//引入高德微信小程序SDK\r\nvar amapFile = require('amap-wx.js');\r\n\r\n//搜索关键字\r\nkeyword: function (){\r\n    var myAmapFun = new amapFile.AMapWX({key: '高德Key'}),that = this;\r\n    myAmapFun.getInputtips({\r\n        keywords:'关键字',\r\n        location: '',\r\n        success: function (data) {\r\n          if (data && data.tips) {\r\n            //将数据赋值到searchList\r\n            that.setData({searchList: data.tips});\r\n          }  \r\n        }\r\n    });\r\n }到此我们写好了接口逻辑，现在我们将整个流程打通；为了提升用户的使用体验，在用户输入关键字的同时触发搜索，实时返回结果。input: function (e) {\r\n      this.setData({\r\n        inputVal: e.detail.value\r\n      });\r\n      //在监听的方法中添加搜索关键字的方法\r\n     this.keyword(e.detail.value);\r\n  }这样，每当用户输入关键字时就能实时得到返回结果。我们从接口中提取想要的数据，在页面上展示。   <view class=\"list-item\" wx:for=\"{{searchList}}\" > \r\n       <image class=\"icon\" mode=\"widthFix\" src=\"../../images/icon.png\"></image> \r\n       <view class='title'>{{item.name}}</view>\r\n       <view class='address'>{{item.district}}{{item.address}}</view>\r\n   </view>为增强UI效果我们添加一些合理的样式和小图标作为美化。到这里我们基本已经完成了大致的需求。但是细节方面我们也需要注意；比如：当用户尚未输入关键，或者关键字长度为0的时候，列表容器应该处于不显示状态。当然我们还可以在输入框上添加清除输入内容的按钮来提升使用体验。或者在输入框的左侧添加城市选择，获取经纬度后传入封装的keyword()方法，就能根据不同的城市来做搜索。"}
{"title": "微信小程序之购物车和父子组件传值及calc的注意事项 ", "author": "Rolan", "pub_time": "2018-11-13 00:57", "content": "1.效果图2.子组件实现要实现图中删除的效果，使用组件的形式更好做点，我当时本想直接在pages里实现，不过结果就是，滑动时，所有的商品都显示了删除按钮，除非用数组将每个商品要移动的距离存储起来，不过这样的话就很麻烦，所以我也是用组件来实现的关于微信组件，可以直接点击链接访问官网查看自定义组件子组件index.wxml<view class=\"commodityItem\" bindtouchstart=\"handleTouchStart\" bindtouchmove=\"handleTouchMove\" style=\"transform:translateX({{-rightSpace}}px)\">\r\n  <view class=\"selectedBtn\" bindtap=\"handleSelect\" data-is-selected=\"{{commodity.isselected}}\">\r\n    <view class=\"noSelected\" wx:if=\"{{commodity.isselected==0}}\"></view>\r\n    <image class=\"selectedImg\" wx:else src=\"/images/selected.png\"></image>\r\n  </view>\r\n  <view class=\"commodityInfo\">\r\n    <view class=\"commodityImg\">\r\n      <image src=\"{{commodity.image}}\"></image>          \r\n    </view>\r\n    <view class=\"commodityTitle\">\r\n      <view class=\"title\">{{commodity.title}}</view>\r\n      <view class=\"standard\">规格：{{commodity.standard?commodity.standard:'无'}}</view>\r\n      <view class=\"count\">\r\n        <view class=\"price\">￥{{commodity.price}}</view>\r\n        <view class=\"commodityNum\">\r\n          <i-input-number value=\"{{selectedNum}}\" min=\"1\" max=\"{{commodity.stock}}\" bindchange=\"numChange\" />\r\n        </view>\r\n      </view>\r\n    </view>\r\n  </view>\r\n  <view class=\"deleteBtn\">\r\n    <image class=\"deleteImg\" src=\"/images/delete.png\"></image>\r\n    <text class=\"deleteText\">删除</text>\r\n  </view>\r\n</view>子组件index.wxss/* 商品 */\r\n.commodityItem{\r\n  display: flex;\r\n  position: relative;\r\n  padding: 10rpx 24rpx 20rpx 30rpx;\r\n  box-sizing: border-box;\r\n  background: #fff;\r\n  transition: all .5s;\r\n}\r\n/* 选择按钮 */\r\n.selectedBtn{\r\n  display: flex;\r\n  align-items: center;\r\n  width: 80rpx;\r\n}\r\n.noSelected{\r\n  width: 46rpx;\r\n  height: 46rpx;\r\n  border-radius: 50%;\r\n  border: 1px solid #ef5225;\r\n}\r\n.selectedBtn .selectedImg{\r\n  width: 50rpx;\r\n  height: 50rpx;\r\n}\r\n/* 商品信息 */\r\n.commodityInfo{\r\n  display: flex;\r\n  width: calc(100% - 80rpx);\r\n}\r\n.commodityImg{\r\n  margin-right: 18rpx;\r\n  width: 220rpx;\r\n  height: 220rpx;\r\n}\r\n.commodityImg image{\r\n  width: 100%;\r\n  height: 100%;\r\n  vertical-align: middle;  \r\n}\r\n/* 商品title */\r\n.commodityTitle{\r\n  width: calc(100% - 220rpx);\r\n}\r\n.title{\r\n  display: -webkit-box;\r\n  width: 100%;\r\n  height: 70rpx;\r\n  line-height:35rpx;\r\n  font-size: 24rpx;\r\n  font-weight:600;\r\n  overflow: hidden;\r\n  -webkit-line-clamp: 2;\r\n  -webkit-box-orient: vertical;\r\n}\r\n.standard{\r\n  padding-top: 16rpx;\r\n  width: 100%;\r\n  height: 90rpx;\r\n  box-sizing: border-box;\r\n}\r\n.count{\r\n  display: flex;\r\n  align-items: center;\r\n  justify-content: space-between;\r\n  width: 100%;\r\n  height: 60rpx;\r\n}\r\n\r\n/* 删除按钮 */\r\n.deleteBtn{\r\n  display: flex;\r\n  position: absolute;\r\n  width: 70px;\r\n  height: 100%;\r\n  top: 0rpx;\r\n  right: -70px;\r\n  flex-direction: column;\r\n  align-items: center;\r\n  justify-content: center;\r\n  background: #ef5225;\r\n}\r\n.deleteImg{\r\n  margin-bottom: 10rpx;\r\n  width: 50rpx;\r\n  height: 50rpx;\r\n  vertical-align: middle;\r\n}\r\n.deleteText{\r\n  color: #fff;\r\n}子组件index.json，这里用了iview中的数字输入框{\r\n  \"component\": true,\r\n  \"usingComponents\": {\r\n    \"i-input-number\": \"/component/iview/input-number/index\"\r\n  }\r\n}子组件index.jsComponent({\r\n\r\n  properties: {\r\n    commodity: Object,\r\n  },\r\n\r\n  data: {\r\n    touchStart: null,\r\n    rightSpace: 0,\r\n    selectedNum: 1,\r\n  },\r\n\r\n  methods: {\r\n    /* 商品是否选中 */\r\n    handleSelect() {\r\n            let selectedNum = this.data.selectedNum;\r\n      let commodity = this.data.commodity;\r\n      if(commodity.isselected == 0) {\r\n        commodity.isselected = 1;\r\n      } else {\r\n        commodity.isselected = 0;\r\n      }\r\n            this.triggerEvent('handleselect', { commodity, selectedNum})\r\n    },\r\n    /* 处理触摸滑动开始 */\r\n    handleTouchStart(e) {\r\n      /* 记录触摸滑动初始位置 */\r\n      let touchStart = e.changedTouches[0].clientX;\r\n      this.setData({\r\n        touchStart\r\n      })\r\n    },\r\n    /* 处理触摸滑动 */\r\n    handleTouchMove(e) {\r\n      console.log(e)\r\n      let moveSpace = e.changedTouches[0].clientX;\r\n      let touchStart = this.data.touchStart;\r\n      if (touchStart != null) {\r\n        if (moveSpace - touchStart > 70) {\r\n          this.setData({\r\n            touchStart: null,\r\n            rightSpace: 0\r\n          })\r\n        }\r\n        else if (moveSpace - touchStart < -70) {\r\n          this.setData({\r\n            touchStart: null,\r\n            rightSpace: 70\r\n          })\r\n        }\r\n      }\r\n    },\r\n    numChange(e) {\r\n        let selectedNum = e.detail.value;\r\n        let commodity = this.data.commodity;\r\n        this.setData({\r\n            selectedNum\r\n        })\r\n        this.triggerEvent('handleselect', { commodity, selectedNum})\r\n    }\r\n  }\r\n})3.父组件实现父组件index.wxml，这里用的是假数据，所以操作上会有一些是联调时不必要的操作<view class=\"cart\">\r\n  <view class=\"item\" wx:for=\"{{cartList}}\" wx:key=\"{{items.shopid}}\" wx:for-item=\"items\">\r\n    <view class=\"storeInfo\">\r\n      <image class=\"avatar\" src=\"{{items.logo}}\"></image>\r\n      <view class=\"storeName\">{{items.shopname}}</view>\r\n    </view>\r\n    <view class=\"discount\">满￥100包邮，满10件包邮</view>\r\n    <view class=\"commodity\" wx:for=\"{{items.commodity}}\" wx:key=\"{{item.id}}\">\r\n      <cart-item commodity=\"{{item}}\" bind:handleselect=\"handleSelect\" />\r\n    </view>\r\n  </view>\r\n    <view class=\"count\">\r\n        <view class=\"selectAll\" bindtap=\"handleSelectAll\">\r\n            <view class=\"noSelected\" wx:if=\"{{!isSelectedAll}}\"></view>\r\n        <image class=\"selectedImg\" wx:else src=\"/images/selected.png\"></image>\r\n            <text class=\"selectAllText\">全选</text>\r\n        </view>\r\n        <view class=\"countPrice\">\r\n      <text>合计:</text>\r\n      <text>￥{{countPrice}}</text>\r\n    </view>\r\n        <view class=\"account\">\r\n      <text>结算</text>\r\n      <text>({{countSelectedNum}})</text>\r\n    </view>\r\n    </view>\r\n</view>父组件index.wxsspage{\r\n  background: #f8f8f8;\r\n}\r\n.cart{\r\n    padding-bottom: 100rpx;\r\n  font-size: 26rpx;\r\n}\r\n.item{\r\n  border-bottom: 1px solid #eee;\r\n}\r\n/* 头部店铺信息 */\r\n.storeInfo{\r\n  display: flex;\r\n  padding: 18rpx 0rpx 18rpx 30rpx;\r\n  background: #fff;\r\n  box-sizing: border-box;\r\n}\r\n.storeInfo .avatar{\r\n  width: 56rpx;\r\n  height: 56rpx;\r\n  border-radius: 50%;\r\n  vertical-align: middle;\r\n}\r\n.storeInfo .storeName{\r\n  margin-left: 16rpx;\r\n  line-height: 56rpx;\r\n}\r\n/* 包邮信息 */\r\n.discount{\r\n  padding-left: 30rpx;\r\n  height:50rpx;\r\n  line-height: 50rpx;\r\n  font-size:20rpx;\r\n  color: #666;\r\n  box-sizing: border-box;\r\n}\r\n/* 底部操作 */\r\n.count{\r\n    display: flex;\r\n    position: fixed;\r\n    padding-left: 30rpx;\r\n    bottom: 0;\r\n  left: 0;\r\n    width: 100%;\r\n    height: 100rpx;\r\n    line-height: 100rpx;\r\n  box-sizing: border-box;\r\n  color: #232323;\r\n    background: #eee;\r\n}\r\n/* 全选 */\r\n.selectAll{\r\n    display: flex;\r\n  padding-right: 20rpx;\r\n    align-items: center;\r\n    width: 25%;\r\n  font-size: 30rpx;\r\n}\r\n.selectAll .noSelected{\r\n  width: 46rpx;\r\n  height: 46rpx;\r\n  border-radius: 50%;\r\n  border: 1px solid #ef5225;\r\n}\r\n.selectAll .selectedImg{\r\n  width: 50rpx;\r\n  height: 50rpx;\r\n}\r\n.selectAllText{\r\n    margin-left: 18rpx;\r\n}\r\n\r\n.countPrice{\r\n    position: absolute;\r\n  top: 0;\r\n  right: 270rpx;\r\n  height: 100%;\r\n  line-height: 100rpx;\r\n  text-align: center;\r\n  font-size: 30rpx;\r\n}\r\n.countPrice text{\r\n  margin-right: 15rpx;\r\n}\r\n.account{\r\n  position: absolute;\r\n  top: 0;\r\n  right: 0;\r\n    width: 270rpx;\r\n  height: 100%;\r\n  line-height: 100rpx;\r\n  text-align: center;\r\n  font-size: 30rpx;\r\n  background: #ef5225;\r\n  color: #fff;\r\n}父组件index.json，引用子组件{\r\n  \"usingComponents\": {\r\n    \"cart-item\": \"/component/cart/index\"\r\n  }\r\n}父组件index.jsPage({\r\n\r\n  data: {\r\n    cartList: [\r\n      {\r\n        shopname: '猫咪小店',\r\n        logo: '/images/avatar.jpeg',\r\n        shopid: 11,\r\n        commodity: [\r\n          {\r\n            id: 1,\r\n            image:'/images/commodity.jpg',\r\n            title: '雅诗兰黛鲜活焕亮红石榴晚霜50ml 补水保湿 滋润排浊',\r\n            standard: '111 + 黑色',\r\n            price: '100',\r\n            stock: 10,\r\n            quantity: 1,\r\n            isselected: 0,\r\n          }, \r\n          {\r\n            id: 2,\r\n            image:'/images/avatar7.jpg',\r\n            title: '雅诗兰黛鲜活焕亮红石榴晚霜50ml 补水保湿 滋润排浊',\r\n            price: '10',\r\n            stock: 5,\r\n            quantity: 1,\r\n            isselected: 0,\r\n          }\r\n        ]\r\n      },\r\n      {\r\n        shopname: '猫咪小店',\r\n        logo: '/images/avatar5.jpg',\r\n        shopid: 450,\r\n        commodity: [\r\n          {\r\n            id: 3,\r\n            image:'/images/commodity.jpg',\r\n            title: '雅诗兰黛鲜活焕亮红石榴晚霜50ml 补水保湿 滋润排浊',\r\n            price: '90',\r\n            stock: 10,\r\n            quantity: 1,\r\n            isselected: 0,\r\n          },\r\n          {\r\n            id: 4,\r\n            image:'/images/avatar7.jpg',\r\n            title: '雅诗兰黛鲜活焕亮红石榴晚霜50ml 补水保湿 滋润排浊',\r\n            price: '100',\r\n            stock: 5,\r\n            quantity: 1,\r\n            isselected: 0,\r\n          }, \r\n          {\r\n            id: 5,\r\n            image:'/images/commodity.jpg',\r\n            title: '雅诗兰黛鲜活焕亮红石榴晚霜50ml 补水保湿 滋润排浊',\r\n            standard: '111 + 黑色',\r\n            price: '100',\r\n            stock: 2,\r\n            quantity: 1,\r\n            isselected: 0,\r\n          }\r\n        ]\r\n      },\r\n      {\r\n        shopname: '猫咪小店',\r\n        logo: '/images/avatar.jpeg',\r\n        shopid: 550,\r\n        commodity: [\r\n          {\r\n            id: 6,\r\n            image:'/images/avatar8.jpg',\r\n            title: '雅诗兰黛鲜活焕亮红石榴晚霜50ml 补水保湿 滋润排浊',\r\n            standard: '111 + 黑色',\r\n            price: '100',\r\n            stock: 1,\r\n            quantity: 1,\r\n            isselected: 0,\r\n          }\r\n        ]\r\n      },\r\n    ],\r\n        /* 商品是否全选中 */\r\n        isSelectedAll: false,\r\n        /* 已选中商品的价格 */\r\n        countPrice: 0,\r\n    /* 统计所有选中的商品数量 */\r\n    countSelectedNum: 0,\r\n  },\r\n  /* 处理商品选中 */\r\n  handleSelect(e) {\r\n        let countPrice = 0;\r\n    let countSelectedNum = 0;\r\n    let cartList = this.data.cartList;\r\n    let length = cartList.length;\r\n\r\n        /* 因为是假数据，所以需要循环查找到对应的数据将其替换 */\r\n    for(let i = 0; i < length; i++) {\r\n      for(let j = 0; j < cartList[i].commodity.length; j++) {\r\n                if (cartList[i].commodity[j].id == e.detail.commodity.id) {\r\n          cartList[i].commodity[j] = e.detail.commodity;\r\n          cartList[i].commodity[j].selectedNum = e.detail.selectedNum;\r\n        }\r\n        if (cartList[i].commodity[j].isselected == 1) {\r\n          /* 点击选中的时候，计算价格，要判断下设置的商品选中数量，\r\n           * 我这里的是对点击了的商品才设置了选中的数量，所以需要对没有点击的商品数量设置为1，然后就默认的加一\r\n           */\r\n          if (cartList[i].commodity[j].selectedNum != undefined) {\r\n            countPrice += cartList[i].commodity[j].price * cartList[i].commodity[j].selectedNum;\r\n            countSelectedNum += cartList[i].commodity[j].selectedNum\r\n          } else {\r\n            countPrice += cartList[i].commodity[j].price * 1;\r\n            countSelectedNum += 1;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n        /* 对是否全选中进行判断 */\r\n        let isSelectedAll = true;\r\n        for (let i = 0; i < length; i++) {\r\n            for (let j = 0; j < cartList[i].commodity.length; j++) {\r\n                /* 若商品中的isselecetd有为0的就终止循环，直接设置为未全选 */\r\n                if (cartList[i].commodity[j].isselected == 0) {\r\n                    isSelectedAll = false;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n    this.setData({\r\n      cartList,\r\n            isSelectedAll,\r\n            countPrice,\r\n      countSelectedNum\r\n    })\r\n  },\r\n    /* 全选中商品 */\r\n    handleSelectAll() {\r\n        let isSelectedAll = !this.data.isSelectedAll;\r\n        let cartList = this.data.cartList;\r\n        let length = cartList.length;\r\n    let countPrice = 0;\r\n    let countSelectedNum = 0;\r\n\r\n        /* 遍历数据中的isselected来进行全选的操作 */\r\n        for(let i = 0; i < length; i++) {\r\n            for (let j = 0; j < cartList[i].commodity.length; j++) {\r\n                if(isSelectedAll) {\r\n                    cartList[i].commodity[j].isselected = 1;\r\n          /* 全选的时候，计算价格，要判断下设置的商品选中数量，\r\n           * 我这里的是对点击了的商品才设置了选中的数量，所以需要对没有点击的商品数量设置为1，然后就默认加一\r\n           */\r\n          if (cartList[i].commodity[j].selectedNum != undefined) {\r\n            countPrice += parseInt(cartList[i].commodity[j].price) * cartList[i].commodity[j].selectedNum;\r\n            countSelectedNum += cartList[i].commodity[j].selectedNum;\r\n          } else {\r\n            countPrice += cartList[i].commodity[j].price * 1;    \r\n            countSelectedNum += 1;        \r\n          }\r\n                } else {\r\n                    cartList[i].commodity[j].isselected = 0;\r\n                }\r\n            }\r\n        }\r\n\r\n        this.setData({\r\n            isSelectedAll,\r\n            cartList,\r\n      countPrice,\r\n      countSelectedNum\r\n        })\r\n    },\r\n})4.父子组件传值较常用的都是父组件往子组件传值，所以子组件往父组件传值就会不是很熟悉我这里的话，是因为用的假数据，在点击商品选中或者不选中时，需要改变商品里的选中属性，所以用到了子组件往父组件传值，也包括传递选中的商品数量子组件往父组件传值的话，是通过在调用this.triggerEvent()来实现的/* 在父组件中定义方法：bind:handleselect或者也可以直接写成bindhandleselect*/\r\n<cart-item commodity=\"{{item}}\" bind:handleselect=\"handleSelect\" />在子组件中调用this.triggerEvent('handleselect', { commodity, selectedNum})这个this.triggerEvent('handleselect', { commodity, selectedNum })方法中，handleselect的名称要与父组件中引用子组件时绑定的方法名称一样，后面的对象就是传递的值，也可以直接是以直接量的形式传递，然后再父组件中通过e.detail来获取对应的值handleSelect(e) {\r\n    console.log(e.detail)\r\n    console.log(e.detail.commodity)\r\n    console.log(e.detail.selectedNum)\r\n}5.calc的注意事项我以前也遇到过，然后现在再用的时候，一时间把这点给忘了，在看到编译器样式的时候，才猛然想起.user-content{\r\n    padding: 10px 0 10px 50px;\r\n    width: calc(100% - 50px);  /* 计算宽度，'+'或'-'符号前后有空格 */\r\n    height: 18px;\r\n}css中使用calc可以进行简单的运算：单位可以是百分比，px，rem，em等单位使用\"+\",\"-\",\"*\",\"/\"运算符（使用\"+\"或者\"-\"符号时，符号前后必须加上空格）在Firefox浏览器上使用要加上-moz前缀chrome浏览器上使用要加上-webkit前缀（使用\"+\"或者\"-\"符号时，符号前后必须加上空格）6.部分想法其实在样式上还是挺快就完成了，就是在计算商品价格的时候，想了挺久在计算价格时，当时就有点蒙圈，总是想着要怎么判断他是增加数量还是减少数量，然后就陷入死循环的之中。其实不用想她是增加还是减少数量，因为你都是传的是商品的数量，而且在计算时，也是判断了商品是否选中，所以，直接点，计算价格乘以数量就可以了然后选中的商品数量的统计就和计算价格的思路是一样的了正在努力学习中，若对你的学习有帮助，留下你的印记呗（点个赞咯^_^）往期好文推荐：判断iOS和Android及PC端css实现波浪线及立方体微信小程序中遇到的多规格问题(一)实现单行及多行文字省略号"}
{"title": "vue 项目快速输出微信、支付宝、百度小程序 ", "author": "Rolan", "pub_time": "2018-11-14 00:01", "content": "上周，Megalo@0.2.0 正式发布，优化了数据更新性能的同时，支持了百度智能小程序，着实激动了一把，这“可能”是目前社区里第一个同时支持三端小程序的 vue 小程序框架。下面我们就来试试他的效果。跟着文档走官方文档的第一部分就是快速入门，顺藤摸瓜，构建一个 megalo 项目。安装$ npm install -g @megalo/cli\r\n复制代码构建$ megalo megalo-yanxuan-demo\r\n复制代码打包以微信小程序为入口$ npm run dev:wechat\r\n复制代码至此一个完整的 megalo 项目就构建好了，接下来我们开始转移源码转移 weex 项目我从以前 weex 的 demo 项目， yanxuan-weex-demo ，为基础进行转移，转移过程中涉及到很多 weex 特有的 api 的移除和转换。网络请求以网络请求为例，weex 是使用的 streamlet stream = weex.requireModule('stream');\r\nexport default {\r\n    methods: {\r\n        GET (api, callback) {\r\n            return stream.fetch({\r\n                method: 'GET',\r\n                type: 'json',\r\n                url: api\r\n            }, callback)\r\n        }\r\n    }\r\n}\r\n复制代码因为小程序都有提供网络请求的 API，所以此处对此进行改造，如下export default {\r\n    methods: {\r\n        GET (api, callback) {\r\n            let { platform } = this.$mp || {},\r\n                request = ()=>{}\r\n            switch(platform) {\r\n                case 'wechat':\r\n                    request = wx && wx.request\r\n                break;\r\n                case 'alipay':\r\n                    request = my && my.httpRequest\r\n                break;\r\n                case 'swan':\r\n                    request = swan && swan.request\r\n                break;\r\n                default:\r\n                break;\r\n            }\r\n            request && request({\r\n                url: api,\r\n                success: callback\r\n            })\r\n        }\r\n    }\r\n}\r\n复制代码类似的还有 toast、message 等组件的改造。组件由于 weex 中的 <recycle-list> 、 <loading> 、 <refresh> 、 <scroller> 等组件在小程序组件内是不存在的，所以有三种解决方案自定义一个同名 vue 组件找小程序可用的组件替换实在不行就砍掉需求吧比如 weex 的 <slider> 组件，可以用小程序的 <swiper> 替换，好在微信、支付宝和百度小程序都有支持。cssWeex 容器默认的宽度 (viewport) 是 750px，小程序以 750rpx 为基。所以直接将需要的 px 转换成 rpx。另外自己实现了 1 像素的 wpx，替换成 px 即可。执行三端效果最后看下改造效果。同时执行三端效果比预想的要好，没有过多的适配出错demo 源码 抛给大家供大家把玩。哪些可以转只要现有工程没有做以下几件事，理论上，都是可以转移的，只需要稍微更新一下格式使用 megalo 暂不支持的 vue 特性涉及浏览器特有的 dom 操作，window、userAgent、location、getElementById 等使用第三方组件库且该组件库使用了 dom 操作使用了 vue-router，暂不支持全局使用 vuex不过，方案都是可以调整的，以上功能在社区均可以找到替代方案。换之即可。"}
{"title": "浅析微信支付：查询订单和关闭订单 ", "author": "Rolan", "pub_time": "2018-11-9 00:30", "content": "浅析微信支付系列已经更新六篇了哟～，没有看过的朋友们可以看一下哦。浅析微信支付：支付结果通知浅析微信支付：统一下单接口浅析微信支付：微信公众号网页授权声明：这里的查询订单、关闭订单接口仅适用于 小程序支付、公共号支付、扫码支付、APP支付，刷卡支付方式此处并不适用。1、查询订单以下为微信官方的查询订单文档：https://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=9_21.1. 应用场景该接口提供所有微信支付订单的查询，商户可以通过查询订单接口主动查询订单状态，完成下一步的业务逻辑。需要调用查询接口的情况：\r\n◆ 当商户后台、网络、服务器等出现异常，商户系统最终未接收到支付通知；\r\n◆ 调用支付接口后，返回系统错误或未知交易状态情况；\r\n◆ 调用刷卡支付API，返回USERPAYING的状态；\r\n◆ 调用关单或撤销接口API之前，需确认支付状态；1.2. 接口链接https://api.mch.weixin.qq.com/pay/orderquery1.3. 是否需要证书不需要1.4. 调用接口查询订单接口需要使用微信订单号或者商户订单号来查询，其他参数为商户平台信息的公共参数，为常量，此处省略解释。微信订单号：transaction_id（微信的订单号，建议优先使用）\r\n商户订单号：out_trade_no（商户系统内部订单号）此两个参数必填其中之一，微信推荐使用微信订单号来查询，下面为实现代码：private void doOrderQuery() {\r\n    System.out.println(\"查询订单\");\r\n    HashMap<String, String> data = new HashMap<String, String>();\r\n    // data.put(\"out_trade_no\", out_trade_no);\r\n    data.put(\"transaction_id\", \"4008852001201608221962061594\");\r\n    try {\r\n        WXPay wxPay = new WXPay(WXPayConfigImpl.getInstance());\r\n        Map<String, String> r = wxPay.orderQuery(data);\r\n        System.out.println(r);\r\n    } catch (Exception e) {\r\n        e.printStackTrace();\r\n    }\r\n}wxPay.orderQuery方法为封装的sdk方法，具体实现请参考作者github源码。对于商户关键信息的写入，公共方法为wxPay.fillRequestData，实现如下：/**\r\n * 向 Map 中添加 appid、mch_id、nonce_str、sign_type、sign <br>\r\n * 该函数适用于商户适用于统一下单等接口，不适用于红包、代金券接口\r\n *\r\n * @param reqData r\r\n * @return map\r\n * @throws Exception e\r\n */\r\npublic Map<String, String> fillRequestData(Map<String, String> reqData) throws Exception {\r\n    reqData.put(\"appid\", config.getAppID());\r\n    reqData.put(\"mch_id\", config.getMchID());\r\n    reqData.put(\"nonce_str\", WXPayUtil.generateNonceStr());\r\n    if (SignType.MD5.equals(this.signType)) {\r\n        reqData.put(\"sign_type\", WXPayConstants.MD5);\r\n    } else if (SignType.HMACSHA256.equals(this.signType)) {\r\n        reqData.put(\"sign_type\", WXPayConstants.HMACSHA256);\r\n    }\r\n    reqData.put(\"sign\", WXPayUtil.generateSignature(reqData, config.getKey(), this.signType));\r\n    return reqData;\r\n}以上为查询微信订单的使用方式，具体的返回参数请参考官方文档。2、关闭订单以下为微信官方的关闭订单文档：https://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=9_32.1. 应用场景以下情况需要调用关单接口：商户订单支付失败需要生成新单号重新发起支付，要对原订单号调用关单，避免重复支付；\r\n系统下单后，用户支付超时，系统退出不再受理，避免用户继续，请调用关单接口。注意：订单生成后不能马上调用关单接口，最短调用时间间隔为5分钟。2.2. 接口链接https://api.mch.weixin.qq.com/pay/closeorder2.3. 是否需要证书不需要2.4. 调用接口关闭订单接口需要使用商户订单号来查询，其他参数为商户平台信息的公共参数，为常量，此处省略解释。商户订单号：out_trade_no（商户系统内部订单号）PS：关单接口只能使用微信订单号来查询，和查询接口不同，下面为实现代码：private void doOrderClose() {\r\n    System.out.println(\"关闭订单\");\r\n    HashMap<String, String> data = new HashMap<String, String>();\r\n    data.put(\"out_trade_no\", out_trade_no);\r\n    try {\r\n        WXPay wxPay = new WXPay(WXPayConfigImpl.getInstance());\r\n        Map<String, String> r = wxPay.closeOrder(data);\r\n        System.out.println(r);\r\n    } catch (Exception e) {\r\n        e.printStackTrace();\r\n    }\r\n}关单接口的公共参数设置和查询订单一致，这里就不重复解释了，具体的返回参数请参考微信官方文档。PS：关单接口可能会调用失败，已支付、已关闭等场景，所以需要开发者注意官方文档中的错误码，对异常情况进行处理。结语以上为查询订单、关闭订单的调用方式，如果是刷卡支付方式，他的关闭订单接口为撤销订单:reverse，在作者sdk源码中也有具体的实现方式。预告：下一篇文章 申请退款和退款回调接口，敬请期待！！！​如果想要提前一览源码的小伙伴，可以先看看我的 github，地址如下：​https://github.com/YClimb/wxpay-sdk/blob/master/README.md加作者私人微信，作者微信号如下 yclimb，标明 微信支付 可拉入微信支付讨论群与小伙伴一起探讨哦，一定要标明 微信支付 哦～"}
{"title": "微信小程序之animation底部弹窗动画（两种方法） ", "author": "Rolan", "pub_time": "2018-10-31 00:26", "content": "简单分享一下常用的底部弹窗层或下拉框弹出层（代码需要修改）的内容弹窗的动画效果，这里分享的是点击按钮后底部弹窗的动画效果。第一种方式是动态设置显示区域的高度，第二种方法是动态设置显示区域的移动的位置（使用到 transform:translateY ）；（一）实现效果简单说明一下，两种方法实现的效果是一样的，只有点击按钮才能出发弹窗（指定位置），弹窗弹出后，只有点击背景灰色区域弹窗才能收回，点击弹窗内容区域（粉红色部分是不能收回弹窗的），自己可以自定义粉红色部分右上角关闭按钮。（二）实现分析第一种动态设置高度的方法是：需要一个容器为背景色（灰色区域），一个容器为弹窗内容（粉红色区域），两者是独立的，实现的原理是一样的；粉红色区域的话，就是设置好绝对位置（在屏幕的底部）和默认内容的区域样式，动态设置内容区域的高度，比如弹出：一开始高度为0（隐藏了），通过animation设置的动画时间，将高度从0到指定高度，内容慢慢就会显示了，然后保留最后一帧的动画样式就行了；收缩也是一样的道理。第二种动态设置位置的方法是：需要一个容器为背景色（灰色区域），一个容器为弹窗内容（粉红色区域），两者是独立的，实现的原理是一样的；粉红色区域的话，就是设置好绝对位置（在屏幕的底部）和默认内容的区域样式，比如弹出：一开始粉红色区域的位置平移在屏幕外（隐藏了），通过animation设置的动画时间，将粉红色区域从屏幕外平移到屏幕内（默认设置在屏幕底部的位置），内容慢慢就会显示了，然后保留最后一帧的动画样式就行了；收缩也是一样的道理。 代码也有注释哈。（三）实现代码第一种动态设置高度方法实现：1、wxml代码：<button catchtap='clickPup'>点击底部动画弹窗</button>\r\n\r\n<!-- 底部弹窗动画的内容 -->\r\n<view class='pupContent {{click? \"showContent\": \"hideContent\"}} {{option? \"open\": \"close\"}}' hover-stop-propagation='true'>\r\n  <view class='pupContent-top'>测试一下</view>\r\n</view>\r\n<!-- 固定的背景 -->\r\n<view class='pupContentBG {{click?\"showBG\":\"hideBG\"}} {{option?\"openBG\":\"closeBG\"}}' catchtap='clickPup'>\r\n</view>\r\n复制代码2、wxss代码：.pupContentBG {\r\n  width: 100vw;\r\n  height: 100vh;\r\n  position: fixed;\r\n  top: 0;\r\n}\r\n\r\n.pupContent {\r\n  width: 100%;\r\n  background: pink;\r\n  position: absolute;\r\n  bottom: 0;\r\n  box-shadow: 0 0 10rpx #333;\r\n  height: 0;\r\n  z-index: 999;\r\n}\r\n\r\n/* 设置显示的背景 */\r\n\r\n.showBG {\r\n  display: block;\r\n}\r\n\r\n.hideBG {\r\n  display: none;\r\n}\r\n\r\n/* 弹出或关闭动画来动态设置内容高度 */\r\n\r\n@keyframes slideBGtUp {\r\n  from {\r\n    background: transparent;\r\n  }\r\n\r\n  to {\r\n    background: rgba(0, 0, 0, 0.1);\r\n  }\r\n}\r\n\r\n@keyframes slideBGDown {\r\n  from {\r\n    background: rgba(0, 0, 0, 0.1);\r\n  }\r\n\r\n  to {\r\n    background: transparent;\r\n  }\r\n}\r\n\r\n/* 显示或关闭内容时动画 */\r\n\r\n.openBG {\r\n  animation: slideBGtUp 0.5s ease-in both;\r\n  /* animation-fill-mode: both 动画将会执行 forwards 和 backwards 执行的动作。 */\r\n}\r\n\r\n.closeBG {\r\n  animation: slideBGDown 0.5s ease-in both;\r\n  /* animation-fill-mode: both 动画将会执行 forwards 和 backwards 执行的动作。 */\r\n}\r\n\r\n/* 设置显示内容 */\r\n\r\n.showContent {\r\n  display: block;\r\n}\r\n\r\n.hideContent {\r\n  display: none;\r\n}\r\n\r\n/* 弹出或关闭动画来动态设置内容高度 */\r\n\r\n@keyframes slideContentUp {\r\n  from {\r\n    height: 0;\r\n  }\r\n\r\n  to {\r\n    height: 800rpx;\r\n  }\r\n}\r\n\r\n@keyframes slideContentDown {\r\n  from {\r\n    height: 800rpx;\r\n  }\r\n\r\n  to {\r\n    height: 0;\r\n  }\r\n}\r\n\r\n/* 显示或关闭内容时动画 */\r\n\r\n.open {\r\n  animation: slideContentUp 0.5s ease-in both;\r\n  /* animation-fill-mode: both 动画将会执行 forwards 和 backwards 执行的动作。 */\r\n}\r\n\r\n.close {\r\n  animation: slideContentDown 0.5s ease-in both;\r\n  /* animation-fill-mode: both 动画将会执行 forwards 和 backwards 执行的动作。 */\r\n}\r\n\r\n复制代码3、js代码：data: {\r\n    click: false, //是否显示弹窗内容\r\n    option: false, //显示弹窗或关闭弹窗的操作动画\r\n  },\r\n\r\n  // 用户点击显示弹窗\r\n  clickPup: function() {\r\n    let _that = this;\r\n    if (!_that.data.click) {\r\n      _that.setData({\r\n        click: true,\r\n      })\r\n    }\r\n\r\n    if (_that.data.option) {\r\n      _that.setData({\r\n        option: false,\r\n      })\r\n\r\n      // 关闭显示弹窗动画的内容，不设置的话会出现：点击任何地方都会出现弹窗，就不是指定位置点击出现弹窗了\r\n      setTimeout(() => {\r\n        _that.setData({\r\n          click: false,\r\n        })\r\n      }, 500)\r\n\r\n\r\n    } else {\r\n      _that.setData({\r\n        option: true\r\n      })\r\n    }\r\n  },\r\n\r\n复制代码第二种动态平移内容区域位置方法实现：相对于第一种代码修改的部分：只修改的了粉红色区域的高度和粉红色区域弹出和收回的动画效果：/* 弹出或关闭动画来动态设置内容高度 */\r\n\r\n@keyframes slideContentUp {\r\n  from {\r\n    transform: translateY(100%); /*设置为正数则底部弹出来，负数则相反*/\r\n  }\r\n\r\n  to {\r\n    transform: translateY(0%);\r\n  }\r\n}\r\n\r\n@keyframes slideContentDown {\r\n  from {\r\n    transform: translateY(0%);\r\n  }\r\n\r\n  to {\r\n    transform: translateY(100%);\r\n  }\r\n}\r\n复制代码参考资料：CSS3（三）Animation 入门详解微信小程序CSS3动画下拉菜单感谢阅读。"}
{"title": "小程序的全栈开发新时代 ", "author": "Rolan", "pub_time": "2018-10-31 00:46", "content": "本文由heyli发表于云+社区专栏什么是小程序·云开发小程序·云开发是微信团队和腾讯云团队共同研发的一套小程序基础能力，简言之就是：云能力将会成为小程序的基础能力。整套功能是基于腾讯云全新推出的 云开发(Tencent Cloud Base)所研发出来的一套完备的小程序后台开发方案。小程序·云开发为开发者提供完整的云端流程，简化后端开发和运维概念，无需搭建服务器，使用平台提供的 API 进行核心业务开发，即可实现快速上线和迭代。该解决方案目前提供三大基础能力支持：存储：在小程序前端直接上传/下载云端文件，在小程序云控制台可视化管理数据库：一个既可在小程序前端操作，也能在云函数中读写的文档型数据库云函数：在云端运行的代码，微信私有协议天然鉴权，开发者只需编写业务逻辑代码未来，我们还会集成更多的服务能力，为小程序提供更强有力的云端支持。如何使用小程序·云开发上面就是小程序·云开发简单的使用图谱：在小程序端，直接用官方提供的接口，在云函数端，直接用官方提供的 Node SDK，就可以操作你云的资源。以前开发小程序所担忧的数据库搭建、文件系统部署，通通没有。你只需要有在小程序开发 IDE 里面的 云开发 ，开通一下，填写环境 ID ，便可以拥有小程序的云能力！当然，其实用云开发，并不排斥原有的后台架构，通过下面的架构，你也可以无缝与原有的后台服务兼容，也简化了一些小程序鉴权的逻辑：接下来，我会分别从小程序端、服务端讲述如何使用这些云资源。使用云能力小程序端客户端，这里是指在小程序端中。如果要使用云开发能力，请做以下配置：在 app.json / game.json 中， 中增加字段 \"cloud\": trueproject.config.json 中增加了字段 cloudfunctionRoot 用于指定存放云函数的目录初始化云开发能力：//app.js\r\nApp({\r\n  onLaunch: function () {\r\n    wx.cloud.init({\r\n        traceUser: true // 用户信息会显示在云开发控制台的用户面板中\r\n    });\r\n  }\r\n});小程序端初始化能力文档在用户管理中会显示使用云能力的小程序的访问用户列表，默认以访问时间倒叙排列，访问时间的触发点是在小程序端调用 wx.cloud.init 方法，且其中的 traceUser 参数传值为 true 。服务端如果你想在云函数中，操作文件、数据库和云函数资源，你可以使用我们提供的服务端 SDK 进行操作。首先，进入到你的某个云函数中，安装以下依赖包：npm i --save tcb-admin-node在云函数中初始化// 初始化示例\r\nconst app = require('tcb-admin-node');\r\n\r\n// 初始化资源\r\n// 云函数下不需要secretId和secretKey。\r\n// env如果不指定将使用默认环境\r\napp.init({\r\n  secretId: 'xxxxx',\r\n  secretKey: 'xxxx', \r\n  env: 'xxx'\r\n});\r\n\r\n//云函数下使用默认环境\r\napp.init()\r\n\r\n//云函数下指定环境\r\napp.init({\r\n  env: 'xxx'\r\n});服务端初始化文档存储云开发提供存储空间、上传文件、下载文件、CDN加速文件访问等能力,开发者可以在小程序端与服务端通过 API 使用这些能力。小程序端// 选择图片\r\nwx.chooseImage({\r\n    success: dRes => {\r\n        // 上传图片\r\n        const uploadTask = wx.cloud.uploadFile({\r\n            cloudPath: `${Date.now()}-${Math.floor(Math.random(0, 1) * 10000000)}.png`, // 随机图片名\r\n            filePath: dRes.tempFilePaths[0], // 本地的图片路径\r\n            success: console.log,\r\n            fail: console.error\r\n        });\r\n    },\r\n    fail: console.error,\r\n});小程序端存储文档服务端const app = require('tcb-admin-node');\r\napp.init();\r\n\r\napp.uploadFile({\r\n    cloudPath: \"cover.png\",\r\n    fileContent: fs.createReadStream(`${__dirname}/cover.png`)\r\n}).then((res) => {\r\n    console.log(res);\r\n}).catch((err) => {\r\n    console.error(err);\r\n});;控制台上传好的文件，就会出现在控制台中，如下图。你可以在控制台里删除、下载或者查看图片的详情。你还可以控文件整体的权限，这里还有一些具体的介绍。服务端存储文档数据库小程序云提供文档型数据库 ( document-oriented database )，数据库包含多个集合（相当于关系型数据中的表），集合近似于一个 JSON 数组，数组中的每个对象就是一条记录，记录的格式是 JSON 文档。每条记录都有一个 _id 字段用以唯一标志这条记录、一个 _openid 字段用以标志记录的创建者，即小程序的用户。开发者可以自定义 _id ，但不可在小程序端自定义（在服务端可以） _openid 。 _openid 是在文档创建时由系统根据小程序用户默认创建的，开发者可使用其来标识和定位文档。数据库 API 分为小程序端和服务端两部分，小程序端 API 拥有严格的调用权限控制，开发者可在小程序内直接调用 API 进行非敏感数据的操作。对于有更高安全要求的数据，可在云函数内通过服务端 API 进行操作。云函数的环境是与客户端完全隔离的，在云函数上可以私密且安全的操作数据库。数据库 API 包含增删改查的能力，使用 API 操作数据库只需三步：获取数据库引用、构造查询/更新条件、发出请求。切记，在操作数据库前，请先在控制台中创建 collection 。小程序端const db = wx.cloud.database();\r\n\r\n// 插入数据\r\ndb.collection('photo').add({\r\n    data: {\r\n        photo: 'cloud://tcb-xxx/05ca1d38f86f90d66d4751a730379dfa6584dde05ab4-Ma9vMN_fw658.jpg',\r\n        title: '风景'\r\n    }\r\n});\r\n\r\n// 提取数据\r\ndb.collection('photo').get().then((res) => {\r\n    let data = res.data;\r\n    console.log(data);\r\n});\r\n\r\n// 输出\r\n// 在小程序端， _openid 会自动插入到数据库中\r\n{\r\n    photo: 'cloud://tcb-xxx/05ca1d38f86f90d66d4751a730379dfa6584dde05ab4-Ma9vMN_fw658.jpg',\r\n    title: '风景',\r\n    _openid: 'oLlMr5FICCQJV-QgVLVzKu1212341'\r\n}小程序端数据库文档服务端const app = require('tcb-admin-node');\r\napp.init();\r\nconst db = app.database();\r\n\r\ndb.collection('photo').limit(10).get().then((res) => {\r\n    console.log(res);\r\n}).catch((err) => {\r\n    console.error(err);\r\n});\r\n\r\n// 输出\r\n// 因为是在服务端，其它用户的也可以提取出来\r\n{\r\n    photo: 'cloud://tcb-xxx/05ca1d38f86f90d66d4751a730379dfa6584dde05ab4-Ma9vMN_fw658.jpg',\r\n    title: '风景',\r\n    _openid: 'oLlMr5FICCQJV-QgVLVzKu1342121'\r\n}\r\n{\r\n    photo: 'cloud://tcb-xxx/0dc3e66fd6b53641e328e091ccb3b9c4e53874232e6bf-ZxSfee_fw658.jpg',\r\n    title: '美女',\r\n    _openid: 'DFDFEX343xxdf-QgVLVzKu12452121'\r\n}\r\n{\r\n    photo: 'cloud://tcb-xxx/104b27e339bdc93c0da15a47aa546b6e9c0e3359c315-L8Px2Y_fw658.jpg',\r\n    title: '动物',\r\n    _openid: 'DFDFEX343xxdf-QgVLVzKu1342121'\r\n}服务端数据库文档控制台可以在控制台里，看到用户操作的数据，你也可以自己在控制台上添加、更新或删除数据。如果数据量庞大，可以设置索引提供查询的效率。数据库也可以通过设置权限，管控每个 collection 。云函数云函数是一段运行在云端的代码，无需管理服务器，在开发工具内一键上传部署即可运行后端代码。开发者可以在云函数内获取到每次调用的上下文（ appid 、 openid 等），无需维护复杂的鉴权机制，即可获取天然可信任的用户登录态（ openid ）。小程序端wx.cloud.callFunction({\r\n    name: 'addblog', // 云函数名称\r\n    data: { // 传到云函数处理的参数\r\n        title: '云开发 TCB',\r\n        content: '存储、数据库存、云函数'\r\n    }\r\n}).then(res => {\r\n    console.log(res)\r\n}).catch((err) => {\r\n    console.error(err);\r\n});小程序端云函数文档服务端const app = require(\"tcb-admin-node\");\r\napp.init();\r\n\r\napp.callFunction({\r\n    name: 'addblog', // 云函数名称\r\n    data: { // 传到云函数处理的参数\r\n        title: '云开发 TCB',\r\n        content: '存储、数据库存、云函数'\r\n    }\r\n}).then((res) => {\r\n    console.log(res);\r\n}).catch((err) => {\r\n    console.error(err);\r\n});服务端云函数文档控制台上传好之后的云函数，都会在这里罗列出来。每次调用云函数，都可以在这里看到日志，还可以构造测试的参数，用于调试。语法糖大部份的接口，目前都支持两种写法，分别是Promise 和 Async/Await，本节以 callFunction作为例子，在 云函数 中介绍这两种写法。 Async/Awai t 本质上是基于 Promise 的一种语法糖，它只是把 Promise 转换成同步的写法而已。Promiseconst app = require(\"tcb-admin-node\");\r\napp.init();\r\n\r\nexports.main = (event, context, callback) => {\r\n    app.callFunction({\r\n        name: 'addblog', // 云函数名称\r\n        data: { // 传到云函数处理的参数\r\n            title: '云开发 TCB',\r\n            content: '存储、数据库存、云函数'\r\n        }\r\n    }).then((res) => {\r\n        console.log(res);\r\n        callback(null, res.data);\r\n    }).catch((err) => {\r\n        callback(err);\r\n    });\r\n};Async/Awaitconst app = require(\"tcb-admin-node\");\r\napp.init();\r\n\r\nexports.main = async (event, context) => {\r\n    let result = null;\r\n\r\n    try {\r\n        result = await app.callFunction({\r\n            name: 'addblog', // 云函数名称\r\n            data: { // 传到云函数处理的参数\r\n                title: '云开发 TCB',\r\n                content: '存储、数据库存、云函数'\r\n            }\r\n        });\r\n    }\r\n    catch (e) {\r\n        return e;\r\n    }\r\n\r\n    return result;\r\n};在云函数里使用，由于是 Node 8.9 或以上的环境，因此天然支持 Async/Await 诘法，但在小程端要使用的话，需要额外引入 Polyfill ，比如这个开源的项目： regenerator开发者资源由于小程序·云开发是基于腾讯云的云开发开发的功能，因此在腾讯云与小程序两边都有不少的开发者资源，这里供大家参阅读：腾讯云开发者资源及文档腾讯云云开发平台官方 Github微信小程序·云开发文档"}
{"title": "微信小程序开发系列教程第七章：编辑名片页面开发 ", "author": "admin", "pub_time": "2016-10-12 22:14", "content": "编辑名片有两条路径，分为新增名片流程与修改名片流程。用户手填新增名片流程：首先跳转到我们的新增名片页面 1 需要传递用户的当前 userId，wx.navigateTo 带值跳转。Manual 为 true 设置用户走的是新增路线。新增名片页面 1 基本布局如下：取到 userId。使用微信自带的 input 组件验证也非常好用，如 maxLength 属性，可以限制用户输入长度，如我这的姓名长度是最大 5 位，直接数字 5 即可。也可以自定义一些验证效果，具体可以根据需求进行一些验证配置，取到用户输入的值，进行操作。这里绑定了自带的模态框提示组件。其中 modalHidden2 是模态框开关。另外 proptText 是需要提示的内容。即使很多输入框也支持数据动态改变，非常方便。实际效果，非常快捷，比以前省去很多事情，编写小程序，发现最大的好处可能就是我们不必去考虑一系列兼容性问题。最后还有个头像上传图片，测试了下目前上传到后台服务器还有点问题，应该是内测版本不太完善导致吧。设置的直接是背景图片。提交表单与跳转。提交表单使用的是自带的 bindsubmit 事件组件，在 button 组件上添加 formType=”submit” 即可，还有点需注意的是使用表单提交功能时 input 需加上 name 属性，这个传递方式是以键值对的形式传递的。这时候跳转到编辑页 2 页面，这个页面是根据用户填写的手机号码识别到匹配的公司，页面非常简单，一个数据循环而已，单选框日后可能还需要美化一下。同样也是一些数据绑定以及验证效果。实际渲染效果可以看到。这个和第一个编辑页面逻辑基本不相上下，一些基本验证与提交，这里就讲到前面两步骤即可，编辑页面3也是同理，这里不再过多啰嗦。修改名片流程效果图与需求，修改名片是一次性把以前填写的个人信息全部渲染出来，供用户来改动：名片图片模块，上传图片暂时还有点问题，这里就是模仿了个跳转组件，比较建议需要跳转的页面还是使用 wx.navigateTo 控制好一点，wx.navigateTo 提供了给我们不同的 3 个跳转路由，封装的都很好，而且跳转页面很多牵连到传值之类的，可以达到统一管理也可以避免一些看不到的 bug 吧，总之还是根据业务需求来定：姓名手机必填模块：个人信息模块，直接循环（block）出来：Onload 时我们请求必填与选填数据：* requiredGroup 必填中文信息* notRequiredGroup 选题中文信息* requiredGroupEn 必填英文信息* notRequiredGroupEn 选题英文信息```//请求名片对应的公司的中文信息的属性组数据，分为必填和选填//选题项变量以 no 开头requester.getOfflineCardInfoGroupFields(userId, cardId,function (res) {//debuggervar userName = res.card.userName;var mobile = res.card.mobile;var requiredGroup = res.requiredGroupCh;var notRequiredGroup = res.notRequiredGroupCh;var requiredGroupEn = res.requiredGroupEn;var notRequiredGroupEn = res.notRequiredGroupEn;var reqLen = requiredGroup.fields.length;var nreqLen = notRequiredGroup.fields.length;var reqLenEn = requiredGroupEn.fields.length;var nreqLenEn = notRequiredGroupEn.fields.length;self.setData({userName: userName,mobile: mobile,requireFields: requiredGroup.fields,notRequireFields: notRequiredGroup.fields,requireFieldsEn: requiredGroupEn.fields,notRequireFieldsEn: notRequiredGroupEn.fields,l1: reqLen,l2: nreqLen + reqLen,l3: reqLenEn + nreqLen + reqLen});self.forceUpdate();}, function (code, msg) {console.info(\"code=\" + code + \"&msg=\" + msg);});```中英文信息必填与选填渲染：这里表单提交数据转换有点复杂（大家根据业务需求来做，不必花时间研究这里的方法），获取的是数组，按照后台需要的数据格式进行转换传递过去。今天再回去理下首页 A、B、C 定点跳转功能实现方法。首先是右边小索引布局以及数据绑定，数据绑定和名片夹列表上的字母一样，该字母下面有名片则渲染出来，没有则不需要渲染，id同样是当前字母与右边显示的内容一样：数据 sort，和 group.name 数据一样：这里是因为 # 不支持设为 id（就是 id=”#”），故而进行了一个转化。点击事件：获取到当前 ID，以及绑定数据 toView 为当前 ID。首先名片列表，名片上的字母索引都在 scroll-view 里面，这个 scroll-view 必须设置好固定的高度，设置成 100% 与 100vh 是无效的，y 轴的滚动开关打开，scroll-into-view 需要跳转到它子元素的 id 上。可以看下：这个 group.name==sortmsg，等于就是 A==A,B==B 同理。在这里如顶部有些菜单栏的话，你就要注意好布局了，不然会出现向下偏移这个菜单栏的高度，其实你只要和字母索引同级下即可避免此问题（这里的顶部菜单以模板分离出去了，分离模板的时候需注意下，需要在这里绑定模板的一些数据会出现失效，具体没有继续深入研究下去）。跳转功能基本实现（ohter 就是 # 底部）。"}
{"title": "小程序中打开网页和pdf ", "author": "Rolan", "pub_time": "2018-8-23 00:12", "content": "打开网页的方法有两种第一种是最简单的微信官方提供的方法，直接把要打开的网页地址赋给web-view标签的src属性     <web-view src=\"{{article}}\"> </web-view>第二种需要引入一个第三方插件，下面的写法只适用于wepy框架中，其他框架中写法略有不同。<template><view>    //插件中的固定写法    <import src=\"../../wxParse/wxParse.wxml\" />    <template is=\"wxParse\" data=\"{{wxParseData:article.nodes}}\" />    <view wx:if='article' class='addclass'></view></view></template><script>//引入插件import WxParse from \"../../wxParse/wxParse\";export default class webview extends wepy.page {    data = {        //网页地址路径        article: '',    }    methods = {    }    async onLoad(options) {        let ret = await api.rentalContracts({            id: this.id,            method: 'GET'        });        this.article = ret.data        //调用插件中的方法设置article中的网页路径        WxParse.wxParse('article', 'html', this.article, this, 1);    }}打开phf文件给按钮定义一个preview方法，在downloadFile方法中调用wx.openDocument方法就可以实现。       preview() {            let that=this.            wx.downloadFile({                url: 'https://www.*******.com/contract/default/pdf',                success: function(res) {                    console.log(res)                    var Path = res.tempFilePath //返回的文件临时地址，用于后面打开本地预览所用                    that.webview=Path                    wx.openDocument({                        filePath: Path,                        success: function(res) {                            console.log('打开文档成功')                        }                    })                },                fail: function(res) {                    console.log(res)                }            })        },作者：王炳祺 链接：https://www.jianshu.com/p/098fd010d88b"}
{"title": "微信小程序抽奖-翻牌 ", "author": "Rolan", "pub_time": "2018-8-31 00:21", "content": "背景ps：本次开发基于wepy框架 由于最近接到一个需求--抽奖活动； 翻牌打乱活动抽奖活动，大概需求是这样的，九宫格卡牌，先正面展示所有奖品，然后卡牌翻转，打乱排序，点击卡牌，然后抽奖。这个需求本身其实不难，主要是分为三步；展示所有卡牌，然后翻转。打乱所有卡牌点击其中一张卡牌，抽奖第一步：卡牌翻转我们先在dom中渲染9个卡牌。<view class=\"card-module\">  <view class=\"card {{showClass ? 'change' : ''}}>    <view class=\"front card-item\">{{cardItem.front}}</view>    <view class=\"back card-item\">{{cardItem.back}}</view>  </view>  </repeat></view>在数据中生成模拟卡牌数据cardData: [    {      animationData: {},      front: '正面1',      back: '反面1'    },    ...    ...    {      animationData: {},      front: '正面9',      back: '反面9'    }  ],  showClass: false,在样式中把卡牌的基本样式渲染出来.card-module{  padding: 45rpx;  display: flex;  flex-direction: row;  flex-wrap: wrap;  transform:translate3d(0,0,0);  .card{    width: 200rpx;    height: 200rpx;    line-height: 200rpx;    text-align: center;    color: #fff;    margin: 10rpx;    position:relative;    overflow:hidden;    .card-item{      position:absolute;      left:0;      top:0;      width:100%;      height:100%;      transition:all .5s ease-in-out;      transform-style:preserve-3d;      backface-visibility:hidden;      box-sizing:border-box;    }    .front{      background-color: red;      transform: rotateY(0deg);      z-index:2;    }    .back{      background-color: #009fff;      transform: rotateY(180deg);      z-index:1;    }  }  .card.change{    .front{      z-index:1;      transform: rotateY(180deg);    }    .back{      z-index:2;        transform: rotateY(0deg);    }  }}效果如下这里有些css属性可能需要大部补充学习一下css3 backface-visibility 属性定义和用法 backface-visibility 属性定义当元素不面向屏幕时是否可见。 如果在旋转元素不希望看到其背面时，该属性很有用。CSS3 perspective 属性perspective 属性定义 3D 元素距视图的距离，以像素计。该属性允许您改变 3D 元素查看 3D 元素的视图。 当为元素定义 perspective 属性时，其子元素会获得透视效果，而不是元素本身。第二步：卡牌打乱由于业务上是抽奖使用的，所以选择的方案是：翻转后，卡牌收回到中间的卡牌中间，然后再让卡牌回到原来的位置。 关于小程序的原生框架有支持的动画接口，若不了解的请前往： developers.weixin.qq.com/miniprogram… 在对动画有基本了解之后，我们可以开始在翻转的基础上加上打乱的动画了 微信小程序的动画接口使用方式是在dom对象上面加上animation对象。 dom<view class=\"card-module\">  <view class=\"card {{showClass ? 'change' : ''}} animation=\"{{cardItem.animationData}}\" >    <view class=\"front card-item\">{{cardItem.front}}</view>    <view class=\"back card-item\">{{cardItem.back}}</view>  </view>  </repeat></view>scriptallMove () {    // 110 是卡牌宽度加边距    this.methods.shuffle.call(this, 110)    let timer = setTimeout(() => {      clearTimeout(timer)      this.methods.shuffle.call(this, 0)      this.$apply()    }, 1000)},// 洗牌shuffle (translateUnit) {    let curCardData = this.cardData    curCardData.map((item, index) => {      let animation = wepy.createAnimation({        duration: 500,        timingFunction: 'ease'      })      animation.export()      switch (index) {        case 0:          animation.translate(translateUnit, translateUnit).step()          break        case 1:          animation.translate(0, translateUnit).step()          break        case 2:          animation.translate(-translateUnit, translateUnit).step()          break        case 3:          animation.translate(translateUnit, 0).step()          break        case 4:          animation.translate(0, 0).step()          break        case 5:          animation.translate(-translateUnit, 0).step()          break        case 6:          animation.translate(translateUnit, -translateUnit).step()          break        case 7:          animation.translate(0, -translateUnit).step()          break        case 8:          animation.translate(-translateUnit, -translateUnit).step()          break      }      item.animationData = animation.export()    })    this.cardData = curCardData    this.$apply()},算法后面需要优化，我们先完成功能效果， 效果如下第三步：卡牌翻转dom代码<view class=\"card-module\">  <view class=\"card {{showClass ? 'change' : ''}}  {{curIndex === index ? 'getprize' : ''}}\" @tap=\"itemChage({{cardItem}}, {{index}})\" animation=\"{{cardItem.animationData}}\" >    <view class=\"front card-item\">{{cardItem.front}}</view>    <view class=\"back card-item\">{{cardItem.back}}</view>  </view>  </repeat></view>script代码data中定义一个curIndex = -1的对象data = {      curOpen: -1,      }methods = {    // 抽奖      itemChage (item, curIndex) {        this.cardData[curIndex].front = 'iphone x'        console.log(item, curIndex)        this.curOpen = curIndex      }}less.card.getprize{    .front{      z-index:2;      transform: rotateY(0deg);    }    .back{      z-index:1;        transform: rotateY(180deg);    }  }效果如下现在我们就已经完成了基本的需求；但是在位移动画时候代码写的太丑陋了。 我们来想想怎么优化算法； 我们现在就九宫格布局，我们可以看成是二维布局那我们是不是可以在卡牌中也使用二维数组布局属性resetData () {    const total = 9 // 总数    const lineTotal = 3 // 单行数    curCardData.map((item, index) => {      let curCardData = this.cardData      let x = index % lineTotal      let y = parseInt(index / lineTotal)      item.twoArry = {x, y}    })}在位移动画中使用二维布局的差值进行位移// 洗牌shuffle (translateUnit) {    let curCardData = this.cardData    curCardData.map((item, index) => {      let animation = wepy.createAnimation({        duration: 500,        timingFunction: 'ease'      })      animation.export()      const translateUnitX = translateUnit * (1 - item.twoArry.x)      const translateUnitY = translateUnit * (1 - item.twoArry.y)      animation.translate(translateUnitX, translateUnitY).step()      item.animationData = animation.export()    })    this.cardData = curCardData    this.$apply()},这样整个动画就算完成了，demo请前往githubgithub.com/fishmankkk/…作者：fishman 链接：https://juejin.im/post/5b867460f265da435743a8de 来源：掘金 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}
{"title": "小程序tab点击监听方法：onTabItemTap() ", "author": "Rolan", "pub_time": "2018-9-5 00:37", "content": "page()的详细生命周期，可以查看文档，今天主要说下其onTabItemTap()方法，很少用到，但我们在开发中为了解决一些问题（在此方法中触发登录界面），试用下此方法：方法说明Triggered when the user taps the tab if the current page is a tab page（当点击tab界面时触发）测试代码：  /** tab点击 */  onTabItemTap(item) {    console.log(item)    wx.showToast({      title: 'tab点击',    })  },  /**   * 生命周期函数--监听页面显示   */  onShow: function() {    self = this;    app.NetUtil.CheckLoginStatus(null, function(loginStatus) {});    ···分别在模拟器、iOS系统、Android系统分别测试，结果如下：效果图小程序模拟器：三个tab切换时，不会触发onTabItemTap()方法，如果已经在“个人中心”界面，再次点击tab，会触发该方法，而且点击几次，触发几次，没有APP的tab那么好使。iOS版微信的小程序：切换正常触发，多次点击可以根据自己的需要做相应处理。Android版微信（OPPO）的小程序：切换正常触发，多次点击可以根据自己的需要做相应处理。作者：恩来客 链接：https://www.jianshu.com/p/2e8370b7c760"}
{"title": "微信小程序数据过滤（filter）方法 ", "author": "Rolan", "pub_time": "2018-9-12 00:06", "content": "因为微信小程序的wxml和js的内部实现机制是分开编译的。所以在wxml是没办法调用js的函数的。这会导致WXML缺少一个我们常用的功能，那就是没有办法在视图层对数据进行格式化处理。比如我们从后端获取到一个包含了时间戳数据的数组，然后需要在界面上把这些日期都格式化显示为2017-01-01这种格式的日期形式，在Vue, Angular之类的前端Web框架中，一般在视图层都提供了如filter之类相应比较好用的方案。vue是没有这些方法的。但是小程序推出了wxs类型文件就是解决这类问题的。使用首先新建filter.wxs文件（也可以直接写在wxml文件中，但是这中公共方法还是应该单独建文件的）。var formatDate = function (timestamp,option) {\r\n  var date = getDate(parseInt(timestamp));\r\n  var year = date.getFullYear()\r\n  var month = date.getMonth() + 1\r\n  var day = date.getDate()\r\n  var hour = function(){\r\n    if (date.getHours()<10){  //补‘0’\r\n      return '0' + date.getHours()\r\n    }\r\n    return date.getHours();\r\n  }\r\n  var minute = function () {\r\n    if (date.getMinutes() < 10) {\r\n      return '0' + date.getMinutes()\r\n    }\r\n    return date.getMinutes();\r\n  }\r\n  var second = function () {\r\n    if (date.getSeconds() < 10) {\r\n      return '0' + date.getSeconds()\r\n    }\r\n    return date.getSeconds();\r\n  }\r\n\r\n  if (option=='notime'){  //不需要时间\r\n    return year + '-' + month + '-' + day;\r\n  }\r\n\r\n  return year + '-' + month + '-' + day + ' ' + hour() + ':' + minute() + \":\" + second();\r\n}\r\n\r\nmodule.exports = {\r\n  formatDate: formatDate,\r\n};在wxml文件中使用<wxs src='filter.wxs' module='filter' />\r\n  <view>日期：{{filter.formatDate(要过滤的时间戳)}}</view>注意事项wxs是不同于js文件的。所以很多js的api是不支持的。具体支持看官方文档。例如本来获取日期，我们原本是调用new Date()的。在wxs是不支持的，但是小程序提供了一个全局函数getDate(）代替。还有，wxs不支持任何ES6的语法。什么let，Map()都用不了（OS：真是low啊-_-!）。"}
{"title": "小程序导出朋友圈海报详细记录 ", "author": "Rolan", "pub_time": "2018-9-18 00:08", "content": "小程序提供了转发给好友的接口，但是没提供分享到朋友圈的接口。于是，只有引导用户保存图片分享到朋友圈。 两种方案：用微信 api 手动保存，用 painter 。微信 api使用原生接口的话，大致是使用 canvas 绘制出海报，然后下载。所以重点是绘制出海报，下载的流程都是一样的。当然在保存图片到相册前，还会需要获取保存图片到相册的权限。总结下来就是canvas绘制，获取保存权限，保存图片这三个步骤。 首先来看绘制海报，需要使用以下接口wx.createCanvasContext 创建 canvas contextctx.drawImage 绘制图片到 canvasctx.fillText 写文字wx.getImageInfo 获取网络图片的 tempFilePathctx.draw canvas 绘制最终保存下来的海报是这样的绘制的内容很简单，首先就是背景图；然后是分享者的头像；接下来是 @ xx 邀请你 这样一个文本描述；最后就是底部的小程序码。首先，创建 canvas 画布<canvas canvas-id='canvas' class='canvas' :style=\"{height: windowHeight + 'px'}\"/>\r\n复制代码使用小程序 createCanvasContext api ,需要传入 canvasidconst ctx = wx.createCanvasContext('canvas')\r\n复制代码然后将背景图片绘制出来，背景图片是放在本地的图片。ctx.drawImage('../../../static/assets/img/poster_background.png', 0, 0, this.windowWidth, this.windowHeight)\r\n复制代码然后写上文字ctx.setFontSize(12);\r\nctx.setFillStyle('#FFFFFF');\r\nctx.setTextAlign('center');\r\nctx.fillText(`${this.privateUserInfo.nickname} 邀您领取`, this.windowWidth / 2, this.transformScale(520))\r\n复制代码这里会将原始尺寸和绘制的尺寸等比例转换一下，就不赘述了。再接下来就是绘制小程序码了。由于小程序码是带了分享者的信息，所以必须是临时获取的网络图片资源，具体怎么获取带有分享者信息的小程序码，会专门写一篇文章介绍。绘制图片绘制头像与小程序码，这两张图片都是网络资源，所以都要使用 wx. getImageInfo 接口将其下载下来放到微信内存中，然后使用其response.path 绘制。小程序并不支持直接的绘制网络图片，而且也不支持 base64图片的绘制（虽然模拟器上会有效果）。头像的绘制还有有一个裁剪圆形头像的过程。wx.getImageInfo是异步的，所以在回调函数里绘制，当然这不是好的方式。可以使用 promise 来解决，由于现在已经不用这个代码了，就没有去改了。wx.getImageInfo({\r\n          src: miniProgramCodeSrc,\r\n          success: (response) => {\r\n            const miniProgramCodeSize = this.transformScale(160)\r\n            ctx.drawImage(response.path, this.transformScale(85), this.transformScale(710), miniProgramCodeSize, miniProgramCodeSize)\r\n\r\n            wx.getImageInfo({\r\n              src: this.privateUserInfo.avatar,\r\n              success: (response) => {\r\n                const avatarSize = this.transformScale(100)\r\n                //先绘制圆，裁剪成圆形图片\r\n                ctx.save();\r\n                ctx.beginPath();\r\n                //圆的原点x坐标，y坐标，半径，起始弧度，终止弧度\r\n                ctx.arc(this.transformScale(320), this.transformScale(425), avatarSize / 2, 0, 2 * Math.PI);\r\n                ctx.setStrokeStyle('#ffffff');\r\n                ctx.stroke();\r\n                ctx.clip();\r\n\r\n                ctx.drawImage(response.path, this.transformScale(270), this.transformScale(375), avatarSize, avatarSize)\r\n                ctx.restore();\r\n\r\n                ctx.draw(false, () => {\r\n                  this.saveToTempFilePath()\r\n                })\r\n              }\r\n            })\r\n          }\r\n        })\r\n复制代码到这一步，绘制基本就结束了。我们所要的海报内容已经可以在 canvas 上呈现了，接下来就是将 canvas 的内容保存为图片了。值得提醒的是，ctx.draw这个接口也是异步的，需要在其回调中执行下载的操作。获取 tempFilePathwx.canvasToTempFilePath 获取整个 canvas 的tempFilePath保存图片最重要的就是tempFilePath了，使用canvasToTempFilePath 获取 tempFilePath。需要注意的是canvasToTempFilePath接口二参需要传入 this。saveToTempFilePath() {\r\n        wx.canvasToTempFilePath({\r\n          canvasId: 'canvas',\r\n          success: (response) => {\r\n            //获取相册授权\r\n          }\r\n        }, this)\r\n      }\r\n复制代码获取 tempFilePath 成功后再获取保存权限，当然也可以先获取保存权限，再获取tempFilePath。获取保存权限首先查看是否有保存权限，有权限就可以直接保存了。没有权限就先获取权限，再保存。wx.getSetting 查看权限列表wx.authorize 若没有保存图片权限，进行授权wx.getSetting({\r\n  success: (res) => {\r\n    if (!res.authSetting['scope.writePhotosAlbum']) {\r\n      wx.authorize({\r\n        scope:'scope.writePhotosAlbum',\r\n        success: () => {\r\n          this.saveImageToPhotosAlbumByWX(response.tempFilePath)\r\n        }\r\n      })\r\n    } else {\r\n      this.saveImageToPhotosAlbumByWX(response.tempFilePath)\r\n    }\r\n  }\r\n})\r\n复制代码保存图片到相册wx.saveImageToPhotosAlbum 保存图片到相册这一步就很简单了，万事俱备，只差保存了。调用 wx.saveImageToPhotosAlbum 即可。saveImageToPhotosAlbumByWX(tempFilePath) {\r\n        wx.saveImageToPhotosAlbum({\r\n          filePath: tempFilePath,\r\n          complete: () => {\r\n            // 其他操作\r\n          }\r\n        })\r\n      }\r\n复制代码到这里，使用原生 api 保存一张分享朋友圈的海报就好了。painterpainter 是什么呢？小程序生成图片库，轻松通过 json 方式绘制一张可以发到朋友圈的图片painter 是酷家乐开源的小程序图片生成库，类似 echarts，使用配置对象渲染图片到 canvas。渲染完成后回调会返回 tempFilePath,然后调用 wx.saveImageToPhotosAlbum 即可保存。保存的步骤和第一种方案一致，关键是获取到 tempFilePath。按照其 readme 来操作就好了，由于项目是使用了 mpvue，所以使用了 mpvue接入方案 。使用 painter<painter v-if=\"showPainter\" class='canvas' @imgOK=\"onImgOk\" :palette=\"palette\"/>\r\n复制代码为什么要使用 v-if 呢，需要在所有数据都准备好了后再渲染 painter，否则会无限绘制。data() {\r\n  return {\r\n    //painter 配置数据\r\n    palette: {\r\n      width: '640rpx',\r\n      height: '1008rpx',\r\n      background: '/static/assets/img/poster_background.png',\r\n      views: [\r\n        {\r\n          type: 'image',\r\n          url: '',\r\n          css: {\r\n            top: '380rpx',\r\n            left: '320rpx',\r\n            align: 'center',\r\n            width: '100rpx',\r\n            height: '100rpx',\r\n            borderRadius: '50rpx'\r\n          }\r\n        }, {\r\n          type: 'text',\r\n          text: '',\r\n          css: {\r\n            top: '490rpx',\r\n            left: '320rpx',\r\n            align: 'center',\r\n            fontSize: '24rpx',\r\n            color: '#fff'\r\n          }\r\n        },\r\n        {\r\n          type: 'image',\r\n          url: '',\r\n          css: {\r\n            top: '690rpx',\r\n            left: '85rpx',\r\n            width: '180rpx',\r\n            height: '180rpx'\r\n          }\r\n        }\r\n      ]\r\n    }\r\n\r\n  }\r\n},\r\n\r\ncomputed: {\r\n  showPainter() {\r\n    const avatar = this.palette.views[0].url\r\n    const text = this.palette.views[1].text\r\n    const qrCodeUrl = this.palette.views[2].url\r\n    return avatar !== '' && text !== '' && qrCodeUrl!== ''\r\n  }\r\n}\r\n复制代码在 painter绘制成功的回调里，将 tempFilePath 保存起来。接下来的权限获取和保存图片到相册流程就和上一个方案一致了。但是，需要提醒的是，tempFilePath 需要放在全局变量中，不能放在data 中。总结总结一下，遇到的一些坑小程序canvas不能支持 base64drow 有回调drawImage 不能直接使用网络图片需要处理获取权限，用户拒绝后的场景最后海报就暴露了，是的，就是漫游鲸。欢迎扫个码体验漫游鲸小程序，欢迎了解下漫游鲸。如果还不了解漫游鲸， 那么点击就能了解漫游鲸啦"}
{"title": "微信小程序onLaunch异步，首页 onLoad 先执行 ? ", "author": "Rolan", "pub_time": "2018-9-26 00:18", "content": "本来按照事件顺序，小程序初始化时触发App里的onLaunch，后面再执行页面Page里的onLoad，但是在onLaunch里请求获取是否有权限，等待返回值的时候Page里的onLoad事件就已经执行了。//app.js\r\nApp({\r\n  onLaunch: function () {\r\n    console.log('onLaunch');\r\n    wx.request({\r\n      url: 'test.php', //仅为示例，并非真实的接口地址\r\n      data: {\r\n      },\r\n      success: function(res) {\r\n        console.log('onLaunch-request-success');\r\n        // 将employId赋值给全局变量，提供给页面做判断\r\n        this.globalData.employId = res.employId;   \r\n      }\r\n    })\r\n  },\r\n  globalData: {\r\n    employId: ''\r\n  }\r\n})\r\n//index.js\r\n//获取应用实例\r\nconst app = getApp()\r\n\r\nPage({\r\n  data: {\r\n    albumDisabled: true,\r\n    bindDisabled: false\r\n  },\r\n  onLoad: function () {\r\n    console.log('onLoad');\r\n    console.log('onLoad app.globalData.employId = ' + app.globalData.employId);\r\n    //判断是用户是否绑定了\r\n    if (app.globalData.employId && app.globalData.employId != '') {\r\n      this.setData({\r\n        albumDisabled: false,\r\n        bindDisabled: true\r\n      });\r\n  }\r\n})\r\n控制台打印的结果是onLaunch\r\nonLoad\r\nonLoad app.globalData.employId = \r\nonLaunch-request-success\r\n要是能等完onLaunch请求完再执行Page的onLoad方法那该多好。这里采用的方法是定义一个回调函数。Page页面判断一下当前app.globalData.employId是否有值，如果没有（第一次）则定义定义一个app方法（回调函数）app.employIdCallback = employId => {...}。App页面在请求success后判断时候有Page页面定义的回调方法，如果有就执行该方法。因为回调函数是在Page里面定义的所以方法作用域this是指向Page页面。//app.js\r\nApp({\r\n  onLaunch: function () {\r\n    wx.request({\r\n      url: 'test.php', //仅为示例，并非真实的接口地址\r\n      data: {\r\n      },\r\n      success: function(res) {\r\n        this.globalData.employId = res.employId;\r\n        //由于这里是网络请求，可能会在 Page.onLoad 之后才返回\r\n        // 所以此处加入 callback 以防止这种情况\r\n        if (this.employIdCallback){\r\n           this.employIdCallback(res.employId);\r\n        }\r\n      }\r\n    })\r\n  },\r\n  globalData: {\r\n    employId: ''\r\n  }\r\n})\r\n//index.js\r\n//获取应用实例\r\nconst app = getApp()\r\n\r\nPage({\r\n  data: {\r\n    albumDisabled: true,\r\n    bindDisabled: false\r\n  },\r\n  onLoad: function () {\r\n    //判断是用户是否绑定了\r\n    if (app.globalData.employId && app.globalData.employId != '') {\r\n      this.setData({\r\n        albumDisabled: false,\r\n        bindDisabled: true\r\n      });\r\n    } else {\r\n      // 由于 getUserInfo 是网络请求，可能会在 Page.onLoad 之后才返回\r\n      // 所以此处加入 callback 以防止这种情况\r\n      app.employIdCallback = employId => {\r\n        if (employId != '') {\r\n          this.setData({\r\n            albumDisabled: false,\r\n            bindDisabled: true\r\n          });\r\n        }\r\n      }\r\n    }\r\n  }\r\n})\r\n这样的话，就能实现想要的结果。执行顺序就是：[App] onLaunch -> [Page] onLoad -> [App] onLaunch sucess callback"}
{"title": "小程序源码反编译实战笔记 ", "author": "Rolan", "pub_time": "2018-10-12 00:21", "content": "分分钟上手小程序源码反编译最近在做微信小程序开发，看到一些做的比较有意思的小程序，想看一看他们的源码，于是研究了一下小程序源码反编译相关的技术。结合本次经历，总结如下。手机root要拿到小程序在手机上的源码包，需要有一台越狱的iphone或者一台拥有root权限的android机，正好我手里有一台闲置的小米4，就拿来用了，试过很多种方式给小米4root，差点搞成板砖机，一直在recorvy模式启动不了，最后尝试了小米官网的刷机方法，把系统刷成了开发版，完美root。小米4刷机教程： https://www.miui.com/shuaji-305.html手机刷机成功后，开启root权限，并打开USB调试模式小米4开发版开启root权限： http://www.miui.com/thread-9625466-1-1.htmlMIUI9开启USB调试： https://jingyan.baidu.com/article/49711c6196e728fa441b7c37.html电脑操作以 MacOS 操作系统为例，通过USB连接操作Android手机安装 adb 工具在 MacOS 系统上可以通过 brew 安装 adb 工具brew cask install android-platform-tools\r\n手机连电脑通过USB数据线将手机连接到电脑，并在手机端开启USB调试，通过下面的命令测试是否连接成功adb devices\r\n连接成功的情况下查看小程序源码进入 adb shell 模式adb shell\r\n切换到root权限su\r\n进入小程序源码目录先进入 MicroMsg 文件夹，通过 ls 命令查看文件夹，找到 63c92a20722afef36b525ecb04706c15 这样的文件夹（不同的微信登录用户，这个文件夹的名称不同），然后再进入 appbrand/pkg目录cd /data/data/com.tencent.mm/MicroMsg\r\nls\r\ncd 63c92a20722afef36b525ecb04706c15/appbrand/pkg\r\n查看小程序源码可以先执行 rm -rf ./* 删除掉当前目录下所有缓存的小程序源码包，然后通过手机端点击进入需要获取源码的小程序，再执行 ls -l 即可看到最新操作的小程序源码包rm -rf ./*\r\nls -l\r\n将小程序源码拷贝到手机SD卡cp _1038319936_4.wxapkg /sdcard\r\n新开一个终端窗口，将源码拷贝到电脑adb pull sdcard/_1038319936_4.wxapkg /data/weapp/a.wxapkg\r\n操作过程截图反编译源码下载 nodejs 版本的反编译工具并安装相关 npm 包git clone https://github.com/qwerty472123/wxappUnpacker.git\r\n\r\ncd wxappUnpacker\r\n\r\nnpm install esprima -g\r\nnpm install css-tree -g\r\nnpm install cssbeautify -g\r\nnpm install vm2 -g\r\nnpm install uglify-es -g\r\n反编译小程序源码node wuWxapkg.js /data/weapp/a.wxapkg\r\n最后进入反编译成功的文件，即可看到需要的小程序文件"}
{"title": "小程序版结合promise的axios风格ajax请求函数 ", "author": "Rolan", "pub_time": "2018-10-18 00:42", "content": "建议的小程序版本的axios函数，之所以说简易，因为只是用了常用的请求方法外，然后添加了拦截器而已。具体如下：wxhttp命名为wxhttp具体的请求用法如axioswxhttp#request(config)wxhttp#get(url[,config])wxhttp#delete(url[,config])wxhttp#head(url[,config])wxhttp#options(url[,config])wxhttp#post(url[,data[,config]])wxhttp#put(url[,data[,config]])wxhttp#patch(url[,data[,config]])拦截方法：请求拦截wxhttp.interceptors.request.use(handleRequest(config),handleError(err))注意：handleRequest需要返回处理后的config返回拦截wxhttp.interceptors.response.use(handresponse(res))注意：handleResponse需要返回处理后的res例子：import $http from \"../../utils/http\"\r\nexport default {\r\n  name: 'seckillHome',\r\n  data() {\r\n    return {\r\n\r\n    }\r\n  },\r\n  onShow() {\r\n    // 请求拦截\r\n    $http.interceptors.request.use(function (config) {\r\n      console.log(`请求拦截`, config)\r\n      // 此处设置的数据将与请求的数据进行合并，如果自动同名则以拦截的为准。\r\n      config.data = {\r\n        address: \"北京市东城区\"\r\n      }\r\n      return config\r\n    })\r\n\r\n    $http.post('https://www.baidu.com', {\r\n      name: 'cdd',\r\n      age: 23\r\n    }).then(res => {\r\n      console.log(`结果是`, res)\r\n    })\r\n  }\r\n}因为使用了promise风格，所以可以使用Promise.all方法来进行并发请求。查看源码"}
{"title": "微信小程序营销组件wxapp-market ", "author": "Rolan", "pub_time": "2018-10-19 00:08", "content": "wxapp-market 是基于微信小程序的营销组件，用于快速开发营销玩法类小程序项目页面，包含大转盘、刮刮乐、老虎机、水果机、九宫格翻纸牌、摇一摇、手势解锁等多种营销组件。使用1.拉取仓库git clone git@github.com:o2team/wxapp-market.git\r\n\r\n2.组件文件大转盘 (Big wheel) : /components/wheel/刮刮乐 (Scratch tickets) : /components/scratch/老虎机 (Slot machine) : /components/slotMachine/水果机 (Fruit machine) : /components/fruitMachine/九宫格翻纸牌 (Grid card) : /components/card/摇一摇 (Shake) : /components/shake/手势解锁 (Gesture lock) : /components/lock/3.调用以大转盘组件为例WXSS中引用样式：@import \"../../components/wheel/wheel.wxss\"\r\nWXML中引用结构：<import src=\"../../components/wheel/wheel.wxml\"/>\r\nJS中引用：import Wheel from \"../../components/wheel/wheel.js\"\r\nJS中实例调用：  new Wheel(this,{\r\n    areaNumber: 8,   //抽奖间隔\r\n    speed: 16,       //转动速度\r\n    awardNumer: 2,   //中奖区域从1开始\r\n    mode: 1,         //1是指针旋转，2为转盘旋转\r\n    callback: (idx, award) => {      //结束回调， 参数对应宫格索引，对应奖项    \r\n    }\r\n  })\r\n运行效果：大转盘其他wxapp-market项目地址：https://github.com/o2team/wxa..."}
{"title": "小程序第三方框架对比 ( wepy / mpvue / taro ) ", "author": "Rolan", "pub_time": "2018-10-19 00:21", "content": "众所周知如今市面上端的形态多种多样，手机Web、ReactNative、微信小程序, 支付宝小程序, 快应用等,每一端都是巨大的流量入口，当业务要求同时在不同的端都要求有所表现的时候，针对不同的端去编写多套代码的成本显然非常高，这时候只编写一套代码就能够适配到多端的能力就显得极为需要。但面对目前市面上成熟的小程序第三方框架如何针对自己的需求进行选择也是一个麻烦事,本文针对当前市面上的三大转译框架进行一个综合对比,希望能对大家的技术选择有所帮助,如有哪里不妥的地方希望指正;　小程序开发有哪些痛点?频繁调用 setData及 setData过程中页面跳闪组件化支持能力太弱(几乎没有)不能使用 less、scss 等预编译器request 并发次数限制　为什么使用第三方框架? 只要熟悉vue或react即可快速上手,学习成本低 一套代码可在多端编译运行(微信,支付宝,h5,RN)  支付宝小程序暂不完善组件化开发，完美解决组件隔离，组件嵌套，组件通信等问题 支持使用第三方 npm 资源使小程序可支持 Promise，解决回调烦恼可使用 Generator Fu-nction / Class / Async Function 等特性，提升开发效率 对小程序本身的优化，如生命周期的补充，性能的优化等等支持样式编译器: Scss/Less，模板编译器，代码编译器：Babel/Typescript。    第三方框架对比 wepy mpvue taro　　在这里我通过对目前已开源的三种常用小程序框架做一个综合对比, 还有一个叫nanchi的基于react的小程序转译框架,由于没来的及研究暂不做比较;WEPY https://tencent.github.io/wepy/document.html　　腾讯团队开源的一款类vue语法规范的小程序框架,借鉴了Vue的语法风格和功能特性,支持了Vue的诸多特征，比如父子组件、组件之间的通信、computed属性计算、wathcer监听器、props传值、slot槽分发，还有很多高级的特征支持：Mixin混合、拦截器等;WePY发布的第一个版本是2016年12月份，也就是小程序刚刚推出的时候，到目前为止，WePY已经发布了52个版本, 最新版本为1.7.2; MpVue http://mpvue.com/mpvue/#-html　　美团团队开源的一款使用 Vue.js 开发微信小程序的前端框架。使用此框架，开发者将得到完整的 Vue.js 开发体验，同时为 H5 和小程序提供了代码复用的能力。mpvue在发布后的几天间获得2.7k的star,上升速度飞起,截至目前为止已经有13.7k的star;Taro https://taro.aotu.io/ 　　京东凹凸实验室开源的一款使用 React.js 开发微信小程序的前端框架。它采用与 React 一致的组件化思想，组件生命周期与 React 保持一致，同时支持使用 JSX 语法，让代码具有更丰富的表现力，使用 Taro 进行开发可以获得和 React 一致的开发体验。,同时因为使用了react的原因所以除了能编译h5, 小程序外还可以编译为ReactNative;Star  　           生命周期　　同为vue规范的mpvue和wepy的生命周期和各种方法不尽相同　　wepy　　wepy生命周期基本与原生小程序相同,再此基础上糅合了一些vue的特性; 对于WePY中的methods属性，因为与Vue中的使用习惯不一致，非常容易造成误解，这里需要特别强调一下：WePY中的methods属性只能声明页面wxml标签的bind、catch事件，不能声明自定义方法，这与Vue中的用法是不一致的。　　import wepy from 'wepy';\r\n\r\nexport default class MyPage extends wepy.page {\r\n// export default class MyComponent extends wepy.component {\r\n    customData = {}  // 自定义数据\r\n\r\n    customFunction ()　{}  //自定义方法\r\n\r\n    onLoad () {}  // 在Page和Component共用的生命周期函数\r\n\r\n    onShow () {}  // 只在Page中存在的页面生命周期函数\r\n\r\n    config = {};  // 只在Page实例中存在的配置数据，对应于原生的page.json文件\r\n\r\n    data = {};  // 页面所需数据均需在这里声明，可用于模板数据绑定\r\n\r\n    components = {};  // 声明页面中所引用的组件，或声明组件中所引用的子组件\r\n\r\n    mixins = [];  // 声明页面所引用的Mixin实例\r\n\r\n    computed = {};  // 声明计算属性（详见后文介绍）\r\n\r\n    watch = {};  // 声明数据watcher（详见后文介绍）\r\n\r\n    methods = {};  // 声明页面wxml中标签的事件处理函数。注意，此处只用于声明页面wxml中标签的bind、catch事件，自定义方法需以自定义方法的方式声明\r\n\r\n    events = {};  // 声明组件之间的事件处理函数\r\n}　　mpvue　　mpvue 除了 Vue 本身的生命周期外，还兼容了小程序生命周期，这部分生命周期钩子的来源于微信小程序的 Page， 除特殊情况外，不建议使用小程序的生命周期 钩子。 1Vue\r\n 3 beforeCreate\r\n 4 created\r\n 5 beforeMount\r\n 6 mounted\r\n 7 beforeUpdate\r\n 8 updated\r\n 9 activated\r\n10 deactivated\r\n11 beforeDestroy\r\n12 destroyed\r\n13 app 部分\r\n15 onLaunch，初始化\r\n16 onShow，当小程序启动，或从后台进入前台显示\r\n17 onHide，当小程序从前台进入后台\r\n18 page 部分\r\n20 onLoad，监听页面加载\r\n21 onShow，监听页面显示\r\n22 onReady，监听页面初次渲染完成\r\n23 onHide，监听页面隐藏\r\n24 onUnload，监听页面卸载\r\n25 onPullDownRefresh，监听用户下拉动作\r\n26 onReachBottom，页面上拉触底事件的处理函数\r\n27 onShareAppMessage，用户点击右上角分享\r\n28 onPageScroll，页面滚动\r\n29 onTabItemTap, 当前是 tab 页时，点击 tab 时触发 （mpvue 0.0.16 支持）简单示例new Vue({\r\n  data: {\r\n    a: 1\r\n  },\r\n  created () {\r\n    // `this` 指向 vm 实例\r\n    console.log('a is: ' + this.a)\r\n  },\r\n  onShow () {\r\n    // `this` 指向 vm 实例\r\n    console.log('a is: ' + this.a, '小程序触发的 onshow')\r\n  }\r\n})\r\n// => \"a is: 1\" taro与react生命周期完全相同class Clock extends Component {\r\n  constructor (props) {\r\n    super(props)\r\n    this.state = { date: new Date() }\r\n  }\r\n\r\n  componentDidMount() {\r\n\r\n  }\r\n\r\n  componentWillUnmount() {\r\n\r\n  }\r\n\r\n  render () {\r\n    return (\r\n      <View>\r\n        <Text>Hello, world!</Text>\r\n        <Text>现在的时间是 {this.state.date.toLocaleTimeString()}.</Text>\r\n      </View>\r\n    )\r\n  }\r\n}列表渲染在列表渲染上三者也分别有不同的应用方法wepy当需要循环渲染WePY组件时(类似于通过wx:for循环渲染原生的wxml标签)，必须使用WePY定义的辅助标签<repeat><template>\r\n    <!-- 注意，使用for属性，而不是使用wx:for属性 -->\r\n    <repeat for=\"{{list}}\" key=\"index\" index=\"index\" item=\"item\">\r\n        <!-- 插入<script>脚本部分所声明的child组件，同时传入item -->\r\n        <child :item=\"item\"></child>\r\n    </repeat>\r\n</template>\r\n\r\n<script>\r\n    import wepy from 'wepy';\r\n    // 引入child组件文件\r\n    import Child from '../components/child';\r\n\r\n    export default class Index extends wepy.component {\r\n        components = {\r\n            // 声明页面中要使用到的Child组件的ID为child\r\n            child: Child\r\n        }\r\n\r\n        data = {\r\n            list: [{id: 1, title: 'title1'}, {id: 2, title: 'title2'}]\r\n        }\r\n    }\r\n</script>mpvue使用v-for与vue一致,只是需要注意一点，嵌套列表渲染，必须指定不同的索引！<!-- 在这种嵌套循环的时候， index 和 itemIndex 这种索引是必须指定，且别名不能相同，正确的写法如下 -->\r\n<template>\r\n    <ul v-for=\"(card, index) in list\">\r\n        <li v-for=\"(item, itemIndex) in card\">\r\n            {{item.value}}\r\n        </li>\r\n    </ul>\r\n</template>taro的列表循环用法基本与react相同,有一点需要注意,在 React 中，JSX 是会编译成普通的 JS 的执行，每一个 JSX 元素，其实会通过 createElement 函数创建成一个 JavaScript 对象（React Element），因此实际上你可以这样写代码 React 也是完全能渲染的：const list = this.state.list.map(l => {\r\n  if (l.selected) {\r\n    return <li>{l.text}</li>\r\n  }\r\n}).filter(React.isValidElement)但是 Taro 中，JSX 会编译成微信小程序模板字符串，因此你不能把 map 函数生成的模板当做一个数组来处理。当你需要这么做时，应该先处理需要循环的数组，再用处理好的数组来调用 map 函数。例如上例应该写成：const list = this.state.list\r\n  .filter(l => l.selected)\r\n  .map(l => {\r\n    return <li>{l.text}</li>\r\n  })事件处理mpvue目前全支持小程序的事件处理器,引入了 Vue.js 的虚拟 DOM ，在前文模版中绑定的事件会被挂在到 vnode 上，同时 compiler 在 wxml 上绑定了小程序的事件，并做了相应的映射，所以你在真实点击的时候通过 runtime 中 handleProxy 通过事件类型分发到 vnode 的事件上，同 Vue 在 WEB 的机制一样，所以可以做到无损支持。同时还顺便支持了自定义事件和 $emit 机制// 事件映射表，左侧为 WEB 事件，右侧为 小程序 对应事件\r\n{\r\n    click: 'tap',\r\n    touchstart: 'touchstart',\r\n    touchmove: 'touchmove',\r\n    touchcancel: 'touchcancel',\r\n    touchend: 'touchend',\r\n    tap: 'tap',\r\n    longtap: 'longtap',\r\n    input: 'input',\r\n    change: 'change',\r\n    submit: 'submit',\r\n    blur: 'blur',\r\n    focus: 'focus',\r\n    reset: 'reset',\r\n    confirm: 'confirm',\r\n    columnchange: 'columnchange',\r\n    linechange: 'linechange',\r\n    error: 'error',\r\n    scrolltoupper: 'scrolltoupper',\r\n    scrolltolower: 'scrolltolower',\r\n    scroll: 'scroll'\r\n}踩坑注意(官方文档)：列表中没有的原生事件也可以使用例如 bindregionchange 事件直接在 dom 上将bind改为@ @regionchange,同时这个事件也非常特殊，它的 event type 有 begin 和 end 两个，导致我们无法在handleProxy 中区分到底是什么事件，所以你在监听此类事件的时候同时监听事件名和事件类型既 <map @regionchange=\"functionName\" @end=\"functionName\" @begin=\"functionName\"><map>小程序能力所致，bind 和 catch 事件同时绑定时候，只会触发 bind ,catch 不会被触发，要避免踩坑。事件修饰符.stop 的使用会阻止冒泡，但是同时绑定了一个非冒泡事件，会导致该元素上的 catchEventName 失效！.prevent 可以直接干掉，因为小程序里没有什么默认事件，比如submit并不会跳转页面.capture 支持 1.0.9.self 没有可以判断的标识.once 也不能做，因为小程序没有 removeEventListener, 虽然可以直接在 handleProxy 中处理，但非常的不优雅，违背了原意，暂不考虑其他 键值修饰符 等在小程序中压根没键盘，所以。。。wepy事件绑定区别于vue,根据原生小程序事件提供了语法优化绑定事件 bindtap=\"click\" 替换为 @tap=\"click\"，取消冒泡原catchtap=\"click\"替换为@tap.stop=\"click\"。捕获监听事件 capture-bind:tap=\"click\" 替换为 @tap.capture=\"click\"，中断捕获监听capture-catch:tap=“click\"替换为 @tap.capture.stop=\"click\"。Taro 元素的事件处理和 DOM 元素的很相似。但是有一点语法上的不同:Taro 事件绑定属性的命名采用驼峰式写法，而不是小写。 如果采用 JSX 的语法你需要传入一个函数作为事件处理函数，而不是一个字符串 (DOM 元素的写法)。 例如，传统的微信小程序模板：<button onclick=\"activateLasers\">\r\n  Activate Lasers\r\n</button>Taro 中稍稍有点不同：<button onClick={this.activateLasers}>\r\n  Activate Lasers\r\n</button>在 Taro 中另一个不同是你不能使用 catchEvent 的方式阻止事件冒泡。你必须明确的使用 stopPropagation。例如，阻止事件冒泡你可以这样写：class Toggle extends React.Component {\r\n  constructor (props) {\r\n    super(props)\r\n    this.state = {isToggleOn: true}\r\n  }\r\n\r\n  onClick = (e) => {\r\n    e.stopPropagation()\r\n    this.setState(prevState => ({\r\n      isToggleOn: !prevState.isToggleOn\r\n    }))\r\n  }\r\n\r\n  render () {\r\n    return (\r\n      <button onClick={this.onClick}>\r\n        {this.state.isToggleOn ? 'ON' : 'OFF'}\r\n      </button>\r\n    )\r\n  }\r\n} request请求wepy对wx.request做了接受参数的修改,值得一提的是它提供了针对全局的intercapter拦截器// 原生代码:\r\n\r\nwx.request({\r\n    url: 'xxx',\r\n    success: function (data) {\r\n        console.log(data);\r\n    }\r\n});\r\n\r\n// WePY 使用方式, 需要开启 Promise 支持，参考开发规范章节\r\nwepy.request('xxxx').then((d) => console.log(d));\r\n\r\n// async/await 的使用方式, 需要开启 Promise 和 async/await 支持，参考 WIKI\r\nasync function request () {\r\n   let d = await wepy.request('xxxxx');\r\n   console.log(d);\r\n}拦截器import wepy from 'wepy';\r\n\r\nexport default class extends wepy.app {\r\n    constructor () {\r\n        // this is not allowed before super()\r\n        super();\r\n        // 拦截request请求\r\n        this.intercept('request', {\r\n            // 发出请求时的回调函数\r\n            config (p) {\r\n                // 对所有request请求中的OBJECT参数对象统一附加时间戳属性\r\n                p.timestamp = +new Date();\r\n                console.log('config request: ', p);\r\n                // 必须返回OBJECT参数对象，否则无法发送请求到服务端\r\n                return p;\r\n            },\r\n\r\n            // 请求成功后的回调函数\r\n            success (p) {\r\n                // 可以在这里对收到的响应数据对象进行加工处理\r\n                console.log('request success: ', p);\r\n                // 必须返回响应数据对象，否则后续无法对响应数据进行处理\r\n                return p;\r\n            },\r\n\r\n            //请求失败后的回调函数\r\n            fail (p) {\r\n                console.log('request fail: ', p);\r\n                // 必须返回响应数据对象，否则后续无法对响应数据进行处理\r\n                return p;\r\n            },\r\n\r\n            // 请求完成时的回调函数(请求成功或失败都会被执行)\r\n            complete (p) {\r\n                console.log('request complete: ', p);\r\n            }\r\n        });\r\n    }\r\n}taro对request进行了二次封装,可以使用Taro.request(OBJECT)发起网络请求，支持 Promise 化使用。 import Taro from '@tarojs/taro'\r\n\r\nTaro.request({\r\n  url: 'http://localhost:8080/test',\r\n  data: {\r\n    foo: 'foo',\r\n    bar: 10\r\n  },\r\n  header: {\r\n    'content-type': 'application/json'\r\n  }\r\n})\r\n  .then(res => console.log(res.data))mpvue没有对request做特殊优化,与原生相同,可以自己根据需要进行封装状态管理wepy 可引用Redux和Mbox,目前wepy的脚手架内已经集成了redux,选择需要即可;mpVue使用vuextaro使用Redux如何选择适合自己的项目如果只需要做一个微信小程序则根据自己的擅长框架选择mpvue或taro如果是当前老项目想像向程序迁移同时老项目又是使用vue开发,建议使用mpvue或wepy如果是老项目使用react开发且需要部分迁移小程序,建议使用taro如果是新项目且新项目需要同时支持微信小程序和支付宝小程序, 建议使用原生开发,因为目前框架的转译支付宝小程序支持并不是很好,且出了问题不好定位修改, 但如果是小demo不涉及太多逻辑的项目都可以使用框架作为尝鲜; 但如果是涉及太多交互逻辑的则不建议使用框架转译,由于支付宝小程序在视图层基本与小程序一致所以建议手动更改替换部分方法和全局替换一些属性或文件名,如wxml替换为axml这种, 手动转换时间比大概是四比一; 当然如果人手足够一端开发一个是最好的..."}
{"title": "微信小程序之：云开发初体验--致我的第一个小程序 ", "author": "Rolan", "pub_time": "2018-10-19 00:36", "content": "背景：一直关注微信小程序的发展，看着小程序一步步完善，一步步壮大，心里痒痒，也想做一个自己的微信小程序，但是苦于只会前端，不会服务端，所以想法一直被卡着。现在小程序有了云开发，很轻松实现后端功能，写后端跟写前端没啥区别，真的是前端小伙伴们的福音啊。经过几个晚上的熬夜奋战，我的第一个微信小程序正式上线啦。小程序名字： 杭州地铁通二维码：欢迎小伙伴们体验，欢迎吐槽。现在还只是初版，功能还不完善，后面会继续更新的。 闲话少说，进入正题。小程序云开发是什么？开发者可以使用云开发开发微信小程序、小游戏，无需搭建服务器，即可使用云端能力。(云端说白了也就是服务端啦，说的那么高大上，对新手朋友可不太友好。)小程序·云开发提供了三个基础能力： 数据库 、 存储 和 云函数 。数据库 ：json数据库，就理解为往里面存的是json，取出来的也是json。存储 ：就是把你的图片、音频和视频之类的资源文件，存储到里面，帮你生成链接，直接拿链接就可以用，就好像一个网盘一样。云函数 ：这个云函数，就是服务端的接口，你调用这个函数，也就是调用接口。云函数可以在客户端写，也可以在云开发控制台写，写完之后同步一下，两端就都有了。在云函数里，你可以进行计算，也可以操作数据库，把想要的结果以同步或者异步的方式返回给客户端。每个用户最多可拥有两套开发环境，两套环境是互相独立的，一般是创建一个test环境用于开发，一个release环境用于发布。这里有小坑，后面说。云开发怎么用？在创建工程时，选择快速创建云开发模板，直接就拥有了云开发能力， 模板里已经配置好了云服务对接模块的路径，如下图：￼在app.js里配置当前的环境ID，配置完毕，就可以进行开发了。1.创建并编写云函数：右键云函数模块文件夹->新建Node.js云函数： ￼比如，我创建了一个获取用户收藏列表的云函数，函数功能就是从数据库从读取用户收藏列表，并把结果返回给小程序。注意：app.js里虽然指定了当前环境，但这里的代码是在云端运行的，还是要重新指定读的是哪个环境的数据库。￼上面是异步查询，并返回，所以用的是 await。用await的好处是，可以把异步代码像同步一样去写，这在阮一峰的ES6入门里有讲。2.云函数上传并部署创建完云函数后，还需要右键点击云函数，进行上传并部署，注意：微信开发工具不支持批量上传，每个云函数都要单独点击上传，这里有点坑。上传部署完后，就可以直接调用了，云函数调用和接口返回处理，其中，参数是放在data对象里的。3.获取用户唯一身份标识：openId以前没有云服务时，开发者用自己的服务器对接小程序，使用微信用户id时，需要自己调用接口进行鉴权，来判断用户身份。而现在这些都已经被云服务给做了，每次调用接口，微信会自动鉴权，而且每个接口都会自带openId，使用起来非常方便。云函数里的微信openId的获取，和参数的获取： ￼到此，这些就是云函数的使用过程，是不是很简单，又很方便。最后：上面说过，云服务有两个环境，两个环境互相独立，目前微信不支持环境间数据同步，那在test里的一些数据，就要手动去同步到release环境，这个有点烦。还有一点是：如果开发完要上线了，那要把环境从test切到release环境。切换环境时，需要把app.js里云服务初始化环境切换到release，云函数里如果有数据库调用，也要指定数据环境。而且切换时，用的是环境ID，不是环境的名字，文档里写的是用名字，坑了我20分钟。"}
{"title": "微信小程序跳H5页面 ", "author": "Rolan", "pub_time": "2018-10-19 00:42", "content": "主页面：index.wxml主页面：index.js↑跳转到另一个wxml页面→recharge.wxmlrecharge.wxmlweb-view中设置跳转h5的链接，可以加上需要的参数：tips：1.首先，web-view组件的属性src，正如你说看到的，这个就是设置网页链接的，但是需要特别注意的是web-view的src必须配置https协议的链接；2.其次，就是web-view组件只要配置了链接，它是铺满全屏且自动跳转的，所以这也就是为什么我这边需要先写一个navigator按钮，点击操作之后再让它跳转的原因；3.最后，web-view跳转的接口域名，需要配置在小程序开发设置的业务域名列表中。"}
{"title": "万字解析小程序（2）：如何保证大海上可以看到“小船”？ ", "author": "Rolan", "pub_time": "2018-10-22 00:01", "content": "每一个小程序，都需要回答一个问题——你的用户是谁？换句新潮的说法就是：“你是在玩儿微信里的公域流量还是私域流量？”如何判断公域还是私域？根据用户的使用场景。如果用户的使用场景是“吃喝玩乐上班上课”，那就是在玩儿公域流量。如果户的使用场景是“公众号 朋友圈 聊天”，那就是玩儿私域流量。姜太公公观点：本文将讨论小程序下的公域流量和私域流量的核心差别。并且在明天文章中探讨小程序中公域流量和私域流量的玩儿法。大海上看小船淘宝店主想多卖货，过去怎么办？需要买直通车，需要冲击金钻，需要提高淘宝搜索排名。这面向的是“公域流量”。现在怎么办？搞粉丝群，搞社群，把“公域流量”拉出一部分到自己的“私域流量”。为什么要搞私域流量？在选择爆炸的情况下，用户的每次选择都是站在一个茫茫的大海上。海上满满的都是船。用户会看到离他近的船，或者体量大的船。小船的被看到的机会，很少。私域流量的存在带来了什么？天崩地裂，大海被拆分成很多“浅水湖”。我是一艘小小船，用户在“大海”上看不到我，我就开进他身边的“浅水湖”。每日优鲜，玩儿的是公域流量。干死了无数生鲜电商，成为了用户在海上可以看的到的大船。而社区团购生鲜，玩儿的是私域流量，通过一个个宝妈建立的微信群，拼团买生鲜。公域流量是中心化的，这种模式下火的是“规模经济”。赢家因为规模增大带来了经济效益的提高。规模增大后，成本分摊得更低，获客成本更低。所谓赢家通吃。私域流量去中心化的，这一次，“规模效应”失效了。正所谓 场下格斗没套路，乱拳打死老师傅。微信中的“关系”形成了天然的壁垒。导致了去中心化。大海，因为这些关系的存在，变成了“浅水湖”。如何建立私域，需要和用户建立关系。比如建立公众号，成立社群，或者直接和用户的朋友建立关系。建立关系的目的是为了掌握住“私域的入口”。越强的关系，越强的互动，私域流量的质量越好截然不同的玩儿法微信中的公域流量和私域流量，玩儿法完全不同。因为两种流量模式下，用户 形成一个“行为”的方式完全不同。Fogg模型阐述了如何让行为发生。Fogg模型认为一次行为的发生需要具备三个要素，缺一不可。这三个要素是： 动机，成本，触发点。举一个例子，一家饭馆想吸引用户走进来吃饭。这个行为的发生需要如下条件：动机：顾客想吃饭成本：顾客兜里有50块钱，这家饭馆人均消费30元。顾客有“支付的能力”触发点：顾客走到饭馆旁边，看到饭馆“吸引人的招牌”要完成这次行为，三个要素缺一不可。公域流量 和 私域流量的区别在于，这三个要素出现的顺序不同。公域流量是“动机”驱动行为，私域流量是“触发点”驱动行为。公域流量下，用户首先有了一个“动机”，然后打开了一个软件。用户想听歌，于是打开某易云音乐APP。用户记得它的位置在手机第2屏的第3排，然后轻松的找到，然后点开。私域流量下，用户通过“群”“聊天”“公众号”的触发点，获得了一个动机。好友发给我一个“毛衣”拼团链接，看着还挺实惠的。天气真的变冷了，我也需要一件。两者行为的驱动点完全不同。所以，给小程序开发者的建议是：如果你是玩公域流量，你需要降低“主动触发”下的用户摩擦。在用户有一个动机的时候，帮助她迅速完成行为。做到用户所想即所得，让用户快速找到你的软件。用户心理想要的是，don’t make think，don’t make wait。用户找到你的小程序很便捷，就搞好小程序；如果小程序做不到，就将小程序作为引流工具，把用户像APP沉淀，通过APP形成肌肉记忆。如果你是玩私域流量，你需要降低“被动触发”下对用户的打扰。Emmm，这，真的有点复杂哦！具体如何做，看万字解析（3）。总结一下啦微信开放了自己的社交关系，将流量划分为公域流量和私域流量。私域流量是去中心化的，导致“规模效应”失效。私域流量更多是被动触发，公域流量是主动触发。如果你是玩公域流量，你需要降低“主动触发”下的用户摩擦。如果你是玩私域流量，你需要降低“被动触发”下对用户的打扰。相关阅读万字解析小程序（1）：小程序 PK APP = 无解 ？#专栏作家#姜太公公，微信号公众号：grandpa_jiang，人人都是产品经理专栏作家。产品老流氓，终身学习者。致力于研究产品方法论，解决小白PM的疑难杂症。本文原创发布于人人都是产品经理。未经许可，禁止转载题图来自 Pexels，基于 CC0 协议"}
{"title": "node.js 抓取网页内容（针对微信小程序云开发） ", "author": "Rolan", "pub_time": "2018-10-22 00:48", "content": "最近在研究微信小程序的云开发功能。云开发最大的好处就是不需要前端搭建服务器，可以使用云端能力，从零开始写出来一个能上线的微信小程序，避免了买服务器的开销，对于个人来尝试练手微信小程序从前端到后台的开发，还是一个不错的选择。可以做到一天就能上线一个微信小程序。云开发的优点云开发为开发者提供完整的云端支持，弱化后端和运维概念，无需搭建服务器，使用平台提供的 API 进行核心业务开发，即可实现快速上线和迭代，同时这一能力，同开发者已经使用的云服务相互兼容，并不互斥。云开发目前提供三大基础能力支持：云函数：在云端运行的代码，微信私有协议天然鉴权，开发者只需编写自身业务逻辑代码数据库：一个既可在小程序前端操作，也能在云函数中读写的 JSON 数据库存储：在小程序前端直接上传/下载云端文件，在云开发控制台可视化管理好了，介绍了这么多关于云开发的知识，感性的同学可以去研究研究。官方文档地址：https://developers.weixin.qq....网页内容抓取小程序是关于答题的，所以题目的来源是一个问题。上网搜，一个题目一个题目粘贴是一种方法，但是这样的重复工作，估计粘个10左右就想放弃了。所以想到了网页抓取。正好把之前学的node捡起来。必备工具：Cheerio。一个类似于服务器端JQuery的包。主要用它来分析和过滤抓取来的内容。node的fs模块。这个是node自带的模块，用来读写文件的。此处用来将解析好的数据写入json文件。Axios（非必须）。用来抓取网站的HTML网页。因为我要的数据是从网页上点击一个button后获取渲染的，所以直接访问这个网址是抓取不到的。无奈只能将想要的内容复制出来，存成字符串，去解析这个字符串。接下来就可以用npm init来初始化一个node项目，一路回车后，即可生成一个package.json文件。然后npm install --save axios cheerio安装cheerio和axios包。关键的是用cheerio来实现一个类似jquery的功能。只需将抓取到的内容cheerio.load(quesitons)一下即可，之后就可以按照jquery的操作取dom，组装你想要的数据了。最后用fs.writeFile将数据保存到json文件中，大功告成。具体代码如下：let axios = require(\"axios\");\r\n\r\nlet cheerio = require(\"cheerio\");\r\n\r\nlet fs = require(\"fs\");\r\n\r\n// 我的html结构大致如下，有很多条数据\r\nconst questions = `<li id=\"q1\" style=\"display: list-item;\">\r\n      <div class=\"questionWrapper\">\r\n        <div class=\"question\">举头望明月，__________。</div>\r\n        <div class=\"answer\" value=\"0\">\r\n          回首白云低\r\n        </div>\r\n        <div class=\"answer\" value=\"1\">\r\n          低头思故乡\r\n        </div>\r\n        <div class=\"answer\" value=\"0\">\r\n          当春乃发生\r\n        </div>\r\n        <div class=\"answer\" value=\"0\">\r\n          红掌拨清波\r\n        </div>\r\n      </div>\r\n    </li>\r\n    <li id=\"q2\">\r\n      <div class=\"questionWrapper\">\r\n        <div class=\"question\">__________，却话巴山夜雨时。</div>\r\n        <div class=\"answer\" value=\"1\">\r\n          何当共剪西窗烛\r\n        </div>\r\n        <div class=\"answer\" value=\"0\">\r\n          在天愿做比翼鸟\r\n        </div>\r\n        <div class=\"answer\" value=\"0\">\r\n          世味年来薄似纱\r\n        </div>\r\n        <div class=\"answer\" value=\"0\">\r\n          两岸青山相对出\r\n        </div>\r\n      </div>\r\n    </li>\r\n    ..........\r\n    `;\r\n    \r\nconst $ = cheerio.load(quesitons);\r\n\r\nvar arr = [];\r\n\r\nfor (var i = 0; i < 300; i++) {\r\n   var obj = {};\r\n   obj.quesitons = $(\"#q\" + i).find(\".question\").text();\r\n   obj.A = $($(\"#q\" + i).find(\".answer\")[0]).text();\r\n   obj.B = $($(\"#q\" + i).find(\".answer\")[1]).text();\r\n   obj.C = $($(\"#q\" + i).find(\".answer\")[2]).text();\r\n   obj.D = $($(\"#q\" + i).find(\".answer\")[3]).text();\r\n   obj.index = i + 1;\r\n   obj.answer =\r\n     $($(\"#q\" + i).find(\".answer\")[0]).attr(\"value\") == 1\r\n       ? \"A\"\r\n       : $($(\"#q\" + i).find(\".answer\")[1]).attr(\"value\") == 1\r\n         ? \"B\"\r\n         : $($(\"#q\" + i).find(\".answer\")[2]).attr(\"value\") == 1\r\n           ? \"C\"\r\n           : \"D\";\r\n   arr.push(obj);\r\n}\r\n\r\nfs.writeFile(\"poem.json\", JSON.stringify(arr), err => {\r\n   if (err) throw err;\r\n   console.log(\"json文件已成功保存！\");\r\n});保存到json后的文件格式如下，这样就可以通过json文件上传到云端服务器了。注意事项微信小程序云开发的数据库，上传json文件的数据格式需要注意一下，之前一直提示格式错误，后来才发现，JSON 数据不是数组，而是类似 JSON Lines，即各个记录对象之间使用 n 分隔，而非逗号。所以还需要对node写出来的json文件做一个小处理之后才能上传成功。"}
{"title": "万字解析小程序（3）：流量升级触发的“礼物经济” ", "author": "Rolan", "pub_time": "2018-10-29 00:06", "content": "本文观点：流量升级的原因：微信社交能力的开放，将渠道集中式的“公域流量”转化成用户为中心的“私域流量”。流量升级的结果：私域流量去中心化，导致了“赢家通吃”模式的失效。礼物经济的启示：礼物具有极强的“外部性”。互惠是一种方式，而不是目的。流量升级的原因2017年6月13日，我写了一篇“唱衰小程序”的文章。在小程序初期，有很多人的看法，是和我相同的。认为“小程序 PK APP”，胜算并不大。1年的时间，我明白了1件事情，擂台搭错了，你在旁边磕一吨焦糖瓜子儿，也等不出输赢。看小程序这个赛道，不该看 “小程序 PK APP”，也不该看“微信 PK Android”，而是看“微信 PK 智能手机”。为什么？移动浪潮的兴起，是因为“智能手机”的发展，带来了流量红利。小程序浪潮的兴起，是因为“微信”社交能力的开放，带来的流量升级。1. 追忆移动浪潮智能手机的出现，大大的提高了用户的终端保有量。它太简单便携，人手一部。可是换一个角度想，如果智能手机没有出现，世界会怎样？2018年，可能会有“9毽键盘”、“大屏”电脑，专供于三四线城市，老年人，小镇青年。没有智能手机，可能人手一部电脑。智能手机最性感的点，不在于让一些不触网的人触网，而在于流量的重新洗牌。这一点，只有它可以做到。流量迁移：流量从一个地方转移到另一个地方；流量洗牌：流量池结构打散，重排。人生海海，我们大部分时间在拼“定位”。一亩三分地，种了玉米就不能种高粱。你需要找到你的差异化优势，才能赢得竞争。可是某些浪潮下，这一亩三分地迅速洗牌，种了的玉米被全部拔了下来。要知道，乱世出英雄，混乱是阶梯。——姜太公公智能手机的洗牌，在于“使用场景”的洗牌，因为LBS，移动性等带来的随时随地的场景。这大大拓宽了整体的使用频次和使用时间。在这波使用场景的浪潮下，产生了各种场景解决方案的公司，比如：吃饭、出行、打发时间……微信的洗牌，在于“用户”结构的洗牌。这导致了用户接触信息、使用信息的方式的完全颠覆。微信社交能力的开放，带来了“用户”结构从渠道集中式的公域流量转化成用户为中心的私域流量。所以小程序的价值不在于小程序是什么？而在于微信开放了自己的终端价值，这个开放带来了什么？2. 为什么当初会错判？我们当初为啥会比较“小程序 PK APP”？为了形成“短平快”的判断，我们经常会贴标签。比如：实习生小姑娘一脸花痴的说“我的idol太帅了，简直是行走的荷尔蒙，我要给idol生孩子”  你说：“小鲜肉就是长得好看，实力都不行”。拜托，人家idol都特么42岁了好么，见了面，你都得叫人家一声大哥。（这个case并不是发生在我身上的哦，不要瞎想）“标签”，帮助我们迅速定义未知事物，却模糊了事物的全貌。如果牛在你心中的标签只有“黑白色”，那我问你是否见过牛尾巴是“666”的？你就不会知道，站在你眼前的这一只就是。标签化思考导致我们无法看到事物的全貌。在看小程序赛道时，很多人同样用了标签化思考，导致使用了错误的擂台。为了快速定义“小程序”，我们给它贴了一个“类似app”的标签。原来安卓、苹果手机上使用“微博APP”，现在微信中使用“微博小程序”。这样的“标签”，遮盖了什么全貌呢？为了更好的说明，我先来拆解下移动浪潮的全貌：应用层：用户使用的东西属于应用层。“APP”属于应用层。系统层：指操作系统。“android系统”，“iOS系统”属于系统层。应用的实现依赖于系统层。同一个应用，可能有“android版本”、“iOS版本”终端：“智能手机”是终端。终端带来了流量，流量和价值直接相关。对应到小程序赛道，这个全貌是什么呢？小程序浪潮下的终端是“微信”，开发者原来抢的是“移动手机”里的用户，现在抢的是“微信”里的用户。终端带来了流量，流量和价值直接相关。小程序能力开放前，“微信”里的用户你是很难碰到的。“微信”和“移动手机”在终端价值上，是一个级别的。万物皆有裂痕，那是风吹过来的地方。不要找风口上的猪，而是要看风里有什么能力。——姜太公公小结移动浪潮的兴起，是因为“智能手机”的发展，带来了流量红利。小程序浪潮的兴起，是因为“微信”社交能力的开放，带来的流量升级。流量升级的结果每一个小程序，都需要回答一个问题：“你是在玩儿微信里的公域流量还是私域流量？”如何判断公域还是私域？这里提供一个判断标准——根据用户的使用场景。如果用户的使用场景是“吃喝玩乐上班上课”，那就是在玩儿公域流量。如果用户的使用场景是“公众号 朋友圈 聊天”，那就是玩儿私域流量。小程序的流量升级，是因为出现了私域流量。私域流量的作用是什么呢？引起的后果是什么呢？NO.1 “赢家通吃”模式失效淘宝店主想多卖货，过去怎么办？需要买直通车，需要冲击金钻，需要提高淘宝搜索排名。这面向的是“公域流量”。现在怎么办？搞粉丝群，搞社群，把“公域流量”拉出一部分到自己的“私域流量”。为什么要搞私域流量？在选择爆炸的情况下，用户的每次选择都是站在一个茫茫的大海上。海上满满的都是船，用户会看到离他近的船，或者体量大的船。小船的被看到的机会，很少。私域流量的存在带来了什么？天崩地裂，大海被拆分成很多“浅水湖”。我是一艘小小船，用户在“大海”上看不到我，我就开进他身边的“浅水湖”。每日优鲜，玩儿的是公域流量。干死了无数生鲜电商，成为了用户在海上可以看的到的大船。而社区团购生鲜，玩儿的是私域流量，通过一个个宝妈建立的微信群，拼团买生鲜。公域流量是中心化的，这种模式下火的是“规模经济”。赢家因为规模增大带来了经济效益的提高，规模增大后，成本分摊得更低，获客成本更低。所谓赢家通吃。私域流量去中心化的，这一次，“规模效应”失效了。正所谓 场下格斗没套路，乱拳打死老师傅。微信中的“关系”形成了天然的壁垒，导致了去中心化。大海，因为这些关系的存在，变成了“浅水湖”。NO.2 用户行为的“驱动力”不再是“需求”Fogg模型阐述了如何让行为发生。Fogg模型认为一次行为的发生需要具备三个要素，缺一不可，这三个要素是： 动机、成本、触发点。举一个例子，一家饭馆想吸引用户走进来吃饭，这个行为的发生需要如下条件：动机：顾客想吃饭成本：顾客兜里有50块钱，这家饭馆人均消费30元。顾客有“支付的能力”触发点：顾客走到饭馆旁边，看到饭馆“吸引人的招牌”要完成这次行为，三个要素缺一不可。公域流量和私域流量的区别在于，这三个要素出现的顺序不同。公域流量是“动机”驱动行为，私域流量是“触发点”驱动行为。公域流量下，用户首先有了一个“动机”，然后打开了一个软件。用户想听歌，于是打开某易云音乐APP。用户记得它的位置在手机第2屏的第3排，然后轻松的找到，然后点开。私域流量下，用户通过“群”“聊天”“公众号”的触发点，获得了一个动机。好友发给我一个“毛衣”拼团链接，看着还挺实惠的。天气真的变冷了，我也需要一件。两者行为的驱动点完全不同。如果你是玩公域流量，你需要降低“主动触发”下的用户摩擦。在用户有一个动机的时候，帮助她迅速完成行为。做到用户所想即所得，让用户快速找到你的软件。用户心理想要的是，don’t make think，don’t make wait。如果你是玩私域流量，你需要降低“被动触发”下对用户的打扰。Emmm，这，真的有点复杂哦！会在第3节中重点讲哦！NO.3 流量池结构变为“沙漏”提到“流量池”，最容易想到什么？没错，用户分层。公域流量，流量池的结构是上图这种“鸡尾酒”型。用户是分层的，稳定的，忠实用户 、老用户、新用户各占有稳定的比例。做好这杯鸡尾酒，需要调好用户分配比例，讲的是“精细化运营”。 私域流量，流量池的结构是“沙漏”型。用户是动态的，流动的。小程序中，留存率20%是一个坎儿，而一个普通app，留存率动辄40%，50%，可见微信中的私域流量留存之低。私域流量做不了鸡尾酒，因为“底是漏的”。APP，强调的是转化率，强调的是一节节，分子小于分母的比例。转化率永远是小于1的，如果做到0.9，已经可以封神了。小程序中，强调的是分享，强调的是一层层，分子大于分母的裂变K值。K值大于1才算及格，1.1的100次方=13780 ，但是0.9的100次方=0.000027。分享带来了流量的复利，解决了留存的问题。分享，是整个私域流量池模型成立的根基。小结私域流量的作用是什么呢？引起的后果是什么呢？NO.1 “赢家通吃”模式失效NO.2 用户行为的“驱动力”不再是“需求”NO.3 公域流量池的结构是“鸡尾酒”型，私域流量池的结构是“沙漏”型。“礼物经济”给小程序的启示上文提到了私欲流量池结构变为“沙漏”。这里就不得不重点讲一下分享，你以为我要讲用户分享的18大驱动力？你以为我要讲裂变的起点是“人民币”和“社交币”？不，我们站的高一点，玩儿的大一点的。私域流量的分享其实在做的是“礼物经济”。礼物经济指的是提供商品或服务者并没有明确的预期回馈对象，也没有预期回馈的内容，有许多分享行为出自于非制式的习惯。同时，礼物的施与受之间已转换成一种未明确规定的义务，形成送礼者与收礼者之间的隐晦关系。礼物经济也被认为是一种债务经济，在这种经济中，交易者的目标是尽可能获得最多的礼物债务人，而不像在商品经济中以获取最大利润为目的。——百度百科从礼物经济的3大特点中，我们可以获得针对于小程序流量的玩法儿启示。1. 礼物经济中“互惠”是媒介，但不是目的互惠是一种语言。小明分享了一个“原价999，团购价9块9”的拼团链接给姜太公公。拼团成功后，小明和公公各自省了900元。请问，小明潜意识里，是希望不久的将来，姜太公公也帮助他省900元钱么？不会，小明对于姜太公公给他的回报没有预期。互惠，是一种媒介，是礼物经济中语言。就好像，见面问一句“你吃了没”。实际上，对方吃了啥，根本不care。对小程序开发者的启示：要让“互惠”成为一种沟通的方式，不要把互惠看的太重，否则会本末倒置。小程序的各种玩儿法“拼 抢 坎 送 比”，都是一种沟通的媒介。2. 交换礼物目的是——增加礼物的往来“礼物和商品交易的一个重要不同之处是，礼物在双方之间形成了情感纽带，商品交易却并不会带来任何必要的联系。我进入一家五金店，付钱给店员购买一根锯条然后离开，我可能再也不会和这名店员见面。疏离感是商品交易模式的基本原则，我们不想被打扰，所以如果这个店员一直不想我谈家里的事儿，我会换一家店，因为我只想买一个金条”—— 摘取自《分享经济的爆发》和商品销售不同，礼物赠予是要在双方建立亲密关系。当礼物在群体里流通，形成了一系列相互交织的关系网络，出现了一种去中心化的内聚力。礼物经济在于关系的维护，通过赠送礼物，强化了双方的关系。如果破坏了双方的关系，就不能称为礼物，比如：什么样的礼物会破坏朋友圈的关系？打卡、广告、利己分享。比如：什么样的礼物会破坏朋友的关系？没完没了集call。对小程序开发者的启示：当小程序的某种裂变玩儿法，用户已经麻木甚至厌恶时，这种玩儿法就已经跳出了礼物经济，它不能对用户的关系起到正向的作用。3. 礼物具有“外部性”礼物的商品价值和消费价值在很大程度上是无关紧要的。礼物的价值，通过“送”而达成。礼物的价值不在于礼物本身。一个没有送出去的礼物，没有价值。礼物这种东西，具有很强的外部性。回到互联网。小程序需要具有“外部性”，用户通过分享，感知到价值。用户没有分享，感知不到价值。只有这样，分享才能成为必备操作。拼多多：用户分享前，感受到这是一个卖低价商品的卖场。用户分享后，哇塞好便宜，感觉自己赚到了人民币。黑咔：用户分享前，感受到这是一个图片处理工具。用户分享后，哇塞好有趣大家一起玩，感觉自己赚到了社交币。对小程序开发者的启示：用户通过分享，“才能”感知到小程序的核心价值。“才能”这两个字儿很重要。小结私域流量的分享其实在做的是“礼物经济”，从礼物经济的特点中，我们可以获得针对于小程序的3大启示。总结这篇文章写的有点难哦，感谢你能看完，本文观点回顾：流量升级的原因：微信社交能力的开放，将渠道集中式的“公域流量”转化成用户为中心的“私域流量”。流量升级的结果：私域流量去中心化，导致了“赢家通吃”模式的失效。礼物经济的启示：礼物具有极强的“外部性”。互惠是一种方式，而不是目的。相关阅读万字解析小程序（1）：小程序 PK APP = 无解 ？万字解析小程序（2）：如何保证大海上可以看到“小船”？#专栏作家#姜太公公，微信号公众号：grandpa_jiang，人人都是产品经理专栏作家。产品老流氓，终身学习者。致力于研究产品方法论，解决小白PM的疑难杂症。本文原创发布于人人都是产品经理。未经许可，禁止转载题图来自 Pexels，基于 CC0 协议"}
{"title": "微信小程序：动画（Animation） ", "author": "Rolan", "pub_time": "2018-10-29 00:30", "content": "简单总结一下微信动画的实现及执行步骤。一、实现方式官方文档是这样说的：①创建一个动画实例 animation。②调用实例的方法来描述动画。③最后通过动画实例的 export 方法导出动画数据传递给组件的 animation 属性。因为小程序是数据驱动的，给这句话加上数字标注分为三步：前两步是定义一个动画并设置都要干什么，然后把这个设置好的“规则”扔给界面上的某个元素，让它按照这个规则执行。当然如果有多个元素的animation=\"{{ani}}\"，也都会执行这个动画规则。二、用例子说话新建一个小程序，把没用的删掉修改一下，做个简单例子，上图代码如下：index.wxml，一个helloworld，一个按钮<view class=\"container\">\r\n  <view class=\"usermotto\" animation=\"{{ani}}\">\r\n    <text class=\"user-motto\">{{motto}}</text>\r\n  </view>\r\n  <button bindtap='start'>动画</button>\r\n</view>index.wxss， 为了看着方便加了个边框.usermotto {\r\n  margin-top: 100px;\r\n  border: solid;\r\n}index.jsPage({\r\n  data: {\r\n    motto: 'Hello World',\r\n  },\r\n  start:function(){\r\n    var animation = wx.createAnimation({\r\n      duration: 4000,\r\n      timingFunction: 'ease',\r\n      delay: 1000\r\n    });\r\n    animation.opacity(0.2).translate(100, -100).step()\r\n    this.setData({\r\n      ani:  animation.export()\r\n    })\r\n  }\r\n}) 三、相关参数及方法简单介绍一下例子中的几个参数和方法（其他的详见官方文档）：      duration: 动画持续多少毫秒      timingFunction: “运动”的方式，例子中的 'ease'代表动画以低速开始，然后加快，在结束前变慢        delay: 多久后动画开始运行      opacity(0.2) 慢慢变透明      translate(100, -100) 向X轴移动100的同时向Y轴移动-100      step(): 一组动画完成，例如想让上例中的HelloWorld向右上方移动并变透明后，再次向左移动50可以继续写 animation.translateX( -50).step() , 作用就是向右上方移动和变透明是同时进行， 这两种变化完成之后才会进行向左运行的一步。"}
{"title": "megalo -- 网易考拉小程序解决方案 ", "author": "Rolan", "pub_time": "2018-10-29 00:33", "content": "megalo 是基于 Vue 的小程序框架（没错，又是基于 Vue 的小程序框架），但是它不仅仅支持微信小程序，还支持支付宝小程序，同时还支持在开发时使用更多 Vue 的特性。背景对于用户而言，小程序能提供更好的体验，但对于开发者而言，要让一个应用跑在多个平台上，则需要写多套代码。如何提高小程序开发效率让很多开发者都感到头疼。业界也有相关的解决方案，如 taro 和 mpvue，二者都是基于 react 和 vue 的开发模式实现，让开发者能够以他们熟知的 react 或 vue 模式来开发小程序，提高开发效率。mpvue 的发布给了我们很多启发，更早的时候，我们基于 RegularJS（网易自研的前端框架）开发了一个名为 mpregular 的小程序框架。在 mpregular 的开发和实际使用过程中，我们发现如果小程序框架所支持的特性只是原框架的子集（例如不支持 filter、模版复杂表达式等），开发效率会大打折扣。所以，我们在方案上做了很多尝试，目的是支持更多的特性，减少小程序与 H5 开发之前的差异。目前 mpregular 已经在考拉的小程序业务中大量应用，相关业务的开发同学纷纷表示，学习成本变低，跨端业务（H5 和小程序）的开发效率提升近一倍。方案经过一段时间验证后，我们决定把这套方案用 vue 再实现一次，一是为了适应技术栈的变更升级，二是为社区做一点微小的工作，于是就便有了 megalo。特性支持更多模版语法特性相比于其他小程序开发模式，由于支持更多特性，megalo 更贴近 Vue 原生的开发模式。从表格可以看到，megalo 最大的特点之一是，支持更多的 Vue 语法特性。这意味着，如果你有一个需求是要把现有的 Vue 代码迁移到小程序上，不需要太多改动。因为你的代码中可能大量使用 filter、scoped-slot、复杂表达式插值。基本语法支持 vue 的基本模版语法，包括 v-for 、 v-if 。class 和 style 的绑定方式没有限制，官方的用法都支持。<!-- v-if & v-for -->\r\n<div v-for=\"(item, i) in list\">\r\n  <div v-if=\"isEven(i)\">{{ i }} - {{ item }}</div>\r\n</div>\r\n\r\n<!-- style & class -->\r\n<div :class=\"classObject\"></div>\r\n<div :class=\"{ active: true }\"></div>\r\n<div :class=\"[activeClass, errorClass]\"></div>\r\n<div :style=\"{ color: activeColor, fontSize: fontSize + 'px' }\"></div>\r\n<div :style=\"styleObject\"></div>\r\n<div :style=\"[baseStyles, overridingStyles]\"></div>\r\n复制代码slot & scoped-slot支持 slot 和 scoped-slot。<div>\r\n  <Container>\r\n    <Card>\r\n      <div slot=\"head\"> {{ title }} </div>\r\n      <div> I'm body </div>\r\n      <div slot=\"foot\"> I'm footer </div>\r\n    </Card>\r\n  </Container>\r\n  <List :list=\"list\">\r\n    <span slot-scope=\"scopeProps\">{{ scopeProps.item.label }}</span>\r\n  </List>\r\n<div>\r\n复制代码复杂表达式 & filter可以在模版里面写复杂表达式、调用实例上的方法，当然也可以用更简洁的 filter 语法，跟平时用 Vue 开发一样。<div>\r\n  <div>{{ message.toUpperCase() }}</div>\r\n  <div>{{ toUpperCase( message ) }</div>\r\n  <div>{{ message | toUpperCase }}</div>\r\n</div>\r\n复制代码v-html要使用 v-html 需要添加插件 @megalo/vhtml-plugin ，并引入模版解析库 octoparse ，在页面入口安装一下插件：import Vue from 'vue'\r\nimport VHtmlPlugin from '@megalo/vhtml-plugin'\r\n\r\nVue.use(VHtmlPlugin)\r\n复制代码利用 v-html 指令然后就可以在小程序中渲染 html 了。<div v-html=\"'<h1>megalo</h1>'\"></div>\r\n复制代码更好的数据更新性能小程序的官方明确说明，在调用 setData 更新数据时如果数据量过大或频率更高，会引发性能问题。megalo 在框架底层已经帮开发者对此进行优化，每次数据发生变化时，megalo 只会将视图中要展示的、且发生变化的数据进行更新，将 setData 的数据更新量最小化，同时对更新数据频率进行了限制。像下面这段代码，如果视图只需要展示 user.name 这个字段的话，在进行数据同步时只会将 user.name 这个字符串更新到视图层，其余字段是不会同步到小程序的对象上的。<div>{{ user.name }}</div>\r\n<script>\r\nexport default {\r\n  data() {\r\n    return {\r\n      user: {\r\n        name: 'kaola',\r\n        age: 3,\r\n        favorite: [\r\n          'encalyptus',\r\n          'sleeping'\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}\r\n</script>\r\n复制代码支持更多平台今年以来，各大流量平台都在小程序领域有所动作，蚂蚁金服成立小程序事业部，百度、今日头条也纷纷推出自己的小程序。megalo 目前已经支持微信和支付宝小程序，百度小程序等平台的支持也在计划当中。微信和支付宝小程序使用使用 megalo 开发非常简单，只需在常见的 Vue 项目 webpack 构建配置上配置 @megalo/target 并引入 @magalo/template-compiler 即可。如果需要编译成支付宝小程序，只需要设置 platform: 'alipay' 。const { createMegaloTarget } = require('@megalo/target');\r\nmodule.exports = {\r\n  target: createMegaloTarget( {\r\n    compiler: require('@megalo/template-compiler'),\r\n    platform: 'wechat'\r\n  } )\r\n  // 其他 webpack 配置，如 vue-loader 等\r\n};\r\n复制代码接着，就可以像开发 Vue 应用一样去开发小程序。示例可以参考 megalo-demo 。如果想用 typescript 进行开发，可以参考 megalo-ts-simple 。实现小程序在结构上主要有 Service(JavascriptCore) 和 View(WebView) 两部分组成（微信和支付宝小程序有着类似的结构，下文均以微信小程序为例，并简称为小程序），分别运行在独立的环境上，之间不具备共享数据通道，二者的通信方式是将数据封装在 js 脚本后传递。Page 实例就在 Service 中，通过 setData 方法将数据传递到 View。View 则通过事件绑定将视图层触发的事件传递给 Service。Service 层中无法操作视图层的 DOM 节点。实际开发中，小程序的逻辑和模版需要写在 .js 和 .wxml 两个文件中，分别在 Service 和 View 中执行。如果要将在浏览器端的 Vue 放到小程序中跑，需要将 .vue 文件中的 template 片段转换成 .wxml 文件，并对 Vue 的 runtime 部分改造，将其中的 DOM 操作移除，通过小程序的 Service 中的页面实例上的 API 与 View 进行通信。最终的运行效果是，当 Vue 的 vm 上数据发生更新时，会重新渲染出 vdom，在的 patch 阶段，框架不在去操作 DOM，而是通过 Page 上的 setData 方法将变化的数据更新到视图层，完成 Vue 和 小程序的视图更新，这就是 megalo 底层所做的工作。megalo 的实现，主要分成以下四个部分，下面本文将对每个部分进行介绍。生命周期小程序中，每一个页面（Page）是一个实例，页面的生命周期钩子有很多，但和实例创建的两个关键生命周期分别是 onLoad 和 onReady ，它们分别在「 页面加载，实例初始化后 」和「 初次页面渲染完成 」时触发。Vue 的实例要和小程序实例建立起联系，则需要在小程序 Page 实例创建好以后，即在 onLoad 的钩子函数里，去初始化对应的 Vue 根实例，将页面实例 page 挂载到 Vue 实例的 $mp 上，此时也会触发 Vue 的生命周期钩子 created 。在页面初次渲染完成后，则会调用 $mount 方法，与在浏览器中挂载 DOM 节点不同，这里会将 Vue 实例上的数据初始化到视图层中。由此，Vue 实例就与小程序的 Page 实建立起了联系。除了这两个生命周期钩子以外，像小程序的 onShow 、 onHide 等生命周期钩子在触发时，也会尝试触发 Vue 实例上的同名钩子函数，实现两种实例间生命周期的绑定。在小程序页面退出销毁时，会触发 onUnload 钩子，此时 Vue 的实例也会跟着销毁。模版转换小程序有它特有的模版语法和文件名后缀，所以在构建阶段，我们会将 .vue 文件中的 template 部分提取出来并转换成对应的 .wxml 文件。标签名、语法都会进行相应的转换，如图所示。这一部分是在构建阶段完成的，这意味着，megalo 不支持 render 函数的写法。在构建阶段除了将模版转换成 .wxml 以外，还需要对模版中的每个节点进行转换，并在生产的 render 函数中加入相关的节点标记信息，数据映射和事件代理需要这些信息。数据映射由于无法直接操作视图层的 DOM，所以我们只能利用 page.setData 这个方法完成数据到视图层的映射。最简单暴力的方法，是将 Vue 实例上的所有数据统统收集起来，通过调用 page.setData 方法更新 Page 实例的数据，这个方法会将数据挂载到 Page 实例上，同时也会把数据传递给视图层。但是，这种粗暴的更新方式有两个弊端：i. 全量更新 vm 上的数据是无法区分哪些数据是视图层需要的，冗余无用的数据会被更新到 page 实例上。像下图这个例子，视图层只需要展现两个字符串，如果 vm 上还存在两个大数组，它们也会被无脑同步到 page 上。ii. 同步到 page 实例上的数据其实就是原始数据，并不是视图层实际要展示的数据，所以展示数据的格式化与转换需要依赖小程序模版的解析能力，导致一些 Vue 支持的模版语法无法支持，例如 filter、复杂表达式、传递 class 对象等。当然以上两个弊端不会对功能开发造成影响，但在实际的业务开发中，会让开发体验不一致，尤其是 h5 代码迁移到小程序时，对效率影响颇大。为了解决这个问题，megalo 采用另一种方式，即将 render 时生成的 vnode 上的数据更新到视图，vnode 的数据就是已经处理好的展示数据，根据 vnode 构造每个节点的数据结构，再同步到视图层。例如以下这段代码，在构建阶段 megalo 会对每个节点进行标记，使 render 时生成的 vnode 和模版中每个插值能够对应上。<!-- 编译前的 Vue 模版 .vue -->\r\n<div :class=“classObj”>\r\n  {{ date | format( 'YYYY' ) }}\r\n</div>\r\n\r\n<!-- 编译后的小程序模版 .wxml -->\r\n<view class=\"{{ node_1.class }}\">\r\n  {{ node_1.text }}\r\n</view>\r\n复制代码以这种方式实现的数据映射，只有视图层需要的两个字符串数据会被同步到小程序的 Page 实例上，其余数据则被认为与视图无关则不会进行同步。export default {\r\n  data() {\r\n    return {\r\n      classObj: {\r\n        'kaola': true\r\n      },\r\n      date: new Date(),\r\n      users: {\r\n        // big object\r\n      }\r\n    }\r\n  }\r\n}\r\n复制代码如下图所示，Vue 渲染出来的 vnode 会被以特定的数据结构映射到 page 上，再同步到小程序视图层。以这种方式实现的数据映射，可以更好地支持 Vue 的模版语法，且更大限度地减少更新视图时传输的数据量，从框架层面规避 setData 的性能问题。事件代理小程序视图触发事件后，会将 event 对象通知到 Page 实例，那么我们只需要将视图层中所有的事件都代理到 page.proxy 这个方法中，然后再靠这个方法从 Vue 的实例树上找到对应的 vm和 handler 做事件处理。为了实现这一目的，在构建阶段对模版进行编译时，除了要将事件监听方法转换为 proxy 以外，还需要通过 data- 在元素上标记对应的组件 compid 和节点 nodeid。<!-- 编译前的 Vue 模版 .vue -->\r\n<div @click=\"onClick\"></div>\r\n\r\n<!-- 编译后的小程序模版 .wxml -->\r\n<view bindtap=\"proxy\" data-compid=\"0\" data-nodeid=\"0\"></view>\r\n复制代码事件触发时，proxy 方法会从 event 对象上获取对应的 id 信息和事件类型，进而从 Vue 的根 vm 开始查找，最终在 vnode 上找到对应的 handler 并执行事件处理，完成小程序事件到 Vue 实例的事件代理。现在与未来目前，megalo 已经逐步在考拉的小程序应用开发中投入使用，但 megalo 的数据映射方案早已通过 mpregular 在考拉的大量小程序应用中得到了验证。现在，megalo 支持 typescript 开发，支持支付宝小程序。百度智能小程序的支持也在计划之内，同时，我们还计划开发一个兼容个平台的 UI 组件库、API 库，尝试将跨 H5 和各小程序平台的应用开发之间的差异最小化，提升开发效率。"}
{"title": "微信小程序国密算法实现库sm-crypto ", "author": "Rolan", "pub_time": "2018-10-29 00:43", "content": "国密算法是国家密码局制定标准的一系列算法，主要有SM1，SM2，SM3，SM4，密钥长度和分组长度均为128位。其中：SM1 为对称加密。其加密强度与AES相当。该算法不公开，调用该算法时，需要通过加密芯片的接口进行调用。SM2为非对称加密，基于ECC。该算法已公开。由于该算法基于ECC，故其签名速度与秘钥生成速度都快于RSA。ECC 256位（SM2采用的就是ECC 256位的一种）安全强度比RSA 2048位高，但运算速度快于RSA。SM3 消息摘要。可以用MD5作为对比理解。该算法已公开。校验结果为256位。SM4 无线局域网标准的分组数据算法。对称加密，密钥长度和分组长度均为128位。sm-crypto可以在微信小程序中实现SM2、SM3、SM4国密算法。使用安装 sm-crypto从小程序基础库版本 2.2.1 或以上、及开发者工具 1.02.1808300 或以上开始，小程序支持使用 npm 安装第三方包。npm install --save miniprogram-sm-crypto\r\nsm2获取密钥对const sm2 = require('miniprogram-sm-crypto').sm2;\r\n\r\nlet keypair = sm2.generateKeyPairHex();\r\n\r\npublicKey = keypair.publicKey; // 公钥\r\nprivateKey = keypair.privateKey; // 私钥\r\n加密解密const sm2 = require('miniprogram-sm-crypto').sm2;\r\nconst cipherMode = 1; // 1 - C1C3C2，0 - C1C2C3，默认为1\r\n\r\nlet encryptData = sm2.doEncrypt(msgString, publicKey, cipherMode); // 加密结果\r\nlet decryptData = sm2.doDecrypt(encryptData, privateKey, cipherMode); // 解密结果\r\n签名验签const sm2 = require('miniprogram-sm-crypto').sm2;\r\n\r\n// 纯签名 + 生成椭圆曲线点\r\nlet sigValueHex = sm2.doSignature(msg, privateKey); // 签名\r\nlet verifyResult = sm2.doVerifySignature(msg, sigValueHex, publicKey); // 验签结果\r\n\r\n// 纯签名\r\nlet sigValueHex2 = sm2.doSignature(msg, privateKey, {\r\n    pointPool: [sm2.getPoint(), sm2.getPoint(), sm2.getPoint(), sm2.getPoint()], // 传入事先已生成好的椭圆曲线点，可加快签名速度\r\n}); // 签名\r\nlet verifyResult2 = sm2.doVerifySignature(msg, sigValueHex2, publicKey); // 验签结果\r\n\r\n// 纯签名 + 生成椭圆曲线点 + der编解码\r\nlet sigValueHex3 = sm2.doSignature(msg, privateKey, {\r\n    der: true,\r\n}); // 签名\r\nlet verifyResult3 = sm2.doVerifySignature(msg, sigValueHex3, publicKey, {\r\n    der: true,\r\n}); // 验签结果\r\n\r\n// 纯签名 + 生成椭圆曲线点 + sm3杂凑\r\nlet sigValueHex4 = sm2.doSignature(msg, privateKey, {\r\n    hash: true,\r\n}); // 签名\r\nlet verifyResult4 = sm2.doVerifySignature(msg, sigValueHex4, publicKey, {\r\n    hash: true,\r\n}); // 验签结果\r\n\r\n// 纯签名 + 生成椭圆曲线点 + sm3杂凑（不做公钥推导）\r\nlet sigValueHex5 = sm2.doSignature(msg, privateKey, {\r\n    hash: true,\r\n    publicKey, // 传入公钥的话，可以去掉sm3杂凑中推导公钥的过程，速度会比纯签名 + 生成椭圆曲线点 + sm3杂凑快\r\n});\r\nlet verifyResult5 = sm2.doVerifySignature(msg, sigValueHex5, publicKey, {\r\n    hash: true,\r\n    publicKey,\r\n});\r\n获取椭圆曲线点const sm2 = require('miniprogram-sm-crypto').sm2;\r\n\r\nlet poin = sm2.getPoint(); // 获取一个椭圆曲线点，可在sm2签名时传入\r\nsm3const sm3 = require('miniprogram-sm-crypto').sm3;\r\n\r\nlet hashData = sm3('abc'); // 杂凑\r\nsm4加密const sm4 = require('miniprogram-sm-crypto').sm4;\r\nconst key = [0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10];\r\n\r\nlet encryptData = sm4.encrypt([0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10], key); // 加密\r\n解密const sm4 = require('miniprogram-sm-crypto').sm4;\r\nconst key = [0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10];\r\n\r\nlet decryptData = sm4.decrypt([0x68, 0x1e, 0xdf, 0x34, 0xd2, 0x06, 0x96, 0x5e, 0x86, 0xb3, 0xe9, 0x4f, 0x53, 0x6e, 0x42, 0x46], key); // 解密\r\n\r\n其他sm-crypto项目地址：https://github.com/wechat-min..."}
{"title": "小程序选人控件 - 仿企业微信实现多层级无规则嵌套 ", "author": "Rolan", "pub_time": "2018-10-30 00:12", "content": "在很多系统中都有选择联系人的需求，市面上也没什么好的参照，产品经理看企业微信的选人挺好用的，就说参照这个做一个吧。。。\r\n\r\n算了，还是试着做吧，企业微信的选人的确做的挺好，不得不佩服。\r\n先看看效果图吧，多层级无规律的嵌套都能搞定\r\n\r\n一、设计解读\r\n\r\n整个界面分为三部分：\r\n\r\n最上面的返回上一层按钮\r\n中间的显示部门、人员的列表\r\n最下面显示和操作已选人员的 footer。\r\n\r\n为什么加一个返回上一层按钮呢？\r\n我也觉得比较丑，但小程序无法直接控制左上角返回键（自定义 Title 貌似可以，没试过），点左上角的返回箭头的话就退出选人控件到上个页面了。\r\n我们的需求是点击一个文件夹，通过刷新当前列表进入下一级目录，感觉像是又进了一个页面，但其实并没有，只是列表的数据变化了。由此实现不定层级、无规律的部门和人员嵌套的支持。\r\n比如先点击了首屏数据的第二个 item，它的 index 是 1 ，就将 1 存入  indexList ；返回上一层时将最后一个元素删除。\r\n当勾选了某个人或部门时，会在底部的框中显示所有已选人员或部门的名字，当文字超过屏幕宽度时可以向右无限滑动，底部 footer 始终保持一行。\r\n最终选择的人以底部 footer 里显示的为准，点击确定时根据业务需要将已选人员数据发送给需要的界面。\r\n二、功能逻辑分析\r\n先看看数据格式\r\n{\r\n  id: TEACHER_ID,\r\n  name: '教师',\r\n  parentId: '',\r\n  checked: false,\r\n  isPeople: false,\r\n  children: [\r\n    {\r\n      id: TEACHER_DEPARTMENT_ID,\r\n      name: '部门',\r\n      parentId: 'teacher',\r\n      checked: false,\r\n      isPeople: false,\r\n      children: []\r\n    },\r\n    {\r\n      id: TEACHER_SUBJECT_ID,\r\n      name: '学科',\r\n      parentId: 'teacher',\r\n      checked: false,\r\n      isPeople: false,\r\n      children: []\r\n    },\r\n    {\r\n      id: TEACHER_GRADECLASS_ID,\r\n      name: '年级班级',\r\n      parentId: 'teacher',\r\n      checked: false,\r\n      isPeople: false,\r\n      children: []\r\n    },\r\n  ]\r\n}\r\n复制代码所有的数据组成一个数据树，子节点嵌套在父节点下。\r\nid,  name 不说了，parentId 指明它的父节点，children 包含它的所有子节点，checked 用来判断勾选状态，isPeople 判断是部门还是人员，因为两者的图标不一样。\r\n注意：\r\n本控件采用了数据分步加载的模式，除了最上层固定的几个分类，其他的每层数据都是点击具体的部门后才去请求服务器加载本部门下的数据的，然后再拼接到原始数据树上。这样可以提高加载速度，提升用户体验。\r\n我也试了一次性把所有数据都拉下来，一是太慢，得三五秒，二是数据量太大的话（我这里应该是超过1000，阈值多少没测过），setData() 的时候就会报错：\r\n\r\n超过最大长度了。。。所以只能分步加载数据。\r\n当然如果你的数据量小，几十人或几百人，也可以选择一次性加载。\r\n这个控件逻辑上还是比较复杂的，要考虑的细节太多……下面梳理一下主要的逻辑点\r\n主要逻辑点\r\n1. 需要一个数组存储所有被点击的部门在当前列表的索引 index ，这里用 indexList 表示\r\n点击某个部门进入下一层目录时，将被点击部门的 index 索引 push  进 indexList  中。点击返回上一层按钮时，删除  indexList 中最后一个元素。\r\n2. 要动态的更新当前列表 currentList\r\n每进入新的一层，或返回上一层，都需要刷新 currentList 来实现页面的更新。知道下一层数据很容易，直接取被点击 item 的 children 赋值给 currentList 即可。\r\n但如何还原上一层的数据呢？\r\n第一点记录的 indexList 就发挥作用了，原始数据树为 originalList，循环遍历 indexList ，根据索引依次取出每层的 currentList 直到 indexList 的最后一个元素，就得到了返回上一层需要显示的数据。\r\n3. 每一次勾选或取消选中都要更新原始的数据树 originalList\r\n页面是根据每个 item 的 checked 属性判断是否选中的，所以每次改变勾选状态都要设置被改变的 item 的 checked 属性，然后更新 originalList。这样即使返回上一层了，再进到当前层级选中状态还会被保留，否则刷新 currentList 后已选状态将丢失。\r\n4. 列表中选择状态的改变与底部 footer 的双联动\r\n我们期望的效果是，选中currentList 列表的某一项，底部 footer 会自动添加被选人的名字。取消选中，底部 footer 也会自动删除。\r\n也可以通过 footer 来删除已选人，点击 footer 中人名，会将此人从已选列表中删除，currentList 列表中也会自动取消勾选状态。\r\n嗯，这个功能比较耗性能，每一次都需要大量的计算。考虑到性能和速度因素，本次只做了从 footer 删除只更新 currentList 的勾选状态。\r\n什么意思呢？假如有两层，A 和 B，B 是 A 的下一层数据，即 A 是 B 的父节点。在 A 中选中了一个部门 校长室，点击下一层到 B，在 B 中又选了两个人 张三 和 李四，这时底部 footer 里显示的应该是三个： 校长室、 张三 、 李四。此时点击 footer 的 张三 ， footer 会把 张三 删除，中间列表中 张三 会被置为未选中状态，这没问题。但点击 footer 的 校长室 , 在 footer 中是把  校长室 删除了，但再返回到上一层时，中间列表中的 校长室 依然是勾选状态，因为此时没有更新原始数据树 originalList。如果觉得这是个 bug, 可以加个更新 originalList 的操作。这样就要遍历  originalList 的每个元素判断与本次删除的 id 是否相等，然后改变 checked 值，如果数据量很大，会非常慢。我做了妥协……\r\n关键的逻辑就这四块了，当然还有很多小细节，直接看代码吧，注释写的也比较详细。\r\n三、代码\r\n目录结构：\r\n\r\nfooter 文件夹下是抽离出的 footer 组件，userSelect 是选人控件的主要逻辑。把这几个文件复制过去就可以用了。\r\n把 userSelect.js 里网络请求的代码替换为你的请求代码，注意数据的字段名是否一致。\r\nuserSelect 的代码\r\n\r\nuserSelect.js\r\n\r\n\r\nimport API from '../../../utils/API.js'\r\nimport ArrayUtils from '../../../utils/ArrayUtils.js'\r\nimport EventBus from '../../../components/NotificationCenter/WxNotificationCenter.js'\r\n\r\nlet TEACHER_ID = 'teacher';\r\nlet TEACHER_DEPARTMENT_ID = 't_department';\r\nlet TEACHER_SUBJECT_ID = 't_subject';\r\nlet TEACHER_GRADECLASS_ID = 't_gradeclass';\r\nlet STUDENT_ID = 'student';\r\nlet PARENT_ID = 'parent'\r\n\r\nlet TEACHER = {\r\n  id: TEACHER_ID,\r\n  name: '教师',\r\n  parentId: '',\r\n  checked: false,\r\n  isPeople: false,\r\n  children: [\r\n    {\r\n      id: TEACHER_DEPARTMENT_ID,\r\n      name: '部门',\r\n      parentId: 'teacher',\r\n      checked: false,\r\n      isPeople: false,\r\n      children: []\r\n    },\r\n    {\r\n      id: TEACHER_SUBJECT_ID,\r\n      name: '学科',\r\n      parentId: 'teacher',\r\n      checked: false,\r\n      isPeople: false,\r\n      children: []\r\n    },\r\n    {\r\n      id: TEACHER_GRADECLASS_ID,\r\n      name: '年级班级',\r\n      parentId: 'teacher',\r\n      checked: false,\r\n      isPeople: false,\r\n      children: []\r\n    },\r\n  ]\r\n}\r\nlet STUDENT = {\r\n  id: STUDENT_ID,\r\n  name: '学生',\r\n  parentId: '',\r\n  checked: false,\r\n  isPeople: false,\r\n  children: []\r\n}\r\nlet PARENT = {\r\n  id: PARENT_ID,\r\n  name: '家长',\r\n  parentId: '',\r\n  checked: false,\r\n  isPeople: false,\r\n  children: []\r\n}\r\nlet ORIGINAL_DATA = [\r\n  TEACHER, STUDENT, PARENT\r\n]\r\n\r\nPage({\r\n  data: {\r\n    currentList: [], //当前展示的列表\r\n    selectList: [],  //已选择的元素列表\r\n    originalList: [], //最原始的数据列表\r\n    indexList: [],  //存储目录层级的数组，用于准确的返回上一层\r\n    selectList: [],  //已选中的人员列表\r\n  },\r\n\r\n  onLoad: function (options) {\r\n    wx.setNavigationBarTitle({\r\n      title: '选人控件'\r\n    })\r\n    this.init();\r\n  },\r\n\r\n  init(){\r\n    //用户的单位id\r\n    this.unitId = getApp().globalData.userInfo.unitId;\r\n    //用户类型\r\n    this.userType = 0;\r\n    //上次选中的列表，用于判断是不是取消选中了\r\n    this.lastTimeSelect = []\r\n\r\n    this.setData({\r\n      currentList: ORIGINAL_DATA, //当前展示的列表\r\n      originalList: ORIGINAL_DATA, //最原始的数据列表\r\n    })\r\n  },\r\n\r\n  clickItem(res){\r\n    console.log(res)\r\n    let index = res.currentTarget.id;\r\n    let item = this.data.currentList[index]\r\n\r\n    console.log(\"item\", item)\r\n\r\n    if (!item.isPeople) {\r\n      //点击教师，下一层数据是写死的，不用请求接口\r\n      if (item.id === TEACHER_ID) {\r\n        this.userType = 2;\r\n        this.setData({\r\n          currentList: item.children\r\n        })\r\n      } else if (item.id === TEACHER_SUBJECT_ID) {\r\n        if (item.children.length === 0){\r\n          this._getTeacherSubjectData()\r\n        }else{\r\n          //children的长度不为0时，更新 currentList\r\n          this.setData({\r\n            currentList: item.children\r\n          })\r\n        }\r\n      } else if (item.id === TEACHER_DEPARTMENT_ID) {\r\n        if (item.children.length === 0) {\r\n          this._getTeacherDepartmentData()\r\n        } else {\r\n          //children的长度不为0时，更新 currentList\r\n          this.setData({\r\n            currentList: item.children\r\n          })\r\n        }\r\n      } else if (item.id === TEACHER_GRADECLASS_ID) {\r\n        if (item.children.length === 0) {\r\n          this._getTeacherGradeClassData()\r\n        } else {\r\n          //children的长度不为0时，更新 currentList\r\n          this.setData({\r\n            currentList: item.children\r\n          })\r\n        }\r\n      } else if (item.id === STUDENT_ID) {\r\n        this.userType = 1;\r\n        if (item.children.length === 0) {\r\n          this._getStudentGradeClassData()\r\n        } else {\r\n          //children的长度不为0时，更新 currentList\r\n          this.setData({\r\n            currentList: item.children\r\n          })\r\n        }\r\n      } else if (item.id === PARENT_ID) {\r\n        this.userType = 3;\r\n        if (item.children.length === 0) {\r\n          this._getParentGradeClassData()\r\n        } else {\r\n          //children的长度不为0时，更新 currentList\r\n          this.setData({\r\n            currentList: item.children\r\n          })\r\n        }\r\n      } else{\r\n        //children的长度为0时，请求服务器\r\n        if(item.children.length === 0){\r\n          this._getUserByGroup(item)\r\n        }else{\r\n          //children的长度不为0时，更新 currentList\r\n          this.setData({\r\n            currentList: item.children\r\n          })\r\n        }\r\n      }\r\n\r\n      //将当前的索引存入索引目录中。索引多一个表示目录多一级\r\n      let indexes = this.data.indexList\r\n      indexes.push(index)\r\n      //是目录不是具体的用户\r\n      this.setData({\r\n        indexList: indexes\r\n      })\r\n      //清空上次选中的元素列表，并设置上一层的选中状态给lastTimeSelect\r\n      this.setLastTimeSelectList();\r\n    }\r\n  },\r\n\r\n\r\n  //返回按钮\r\n  goBack() {\r\n    let indexList = this.data.indexList\r\n    if (indexList.length > 0) {\r\n      //返回时删掉最后一个索引\r\n      indexList.pop()\r\n      if (indexList.length == 0) {\r\n        //indexList长度为0说明回到了最顶层\r\n        this.setData({\r\n          currentList: this.data.originalList,\r\n          indexList: indexList\r\n        })\r\n      } else {\r\n        //循环将当前索引的对应数组赋值给currentList\r\n        let list = this.data.originalList\r\n        for (let i = 0; i < indexList.length; i++) {\r\n          let index = indexList[i]\r\n          list = list[index].children\r\n        }\r\n        this.setData({\r\n          currentList: list,\r\n          indexList: indexList\r\n        })\r\n      }\r\n      //清空上次选中的元素列表，并设置上一层的选中状态给lastTimeSelect\r\n      this.setLastTimeSelectList();\r\n    }\r\n  },\r\n\r\n  //清空上次选中的元素列表，并设置上一层的选中状态给lastTimeSelect\r\n  setLastTimeSelectList(){\r\n    this.lastTimeSelect = []\r\n    this.data.currentList.forEach(item => {\r\n      if (item.checked) {\r\n        this.lastTimeSelect.push(item)\r\n      }\r\n    })\r\n  },\r\n\r\n  //获取教师部门数据\r\n  _getTeacherDepartmentData() {\r\n    this._commonRequestMethod(2, 'department')\r\n  },\r\n\r\n  //请求教师的学科数据\r\n  _getTeacherSubjectData(){\r\n    this._commonRequestMethod(2, 'subject')\r\n  },\r\n\r\n  //请求教师的年级班级\r\n  _getTeacherGradeClassData() {\r\n    this._commonRequestMethod(2, 'gradeclass')\r\n  },\r\n\r\n  //请求学生的年级班级\r\n  _getStudentGradeClassData() {\r\n    this._commonRequestMethod(1, 'gradeclass')\r\n  },\r\n\r\n  //请求家长的年级班级\r\n  _getParentGradeClassData() {\r\n    this._commonRequestMethod(3, 'gradeclass')\r\n  },\r\n\r\n  //根据部门查询人\r\n  _getUserByGroup(item){\r\n    let params = {\r\n      userType: this.userType,\r\n      unitId: this.unitId,\r\n      groupType: item.type,\r\n      groupId: item.id\r\n    }\r\n    console.log('params', params)\r\n    getApp().get(API.selectUserByGroup(), params, result => {\r\n      console.log('result', result)\r\n      let list = this.transformData(result.data.data, item.id)\r\n      this.setData({\r\n        currentList: list\r\n      })\r\n      this.addList2DataTree()\r\n      //清空上次选中的元素列表，并设置上一层的选中状态给lastTimeSelect。写在这里防止异步请求时执行顺序问题\r\n      this.setLastTimeSelectList();\r\n    })\r\n  },\r\n\r\n  //通用的请求部门方法\r\n  _commonRequestMethod(userType, groupType){\r\n    wx.showLoading({\r\n      title: '',\r\n    })\r\n    let params = {\r\n      userType: userType,\r\n      unitId: this.unitId,\r\n      groupType: groupType\r\n    }\r\n    console.log('params', params)\r\n    getApp().get(API.selectUsersByUserGroupsTree(), params, result => {\r\n      console.log('result', result)\r\n      wx.hideLoading()\r\n      let data = result.data.data\r\n      this.setData({\r\n        currentList: data\r\n      })\r\n      this.addList2DataTree();\r\n      //清空上次选中的元素列表，并设置上一层的选中状态给lastTimeSelect。写在这里防止异步请求时执行顺序问题\r\n      this.setLastTimeSelectList();\r\n    })\r\n  },\r\n\r\n  //将请求的数据转化为需要的格式\r\n  transformData(list, parentId){\r\n    //先将数据转化为固定的格式\r\n    let newList = []\r\n    for(let i=0; i<list.length; i++){\r\n      let item = list[i]\r\n      newList.push({\r\n        id: item.id,\r\n        name: item.realName,\r\n        parentId: parentId,\r\n        checked: false,\r\n        isPeople: true,\r\n        userType: item.userType,\r\n        gender: item.gender,\r\n        children: []\r\n      })\r\n    }\r\n    return newList;\r\n  },\r\n\r\n  //将当前列表挂载在原数据树上, 目前支持5层目录，如需更多接着往下写就好\r\n  addList2DataTree(){\r\n    let currentList = this.data.currentList;\r\n    let originalList = this.data.originalList;\r\n    let indexes = this.data.indexList\r\n    switch (indexes.length){\r\n      case 1: \r\n        originalList[indexes[0]].children = currentList\r\n        break;\r\n      case 2:\r\n        originalList[indexes[0]].children[indexes[1]].children = currentList\r\n        break;\r\n      case 3:\r\n        originalList[indexes[0]].children[indexes[1]].children[indexes[2]].children = currentList\r\n        break;\r\n      case 4:\r\n        originalList[indexes[0]].children[indexes[1]].children[indexes[2]].children[indexes[3]].children = currentList\r\n        break;\r\n      case 5:\r\n        originalList[indexes[0]].children[indexes[1]].children[indexes[2]].children[indexes[3]].children[indexes[4]].children = currentList\r\n        break;\r\n    }\r\n\r\n    this.setData({\r\n      originalList: originalList\r\n    })\r\n    console.log(\"originalList\", originalList)\r\n  },\r\n\r\n  //选框变化回调\r\n  checkChange(res){\r\n    console.log(res)\r\n    let values = res.detail.value\r\n    let selectItems = []\r\n    //将值取出拼接成 id，name 格式\r\n    values.forEach(value => {\r\n      let arrs = value.split(\",\")\r\n      selectItems.push({id: arrs[0], name: arrs[1]})\r\n    })\r\n    console.log(\"selectItems\", selectItems)\r\n    console.log(\"lastTimeSelect\", this.lastTimeSelect)\r\n    \r\n    //将本次选择的与上次选择的比对，本次比上次多说明新增了，本次比上次少说明删除了，找出被删除的那条数据，在footer中也删除\r\n    if (selectItems.length > this.lastTimeSelect.length){\r\n      //将 selectList 与 selectItems 拼接并去重\r\n      let newList = this.data.selectList.concat(selectItems)\r\n      newList = ArrayUtils.checkRepeat(newList)\r\n      this.setData({\r\n        selectList: newList\r\n      })\r\n    }else{\r\n      //找出取消勾选的item，从selectList中删除\r\n      //比对出取消勾选的是哪个元素\r\n      let diffItem = {}\r\n      this.lastTimeSelect.forEach(item => {\r\n        let flag = false;\r\n        selectItems.forEach(item2 => {\r\n          if(item.id === item2.id){\r\n            flag = true\r\n          }\r\n        })\r\n        if(!flag){\r\n          diffItem = item\r\n          console.log(\"diff=\", item)\r\n        }\r\n      })\r\n      //找出被删除的元素在 selectList 中的位置\r\n      let list = this.data.selectList\r\n      let delIndex = 0;\r\n      for(let i=0; i<list.length; i++){\r\n        if (list[i].id === diffItem.id){\r\n          delIndex = i;\r\n          break;\r\n        }\r\n      }\r\n      //从list中删除这个元素\r\n      list.splice(delIndex, 1)\r\n      this.setData({\r\n        selectList: list\r\n      })\r\n    }\r\n    console.log(\"selectList\", this.data.selectList)\r\n    //更新 currentList 选中状态并重新挂载在数据树上，以保存选择状态\r\n    this.updateCurrentList(this.data.currentList, this.data.selectList)\r\n  },\r\n\r\n  //footer点击删除回调\r\n  footerDelete(res){\r\n    console.log(res)\r\n    this.setData({\r\n      selectList: res.detail.selectList\r\n    })\r\n\r\n    console.log('selectList', this.data.selectList)\r\n    this.updateCurrentList(this.data.currentList, res.detail.selectList)\r\n  },\r\n\r\n  //点击 footer 的确定按钮提交数据\r\n  submitData(res){\r\n    let selectList = this.data.selectList\r\n    //通过 WxNotificationCenter 发送选择的结果通知\r\n    EventBus.postNotificationName(\"SelectPeopleDone\", selectList)\r\n    //将选择结果存入 app.js 的 globalData\r\n    getApp().globalData.selectPeopleList = selectList\r\n    //返回\r\n    wx.navigateBack({\r\n      delta: 1\r\n    })\r\n    console.log(\"selectdone\", selectList)\r\n  },\r\n\r\n  //更新 currentList 并将更新后的列表挂载在数据树上\r\n  updateCurrentList(currentList, selectList){\r\n    let newList = []\r\n    currentList.forEach(item => {\r\n      let flag = false;\r\n      selectList.forEach(item2 => {\r\n        if (item.id === item2.id) {\r\n          flag = true\r\n        }\r\n      })\r\n      if (flag) {\r\n        item.checked = true\r\n      } else {\r\n        item.checked = false\r\n      }\r\n      newList.push(item)\r\n    })\r\n    this.setData({\r\n      currentList: newList\r\n    })\r\n    this.addList2DataTree()\r\n    this.setLastTimeSelectList()\r\n  }\r\n})\r\n复制代码\r\nuserSelect.wxml\r\n\r\n<view class='container'>\r\n  <view class='btn-wrapper'>\r\n    <button bindtap='goBack'>返回上一层</button>\r\n  </view>\r\n\r\n  <view class='people-wrapper'>\r\n    <scroll-view scroll-y class='scrollview'>\r\n      <checkbox-group bindchange=\"checkChange\">\r\n        <view class='item' wx:for='{{currentList}}' wx:key='{{item.id}}'>\r\n          <checkbox checked='{{item.checked}}' value='{{item.id + \",\" + item.name}}'>\r\n          </checkbox>\r\n          <view id='{{index}}' class='item-content' bindtap='clickItem'>\r\n            <image class='img' wx:if='{{!item.isPeople}}' src='../../../assets/file.png'></image>\r\n            <image class='avatar' wx:if='{{item.isPeople}}' src='../../../assets/avatar.png'></image>\r\n            <text class='itemtext'>{{item.name}}</text>\r\n          </view>\r\n        </view>\r\n      </checkbox-group>\r\n      <view class='no-data' wx:if='{{currentList.length===0}}'>暂无数据</view>\r\n    </scroll-view>\r\n  </view>\r\n  <view class='footer'>\r\n    <footer list='{{selectList}}' binddelete='footerDelete' bindsubmit=\"submitData\"/>\r\n  </view>\r\n</view>\r\n复制代码\r\nuserSelect.wxss\r\n\r\n.container {\r\n  width: 100%;\r\n  height: 100%;\r\n  display: flex;\r\n  flex-direction: column;\r\n  padding: 20rpx;\r\n  overflow-x: hidden;\r\n  box-sizing: border-box;\r\n  background-color: #fff;\r\n}\r\n\r\n.btn-wrapper {\r\n  width: 100%;\r\n  padding: 0 20rpx;\r\n  box-sizing: border-box;\r\n}\r\n\r\n.btn {\r\n  font-size: 24rpx;\r\n  width: 100%;\r\n}\r\n\r\n.people-wrapper {\r\n  width: 100%;\r\n  margin-top: 10rpx;\r\n  margin-bottom: 100rpx;\r\n}\r\n\r\n.scrollview {\r\n  width: 100%;\r\n  display: flex;\r\n  flex-direction: column;\r\n}\r\n\r\n.item {\r\n  width: 100%;\r\n  display: flex;\r\n  flex-direction: row;\r\n  align-items: center;\r\n  padding: 30rpx 0;\r\n  margin: 0 20rpx;\r\n  border-bottom: 1rpx solid rgba(7, 17, 27, 0.1);\r\n}\r\n\r\n.item-content {\r\n  width: 100%;\r\n  display: flex;\r\n  flex-direction: row;\r\n  align-items: center;\r\n  margin-left: 20rpx;\r\n}\r\n\r\n.itemtext {\r\n  font-size: 36rpx;\r\n  color: #333;\r\n  margin-left: 20rpx;\r\n  text-align: center;\r\n}\r\n\r\n.img {\r\n  width: 50rpx;\r\n  height: 40rpx;\r\n}\r\n\r\n.avatar {\r\n  width: 50rpx;\r\n  height: 50rpx;\r\n}\r\n\r\n.footer {\r\n  position: absolute;\r\n  left: 0;\r\n  bottom: 0;\r\n  width: 100%;\r\n}\r\n\r\n.no-data{\r\n  width: 100%;\r\n  font-size: 32rpx;\r\n  text-align: center;\r\n  padding: 40rpx 0;\r\n}\r\n复制代码\r\nuserSelect.json\r\n\r\n{\r\n  \"usingComponents\": {\r\n    \"footer\": \"footer/footer\"\r\n  }\r\n}\r\n复制代码footer 的代码\r\n\r\nfooter.js\r\n\r\n\r\nComponent({\r\n  /**\r\n   * 组件的属性列表\r\n   */\r\n  properties: {\r\n    list: {\r\n      type: Array\r\n    }\r\n  },\r\n\r\n  /**\r\n   * 组件的初始数据\r\n   */\r\n  data: {\r\n    \r\n  },\r\n\r\n  /**\r\n   * 组件的方法列表\r\n   */\r\n  methods: {\r\n    delete(res){\r\n      console.log(res)\r\n      let index = res.currentTarget.id\r\n      let list = this.data.list\r\n      list.splice(index,1)\r\n      this.setData({list: list})\r\n      this.triggerEvent(\"delete\", {selectList: list})\r\n    },\r\n\r\n    /**\r\n     * 点击确定按钮\r\n     */\r\n    confirm(){\r\n      this.triggerEvent(\"submit\", \"\")\r\n    }\r\n  }\r\n})\r\n复制代码\r\nfooter.wxml\r\n\r\n<view class='container'>\r\n  <view class='scroll-wrapper'>\r\n    <scroll-view scroll-x style='scroll'>\r\n      <text id='{{index}}' class='text' wx:for='{{list}}' wx:key='{{index}}' bindtap='delete'>{{item.name}}</text>\r\n    </scroll-view>\r\n  </view>\r\n  <text class='btn' bindtap='confirm'>确定</text>\r\n</view>\r\n复制代码\r\nfooter.wxss\r\n\r\n.container {\r\n  width: 100%;\r\n  height: 100rpx;\r\n  display: flex;\r\n  flex-direction: row;\r\n  padding: 20rpx;\r\n  box-sizing: border-box;\r\n  background-color: #fff;\r\n  align-items: center;\r\n  overflow-x: hidden;\r\n  white-space: nowrap;\r\n  border-top: 2rpx solid rgba(7, 17, 27, 0.1)\r\n}\r\n\r\n.scroll-wrapper {\r\n  flex: 1;\r\n  overflow-x: hidden;\r\n  white-space: nowrap;\r\n}\r\n\r\n.scroll {\r\n  width: 100%;\r\n\r\n}\r\n\r\n.text {\r\n  font-size: 32rpx;\r\n  color: #333;\r\n  padding: 40rpx 20rpx;\r\n  margin-right: 10rpx;\r\n  background-color: #f5f5f5;\r\n}\r\n\r\n.btn {\r\n  padding: 10rpx 20rpx;\r\n  background-color: rgb(26, 173, 25);\r\n  border-radius: 10rpx;\r\n  font-size: 32rpx;\r\n  color: #fff;\r\n}\r\n复制代码\r\nfooter.json\r\n\r\n{\r\n  \"component\": true,\r\n  \"usingComponents\": {}\r\n}\r\n复制代码再补一个用到的 ArrayUtils 的代码\r\nexport default{\r\n\r\n  /**\r\n     * 给数组去重\r\n     */\r\n  checkRepeat(list) {\r\n    let noRepList = [list[0]]\r\n    for (let i = 0; i < list.length; i++) {\r\n      let repeat = false\r\n      for (let j = 0; j < noRepList.length; j++) {\r\n        if (noRepList[j].id === list[i].id) {\r\n          repeat = true\r\n          break\r\n        }\r\n      }\r\n      if (!repeat) {\r\n        noRepList.push(list[i])\r\n      }\r\n    }\r\n    return noRepList\r\n  },\r\n\r\n  //删除list中id为 delId 的元素\r\n  deleteItemById(list, delId){\r\n    for (let i = 0; i < list.length; i++) {\r\n      if (list[i].id == delId) {\r\n        list.splice(i, 1)\r\n        return list;\r\n      }\r\n    }\r\n    return list;\r\n  }\r\n\r\n}\r\n复制代码由于时间紧张，还没有把这个控件单独从项目中抽出来写个 Demo，有时间了会给 github 地址的。\r\n代码还有很多可以优化的地方，比如有几个方法太长了，不符合单一职责原则等等，不想改了，以后再优化吧。。\r\n水平有限，各位大侠请轻喷~\r\n有问题或发现 Bug 请在评论区留言，毕竟刚写完就分享出来了，还没经过严格的测试。不过应该没什么大的问题。。。有些细节可能没注意到。\r\n关注下面的标签，发现更多相似文章作者：solocoder链接：https://juejin.im/post/5bd3ec0551882528382d8028"}
{"title": "小程序·云开发初级FAQ ", "author": "Rolan", "pub_time": "2018-10-30 00:23", "content": "之前参加过小程序·云开发相关的分享, 在团队内进行了推广, 感觉官方的宣传不够直接, 还是太玄乎了, 这是收集了猫眼娱乐前端工程师的问题, 和相关答疑, 部分问题是和小程序·云开发的同学沟通过的结论主要面向初级前端工程师, 快速了解云开发是怎么回事, 不涉及复杂代码有小程序开发经验理解 server 端基础, 并有少量node.js server端经验1. 小程序云开发是什么?官方文档, 不用着急点, 下面FAQ未提及的可以进来看主要提供两种能力1.1 提供持久存储持久存储是指删除微信或更换手机后, 用户重新打开我们的小程序, 仍旧能让用户看到自己的信息主要通过两种存储容器类mangodb的 数据库存储 , 比如用户提交的文章文件存储 , 比如用户上传的照片1.2 提供简化的server端编程环境云函数简单解释: 在小程序端写上函数名 + 参数, 就能调用远端的一个函数为什么不直接写到小程序端, 而要绕弯子要这样? 最常见的原因是:有些业务逻辑涉及 保密信息 , 不能写在小程序上, 比如: 价格计算, 交易流程有些操作需要 更高的权限 , 比如: 管理员可以删除所有用户的数据.桥接到第三方接口, 小程序https接口域名数量超限, 或者第三方接口不是https接口.2. 直接操作数据库会不会有安全问题云开发的数据库和传统数据库有些区别, 他会自动给每个数据表增加一个 创建人字段 + 表权限设置 , 后续的操作都会基于这些约束, 一般的策略是每个用户只能修改自己创建的信息, 比如自己发的文章每个用户只能读取其他用户的信息, 但不能修改, 比如其他人发的文章每个用户只能读取公共信息, 但不能修改, 比如公告信息, 一般会允许通过管理端修改3. 直接操作文件存储会不会有安全风险类似上一个数据库的权限, 通过 文件创建人 + 文件夹权限设置文件的操作使用服务端生成的唯一ID, 不会被穷举4. 别人会不会调用我的云函数不会, 云函数的网络协议是私有的, 并且有加上数字签名验证这套机制是在微信app内部实现的, 除非微信这套机制被攻破5.云函数是用js写么, 运行环境是什么?是js, 运行环境是nodejs 8.9, 支持async await关键字目前还不支持修改运行环境, 未来应该会支持自选环境6. 使用了云开发, 是不是就不能使用自己的服务端了不是, 两个可以并存, 就当是看起来不一样的异步调用就好// 云开发相关api\r\nwx.cloud.xxxx()\r\n\r\n// 自有服务\r\nwx.request()\r\n复制代码由于是nodejs的运行环境, 所以云函数可以使用http tcp模块, 这样就能通过云函数转发请求到任意域名, 不受小程序端的请求域名限制7. 典型的云函数是什么样的?// 小程序端, 调用\r\nwx.cloud.callFunction({\r\n    name: 'foo',\r\n    data: { a: 1, b: 2 },\r\n    success: function(res) {\r\n        console.log(res.result)\r\n    }\r\n)\r\n\r\n// 云函数, 声明\r\n// cloudfunctionRoot/functions/foo/index.js\r\nexports.main = async function(e, ctx) {\r\n    return e.a + e.b\r\n}\r\n复制代码函数名和目录名对应, 根路径在project.config.json中定义, 详细参考官方文档中的\"我的第一个云函数\"8. 云函数还有什么特殊能力?直接获取用户的openId// index.js\r\nexports.main = (event, context) => {\r\n  return event.userInfo\r\n}\r\n复制代码如要获取用户头像 昵称等信息, 还是需要在小程序端进行授权才行9. 云函数需要我们考虑服务器运维的工作么不需要, 只要开发好上传就行, 运行环境是独立 封闭的, 类 CentOS 7 的环境10. 开发时和线上环境有隔离么提供1个生产环境, 和1个开发环境, 存储和云函数都是独立的这意味着多个开发者并行开发协作可能会有些小麻烦, 同时只能有一套代码在开发环境, 这就只能通过一些工作流程约定, 比如收敛上传权限, 每日自动部署. 应用类似git-flow的分支策略11. 云开发是否提供有定位 地理信息 支付相关业务的支持暂时没有, 这方面的需求还是很强的, 毕竟小程序是提倡线下扫码, 扫码后还是期望能够获取到附近的相关信息, 简单的比如城市 区划, 详细的比如商家小程序云开发的同学目前还在收集这方面的需求12. 什么版本的基础库支持云开发基础库 2.2.3 之后开始支持, 但对于旧版本可以加个配置也能支持app.json/game.json{\r\n  \"cloud\": true\r\n}\r\n复制代码13. 费用呢目前免费, 正在调研计费策略, 可能是按照调用量, 存储量计费netwjx曹宇   https://juejin.im/post/5bcd5df7518825780d09b145"}
{"title": "微信小程序多层嵌套循环，三级数组遍历 ", "author": "Rolan", "pub_time": "2018-10-30 00:32", "content": "数据：三层嵌套index.wxml 页面<!-- 菜单标签 -->\r\n<view class='menu_label'>\r\n    <view class='label_ul'>\r\n        <view wx:for=\"{{ menuList }}\" wx:key='' class=\"{{ label_index == index ? 'label_lis' : 'label_li' }}\" bindtap='menuList' id=\"{{ index }}\">{{ item.title }}</view>\r\n    </view>\r\n</view>\r\n\r\n<!-- 图书内容 -->\r\n<view class='book_sec'>\r\n    <view class='book_ul' wx:for=\"{{ bookUl }}\" wx:key='' wx:for-item=\"secUl\"  wx:if=\"{{ label_index == index }}\" id=\"{{ index }}\">\r\n        <view class='book_li' wx:for='{{ secUl.bookSec }}' wx:key='' wx:for-item=\"secLi\">\r\n            <view class='book_ol'>\r\n                <view class='book_ol_li' wx:for='{{ secLi.bookList }}' wx:key='' wx:for-item=\"item\">\r\n                    <view class='book_free b'>免费阅读</view>\r\n                    <image src='{{ item.img }}'></image>\r\n                    <view class='book_people b'>100006人在读</view>\r\n                </view>\r\n            </view>\r\n        </view>\r\n    </view>\r\n</view>\r\n\r\n\r\nindex.js页面Page({\r\n        /**\r\n         * 页面的初始数据\r\n         */\r\n        data: {\r\n            menuList: [\r\n                { title: '全部' },\r\n                { title: '文学' },\r\n                { title: '技术类' },\r\n                { title: '社会科学' },\r\n                { title: '设计' },\r\n                { title: '技术类' },\r\n                { title: '社会科学' },\r\n            ],\r\n            label_index: 0,\r\n            bookUl: [\r\n                {\r\n                    bookSec: [\r\n                        {\r\n                            bookList: [\r\n                                { img: '../../img/img1_icon.png' },\r\n                                { img: '../../img/img2_icon.png' },\r\n                                { img: '../../img/img3_icon.png' },\r\n                            ]\r\n                        },\r\n                        {\r\n                            bookList: [\r\n                                { img: '../../img/img4_icon.png' },\r\n                                { img: '../../img/img5_icon.png' },\r\n                            ]\r\n                        }\r\n                    ]\r\n                },\r\n                {\r\n                    bookSec: [\r\n                        {\r\n                            bookList: [\r\n                                { img: '../../img/img6_icon.png' },\r\n                                { img: '../../img/img5_icon.png' },\r\n                                { img: '../../img/img4_icon.png' }\r\n                            ]\r\n                        },\r\n                        {\r\n                            bookList: [\r\n                                { img: '../../img/img7_icon.png' }\r\n                            ]\r\n                        }\r\n                    ]\r\n                },\r\n                {\r\n                    bookSec: [\r\n                        {\r\n                            bookList: [\r\n                                { img: '../../img/img7_icon.png' },\r\n                                { img: '../../img/img2_icon.png' },\r\n                                { img: '../../img/img1_icon.png' },\r\n                            ]\r\n                        },\r\n                        {\r\n                            bookList: [\r\n                                { img: '../../img/img3_icon.png' },\r\n                                { img: '../../img/img4_icon.png' },\r\n                                { img: '../../img/img6_icon.png' }\r\n                            ]\r\n                        }\r\n                    ]\r\n                },\r\n            ]\r\n            \r\n            /**\r\n             * 菜单点击切换内容\r\n             */\r\n        \r\n            menuList: function (e) {\r\n                let that = this;\r\n                // console.log(e);\r\n                var id = e.target.id;\r\n                \r\n                that.setData({\r\n                    label_index: id\r\n                })\r\n            } \r\n        },\r\n    })\r\n\r\n如果列表中项目的位置会动态改变或者有新的项目添加到列表中，并且希望列表中的项目保持自己的特征和状态（如 <input/> 中的输入内容，<switch/> 的选中状态），需要使用 wx:key 来指定列表中项目的唯一的标识符。如不提供 wx:key，会报一个 warning， 如果明确知道该列表是静态，或者不必关注其顺序，可以选择忽略。wx:key 的值以两种形式提供1）字符串，代表在 for 循环的 array 中 item 的某个 property，该 property 的值需要是列表中唯一的字符串或数字，且不能动态改变。2）保留关键字 *this 代表在 for 循环中的 item 本身，这种表示需要 item 本身是一个唯一的字符串或者数字，如：当数据改变触发渲染层重新渲染的时候，会校正带有 key 的组件，框架会确保他们被重新排序，而不是重新创建，以确保使组件保持自身的状态，并且提高列表渲染时的效率。最后效果图作者：MRZYD原文：https://segmentfault.com/a/1190000016818075"}
{"title": "小程序tabbar这套方案全搞定！ ", "author": "Rolan", "pub_time": "2018-10-31 00:12", "content": "关于微信小程序的tarbar，相信你们都不会陌生 在实现小程序微信原装的tabbar却比较呆板，不够精致，往往不符合自己的要求这个时候怎么办呢这套方案接着！先简单的来说一下主要思想:自定义字体图标组件以及tabbar组件，在tabbar中引用自定义字体图标组件。先说一下这套方案的优点：图片换成字体,体积小,请求减少,性能提高自己定义tabbar,能够从细节各方面达到自己的要求，精确到1像素组件可以根据自己的条件来更换tabbar图标（比如你点进一个页面想把这个页面的tabbar样式自己更换） 总而言之就是自由性很大，精准性良好，能够去随心所欲的打造你的专属tabbar!实现这套方案核心还是自定义组件那就从这开始聊：一个自定义组件由 json wxml wxss js 4个文件组成。一个页面要引用一个组件时只需要在该页面的json配置下添加如下{\r\n//声明引用一个组件 配置好你的组件引用路径\r\n  \"usingComponents\": {\r\n    \"icon\": \"../../components/icon/index\"\r\n  }\r\n}\r\n复制代码然后再页面上添加组件的标签即可。//这样就能够在你的页面中添加组件\r\n<icon type=\"\" color=\"\" size=\"\"/>\r\n复制代码如果对于组件的定义仍有疑惑的可以参考这份文档： 官方关于自定义组件的文档OK 下面我们正式来讲这份方案：先定义字体图标组件，在阿里图标库里面挑选好你所需要的字体选择下载代码。 这里我选择的是其中的_fontclass方案，把iconfont.css内的内容拷贝到你创建的icon目录下的index.wxss3. 将该目录下index.json添加{  \r\n//声明这一组文件设为自定义组件\r\n  \"component\": true,\r\n  \"usingComponents\": {}\r\n}\r\n复制代码在index.wxml中定义该组件的结构<!-- 注意style里面的分号！ -->\r\n<text class=\"iconfont icon-{{type}}\" style=\"color:{{color}}; font-size:{{size}}rpx\" ></text>\r\n复制代码在js里面配置他的属性//这里定义了3个自定义属性他们通过{{}}与wxml中的数据连接起来\r\n Component({\r\n  properties: {\r\n    type: {\r\n      type: String,\r\n      value: ''\r\n    },\r\n    color: {\r\n      type: String,\r\n      value: '#000000'\r\n    },\r\n    size: {\r\n      type: Number,\r\n      value: '45'\r\n    }\r\n  }\r\n})\r\n复制代码到此，字体图标组件搞定。现在开始第二步，搞定tabbar组件。首先做在json中添加配置{\r\n  \"component\": true,\r\n  //声明对字体图标组件的引用\r\n  \"usingComponents\": {\r\n    \"icon\": \"../../components/icon/index\"\r\n  }\r\n}\r\n复制代码写wxml结构<view class=\"weibo-tabbar\" >\r\n//绑定回首页事件，此处的data-hi中的数据是为了传递到e.currentTarget.dataset.hi\r\n//通过这个数据我们可以用来判断是否处于首页，然后在js中配置可以阻扰原地跳转\r\n    <view class=\"item-left\"  bindtap=\"goHome\" data-hi=\"{{isIndex}}\">\r\n            <icon type=\"shouye\" color=\"{{isIndex?'#000000':'#b1b1b1'}}\" size=\"45\"/>\r\n            <text class=\"1\" style=\"color:{{isIndex?'#000000':'#b1b1b1'}}\">首页</text>\r\n    </view>\r\n    <block wx:if=\"{{isInner}}\">\r\n        <view class=\"item-right\" style=\"color:#b1b1b1\" bindtap=\"goShare\">\r\n        <icon type=\"fenxiang\" color=\"gray\" size=\"45\"/>\r\n            <text class=\"2\">分享</text>\r\n        </view>\r\n    </block>\r\n    <block wx:else>\r\n        <view class=\"item-right\"  bindtap=\"goInfo\" data-hi=\"{{isIndex}}\">\r\n        <icon type=\"wode\" color=\"{{isIndex?'#b1b1b1':'#000000'}}\" size=\"45\"/>\r\n            <text class=\"2\" style=\"color:{{isIndex?'#b1b1b1':'#000000'}}\">我的</text>\r\n        </view>\r\n    </block>\r\n</view>\r\n复制代码再配置js属性及方法const app = getApp();\r\nComponent({\r\n  properties: {\r\n    isIndex: { // 是否主页            \r\n      type: Boolean,\r\n      value: false,\r\n    },\r\n    isInner: { //是否内部页面\r\n      type: Boolean,\r\n      value: false,\r\n    },\r\n  },\r\n  data: {\r\n    // 这里是一些组件内部数据\r\n    someData: {}\r\n  },\r\n  methods: {\r\n    // 这里是一个自定义方法\r\n    goHome: (e) => {\r\n      // 判断是否为主页面防止原地跳转\r\n      if(!e.currentTarget.dataset.hi){\r\n        wx.redirectTo({\r\n          url: \"/pages/index/index\"\r\n        })\r\n      }\r\n    },\r\n    goShare: function () {\r\n    },\r\n    goInfo: (e) => {\r\n        if(e.currentTarget.dataset.hi){\r\n        wx.redirectTo({\r\n          url: \"/pages/info/info\"\r\n        })\r\n      }\r\n    }\r\n  }\r\n})\r\n复制代码配置样式wxss.weibo-tabbar {\r\n    bottom: 0;\r\n    height: 97rpx;\r\n    padding: 12rpx 0rpx;\r\n    display: flex;\r\n    width: 100%;\r\n    position: fixed;\r\n    background: #ffffff;\r\n    box-sizing: border-box;\r\n}\r\n//产生优雅的0.5px边框\r\n.weibo-tabbar::after {\r\n    content: \"\";\r\n    position: absolute;\r\n    width: 200%;\r\n    height: 200%;\r\n    top: 0;\r\n    left: 0;\r\n    border-top: 1rpx solid rgba(177, 177, 177, 0.4);\r\n    transform: scale(0.5);\r\n    transform-origin: 0 0;\r\n  }\r\n  //这里用flex布局，移动端flex布局确实很爽\r\n  .weibo-tabbar .item-left, .item-right{\r\n   //这里有一处坑，若不不设置他的层级变大的话\r\n   //你是点不到这个item按钮的，当然也不会产生触碰事件\r\n    z-index: 999;\r\n    width: 50%;\r\n    display: flex;\r\n    justify-content: center;\r\n    align-items: center;\r\n    flex-direction: column;\r\n    font-size: 20rpx;\r\n    color: #b1b1b1;\r\n}\r\n.shouye, .wode {\r\n    height: 45rpx;\r\n    width: 45rpx;\r\n}\r\n复制代码到此你只需要在你的页面优雅的添加一行，就能在你的页面中产生tabbar//此处isIndex是给组件的属性传输值，别属性不添加即为默认属性值\r\n<tabbar isIndex=\"true\"></tabbar>\r\n复制代码结果：哇，看了半天就出这么一个小东西！其实大道至简掌握这套方案能够适配你需要的所有tabbar他的颜色、大小、位置都可以自己掌控，重要的是这个解决方案。最后强调一下里面的一些坑按钮的样式层级z-index要提高属性值与{{}}传输的把握style=\"color:{{color}}; font-size:{{size}}\" 注意里面的;号"}
{"title": "在小程序开发中使用 npm ", "author": "Rolan", "pub_time": "2018-10-12 00:37", "content": "本文介绍了如何在微信小程序开发中使用 npm 中包的功能，大大提高微信小程序的开发效率，同时也是微信小程序系列教程的视频版更新。微信小程序在发布之初没有对 npm 的支持功能，这也是目前很多前端开发人员在熟悉了 npm 生态环境后，对微信小程序诟病的地方。微信小程序在 2.2.1 版本后增加了对 npm 包加载的支持，使得小程序支持使用 npm 安装第三方包。微信小程序的功能更新最近更新的也非常给力，如之前给大家介绍的 微信小程序开发平台新功能「云开发」快速上手体验 。1. 在小程序中加载 npm 包微信小程序关于 npm 包的加载使用官方文档在 这里 ，此实战部分我们通过加载一个 npm 的第三方库 miniprogram-datepicker ，此类库用于实现公历与农历的日期选择功能，而微信小程序官方的组件只能简单地选择一个公历时间。在终端中定位到微信小程序的项目文件夹，通过 npm 的安装命令安装。此处请务必使用 –production 选项，可以减少安装一些业务无关的 npm 包，从而减少整个小程序包的大小。2. 构建 npm 包在微信小程序开发工具的「工具」菜单下点击「构建 npm」命令，进行 npm 包的构建，此构建可以将 npm 包构建成在小程序中可加载使用的包。为了帮助大家更好的理解发布 npm 包中提到的各种要求，这里简单介绍一下原理：首先 node_modules 目录不会参与编译、上传和打包中，所以小程序想要使用 npm 包必须走一遍“构建 npm”的过程，在最外层的 node_modules 的同级目录下会生成一个 miniprogram_npm 目录，里面会存放构建打包后的 npm 包，也就是小程序真正使用的 npm 包。构建打包分为两种：小程序 npm 包会直接拷贝构建文件生成目录下的所有文件到 miniprogram_npm 中；其他 npm 包则会从入口 js 文件开始走一遍依赖分析和打包过程（类似 webpack）。寻找 npm 包的过程和 npm 的实现类似，从依赖 npm 包的文件所在目录开始逐层往外找，直到找到可用的 npm 包或是小程序根目录为止。构建完成后还需要确认项目已勾选了「使用 npm 模块」。3. 在项目中使用第三方模块在我们之前实战项目中，在首页中测试下此 npm 模块的加载。<view class=\"doc-container\">\r\n  <view class=\"doc-title\">今日精选</view>\r\n\r\n  <datepicker value=\"\" bindchange=\"bindSolarChange\">\r\n    <button type=\"default\">公历</button>\r\n  </datepicker>\r\n  <datepicker value=\"\" chinese=\"true\" bindchange=\"bindLunarChange\">\r\n    <button type=\"default\">农历</button>\r\n  </datepicker>\r\n\r\n  <block wx:for=\"\" wx:key=\"\">\r\n    <view class=\"list\" data-para=\"\" bindtap=\"tapItem\">\r\n      <view class=\"view_preinfo\">\r\n        <text class=\"list_preinfo\"> / </text>\r\n      </view>\r\n      <text class=\"list_title\"></text>\r\n      <view>\r\n        <block wx:for=\"\" wx:key=\"\">\r\n          <text class=\"list_tag\" style=\"border: solid 1px ;\"></text>\r\n        </block>\r\n      </view>\r\n    </view>\r\n  </block>\r\n</view>在页面中布局完 datepicker 后，保存并完成项目的编译后，点击按钮即可看到组件的加载情况。"}
{"title": "微信小程序裁剪图片成圆形 ", "author": "Rolan", "pub_time": "2018-10-12 10:00", "content": "前言最近在开发小程序，产品经理提了一个需求，要求微信小程序换头像，用户剪裁图片必须是圆形，也在github上看了一些例子，一般剪裁图片用的都是方形，所以自己打算写一个小组件，可以把图片剪裁成圆形，主要思路就是使用canvas绘图，把剪裁的图片绘制成圆形，另外剪裁图片的窗口还可以移动放大缩小，这个功能就用了微信组件movable-view，好了，该说的也说完了，下面咱们开始撸代码。movable-view组件可移动的视图容器，在页面中可以拖拽滑动\r\n会有好多个属性，在这里不一一介绍，只说我们能用到的就可以。\r\n我们用到的属性主要有：direction：movable-view的移动方向，属性值有all、vertical、horizontal、nonescale：是否支持双指缩放，默认缩放手势生效区域是在movable-view内scale-min\t定义缩放倍数最小值scale-max\t定义缩放倍数最大值bindchange\t拖动过程中触发的事件，event.detail = {x: x, y: y, source: source}，其中source表示产生移动的原因，值可为touch（拖动）、touch-out-of-bounds（超出移动范围）、out-of-bounds（超出移动范围后的回弹）、friction（惯性）和空字符串（setData）bindscale\t缩放过程中触发的事件，event.detail = {x: x, y: y, scale: scale}，其中x和y字段在2.1.0之后开始支持返回主要用到的就是这几个值另外使用movable-view的时候必须在外边加一个movable-area的父元素，不然的话没有移动区域。movable-view 的可移动区域，属性只有：scale-area\t当里面的movable-view设置为支持双指缩放时，设置此值可将缩放手势生效区域修改为整个movable-area，是个boolean值，默认false截取区域的移动已经说完了，详情请看developers.weixin.qq.com/miniprogram…canvas绘图画布。该组件是原生组件可以绘制图像，分享朋友圈生成海报就经常用到这个属性，就简单的说下：在wxml中必须要有canvas这个标签，才可以绘制图像，而且要有canvas-id属性，代表canvas 组件的唯一标识符，还有许多API我就不一一介绍了，底下用的API代码当中都会用注释。详情请看微信小程序画布APIhttps://developers.weixin.qq.com/miniprogram/dev/api/canvas/wx.canvasGetImageData.html代码实现首先是选择图片wxml就是初始化一个按钮点击的时候选择图片，而且需要引入我们封装的截取图片组件，并把图片作为参数传进去，封装组件方法请看我另一篇文章juejin.im/post/5afcee…index.wxmlTip: 必须把canvas放到引入剪裁组件的wxml中，否则绘制不成功，因为canvas是原生组件脱离在 WebView 渲染流程外。<view class=\"container\">\r\n  <button wx:if=\"{{!imgSrc}}\" bindtap=\"getImgurl\"> 选择图片 button>\r\n  <view class=\"clip-box\" wx:if=\"{{imgSrc}}\">\r\n      <ClipImg imgSrc=\"{{imgSrc}}\">ClipImg>\r\n  view>\r\nview>\r\n<canvas canvas-id=\"myCanvas\" style=\"position:absolute; width:100%;height:100%;border: 1px solid red;left: -9999px; top: -9999px;\">canvas>\r\n复制代码index.json引入截取图片的组件{\r\n    \"component\": true,\r\n    \"usingComponents\": {\r\n        \"ClipImg\": \"../../component/clipImg/clipImg\"\r\n    }\r\n}\r\n复制代码index.js上传图片显示const app = getApp()\r\n\r\nPage({\r\n  data: {\r\n    imgSrc: ''\r\n  },\r\n  //选择图片\r\n  getImgurl: function () {\r\n    wx.chooseImage({\r\n      count: 1, // 默认9\r\n      sizeType: ['original', 'compressed'], // 可以指定是原图还是压缩图，默认二者都有\r\n      sourceType: ['album', 'camera'], // 可以指定来源是相册还是相机，默认二者都有\r\n      success:  (res) => {\r\n        // 返回选定照片的本地文件路径列表，tempFilePath可以作为img标签的src属性显示图片\r\n        const tempFilePaths = res.tempFilePaths;\r\n        //启动上传等待中...  \r\n        wx.showToast({  \r\n          title: '正在上传...',  \r\n          icon: 'loading',  \r\n          mask: true,  \r\n          duration: 1000 \r\n        }) \r\n        this.setData({\r\n          imgSrc: res.tempFilePaths\r\n        })\r\n      }\r\n    })\r\n  },\r\n  onLoad: function () {\r\n  }\r\n})\r\n复制代码接下来就是剪裁图片组件的封装首先是页面布局，也就是clipImg.wxml<view class=\"clip\">\r\n    <image class=\"head-img\" style=\"width:{{cropperW}}rpx;height:{{cropperH}}rpx\" src=\"{{imageUrl}}\">image>\r\n    <movable-area scale-area style=\"width:{{cropperW}}rpx;height:{{cropperH}}rpx\">\r\n        <movable-view bindchange=\"move\" bindscale=\"scale\" direction=\"all\" scale scale-min=\"0.5\" scale-max=\"1.8\">\r\n        movable-view>\r\n    movable-area>\r\n    <view class=\"btn\">\r\n        <text bindtap=\"cancel\">取消text>\r\n        <text bindtap=\"getImageInfo\">保存text>\r\n    view>\r\nview>\r\n复制代码大概就是这个样子上边的圆就是截取就是截取框。然后就是clipImg.js文件主要就是对图片截取的一些操作Component({\r\n  /**\r\n   * 组件的属性列表\r\n   */\r\n  properties: {\r\n    imgSrc: {\r\n      type: 'String',\r\n      value: ''\r\n    }\r\n  },\r\n\r\n  /**\r\n   * 组件的初始数据\r\n   * imageUrl string 初始化图片\r\n   * cropperW string 缩小图宽度\r\n   * cropperH  string 缩小图高度,\r\n   * img_ratio string  图片比例,\r\n   * IMG_W string 原图高度,\r\n   * IMG_H string 原图高度,\r\n   * left string 图片距离左边距离,\r\n   * top string 图片距离上边距离,\r\n   * clipW number 默认截取框\r\n   */\r\n  data: {\r\n    imageUrl: '',\r\n    cropperW: '',\r\n    cropperH: '',\r\n    img_ratio: '',\r\n    IMG_W: '',\r\n    IMG_H: '',\r\n    left: '',\r\n    top: '',\r\n    clipW: 200\r\n  },\r\n\r\n  /**\r\n   * 组件的方法列表\r\n   */\r\n  methods: {\r\n    //点击取消\r\n    cancel: function () {\r\n      var myEventDetail = {} // detail对象，提供给事件监听函数\r\n      var myEventOption = {} // 触发事件的选项\r\n      this.triggerEvent('myevent', myEventDetail, myEventOption)\r\n    },\r\n    //拖拽事件\r\n    move: function ({ detail }) {\r\n      this.setData({\r\n        left: detail.x * 2,\r\n        top: detail.y * 2\r\n      })\r\n    },\r\n    //缩放事件\r\n    scale: function ({ detail }) {\r\n      console.log(detail.scale)\r\n      this.setData({\r\n        clipW: 200 * detail.scale\r\n      })\r\n    },\r\n    //生成图片\r\n    getImageInfo: function () {\r\n      wx.showLoading({\r\n        title: '图片生成中...',\r\n      })\r\n      const img_ratio = this.data.img_ratio;\r\n      //要截取canvas的宽\r\n      const canvasW = (this.data.clipW / this.data.cropperW) * this.data.IMG_W\r\n      //要截取canvas的高\r\n      const canvasH = (this.data.clipW / this.data.cropperH) * this.data.IMG_H\r\n      //要截取canvas到左边距离\r\n      const canvasL = (this.data.left / this.data.cropperW) * this.data.IMG_W\r\n      //要截取canvas到上边距离\r\n      const canvasT = (this.data.top / this.data.cropperH) * this.data.IMG_H\r\n      // 将图片写入画布\r\n      const ctx = wx.createCanvasContext('myCanvas');\r\n      //绘制图像到画布\r\n      ctx.save(); // 先保存状态 已便于画完圆再用        \r\n      ctx.beginPath(); //开始绘制  \r\n      ctx.clearRect(0, 0, 1000, 1000)\r\n      //先画个圆      \r\n      ctx.arc(this.data.clipW / 2, this.data.clipW / 2, this.data.clipW / 2, 0, 2 * Math.PI, false)\r\n      ctx.clip();//画了圆 再剪切  原始画布中剪切任意形状和尺寸。一旦剪切了某个区域，则所有之后的绘图都会被限制在被剪切的区域内    \r\n      ctx.drawImage(this.data.imageUrl, canvasL, canvasT, canvasW, canvasH, 0, 0, this.data.clipW, this.data.clipW); // 推进去图片        \r\n      ctx.restore(); //恢复之前保存的绘图上下文 恢复之前保存的绘图上下午即状态 可以继续绘制\r\n      ctx.draw(true, () => {\r\n        // 获取画布要裁剪的位置和宽度   \r\n        wx.canvasToTempFilePath({\r\n          x: 0,\r\n          y: 0,\r\n          width: this.data.clipW,\r\n          height: this.data.clipW,\r\n          destWidth: this.data.clipW,\r\n          destHeight: this.data.clipW,\r\n          quality: 0.5,\r\n          canvasId: 'myCanvas',\r\n          success: (res) => {\r\n            wx.hideLoading()\r\n            /**\r\n             * 截取成功后可以上传的服务端直接调用\r\n             * wx.uploadFile();\r\n             */\r\n            //成功获得地址的地方\r\n            wx.previewImage({\r\n              current: '', // 当前显示图片的http链接\r\n              urls: [res.tempFilePath] // 需要预览的图片http链接列表\r\n            })\r\n          }\r\n        })\r\n      })\r\n    }\r\n  },\r\n  ready: function () {\r\n    this.setData({\r\n      imageUrl: this.data.imgSrc[0]\r\n    })\r\n    //获取图片宽高\r\n    wx.getImageInfo({\r\n      src: this.data.imageUrl,\r\n      success: (res) => {\r\n        console.log('图片信息', res);\r\n        //图片实际款高\r\n        const width = res.width;\r\n        const height = res.height;\r\n        //图片宽高比例\r\n        const img_ratio = width / height\r\n        this.setData({\r\n          img_ratio,\r\n          IMG_W: width,\r\n          IMG_H: height,\r\n        })\r\n        if (img_ratio >= 1) {\r\n          //宽比较大，横着显示\r\n          this.setData({\r\n            cropperW: 750,\r\n            cropperH: 750 / img_ratio,\r\n          })\r\n        } else {\r\n          //竖着显示\r\n          this.setData({\r\n            cropperW: 750 * img_ratio,\r\n            cropperH: 750\r\n          })\r\n        }\r\n      } \r\n    })\r\n  }\r\n})\r\n复制代码到现在为止一个截取图片就完成了，可能会有些问题，比如截取的图片的框没有居中，自己可以再次封装这个组件，因为现在已经适合我们公司自己项目了。我们来预览下。另外这个组件支持双指放大截取框来截取图片，不过微信开发者工具不能展示，自己可以把代码下载下来，在自己手机上扫码查看效果。另外我把项目放到了github上边，希望小哥哥小姐姐们多多点赞，多多支持。使用的时候直接把component里边的组件直接引进去就行，有什么疑问可以在github底下留言问我，谢谢。点赞的小哥哥小姐姐最可爱，哈哈哈。。。项目地址github.com/Mr-MengBo/i…"}
{"title": "微信小程序如何开发跑马灯效果？ ", "author": "Rolan", "pub_time": "2018-10-15 00:06", "content": "跑马灯效果比较常见，一般做电商类的小程序，都会用到，所以代码君今天特地写一篇文章，来教一下大家，如何去实现跑马灯效果，下面是代码君实现的效果，可以先看一下！跑马灯效果的制作制作方式很简单，先方上代码，后面会对代码详细讲解一、wxml界面的实现<!-- 跑马灯效果  -->\r\n    <view class=\"example\">\r\n      <view class=\"marquee_box\">\r\n        <view class=\"marquee_text\" style=\"{{orientation}}:{{marqueeDistance}}px;font-size: {{size}}px;\">\r\n          <image src=\"{{adUrl}}\" class='ad-image' />{{text}}\r\n        </view>\r\n      </view>\r\n    </view>\r\n复制代码界面布局很简单，一个底部背景容器，加入一个广播图片和对应的跑马灯文字二、wxss样式.example {\r\n  display: block;\r\n  width: 100%;\r\n  height: 70rpx;\r\n  background-color: #f2f2f2;\r\n  line-height: 70rpx;\r\n}\r\n\r\n.marquee_box {\r\n  width: 100%;\r\n  position: relative;\r\n}\r\n\r\n.marquee_text {\r\n  white-space: nowrap;\r\n  position: absolute;\r\n  top: 0;\r\n  display: flex;\r\n  flex-direction: row;\r\n}\r\n\r\n.ad-image {\r\n  width: 40rpx;\r\n  height: 40rpx;\r\n  margin-right: 10rpx;\r\n  margin-top: 15rpx;\r\n}\r\n复制代码样式就这些，这里代码君要带着大家回顾一下以前教程里讲解的内容文字居中css样式要如何设置？只需要将属性height与line-height设置成一样高度即可display属性none:此元素不会被显示block：两个元素自动换行inline：两个元素靠在一起inherit：继承父类flex：多栏多列三、xxx.jsPage({\r\n  data: {\r\n     text: '51淘甄貨,一个可以省钱的购物平台',\r\n    marqueePace: 1,//滚动速度\r\n    marqueeDistance: 0,//初始滚动距离\r\n    size: 14,\r\n    orientation: 'left',//滚动方向\r\n    interval: 20, // 时间间隔\r\n    adUrl: '../../images/ic_home_msg.png',\r\n  },\r\n  onShow: function () {\r\n    // 页面显示\r\n    var that = this;\r\n    var length = that.data.text.length * that.data.size;//文字长度\r\n    var windowWidth = wx.getSystemInfoSync().windowWidth;// 屏幕宽度\r\n    that.setData({\r\n      length: length,\r\n      windowWidth: windowWidth,\r\n    });\r\n    that.runMarquee();// 水平一行字滚动完了再按照原来的方向滚动\r\n  },\r\n runMarquee: function () {\r\n    var that = this;\r\n    var interval = setInterval(function () {\r\n      //文字一直移动到末端\r\n      if (-that.data.marqueeDistance < that.data.length) {\r\n        that.setData({\r\n          marqueeDistance: that.data.marqueeDistance - that.data.marqueePace,\r\n        });\r\n      } else {\r\n        clearInterval(interval);\r\n        that.setData({\r\n          marqueeDistance: that.data.windowWidth\r\n        });\r\n        that.runMarquee();\r\n      }\r\n    }, that.data.interval);\r\n  }\r\n})\r\n复制代码js里面需要讲解的比较多1. setInterval 计时器如何使用？setInterval(function(){\r\nconsole.log(\"interval\")\r\n},1000)\r\n复制代码这个方法是微信小程序的api，直接使用即可，和正常的定时器一样，setInterval需要传入两个参数，一个是回调的方法，另一个是每隔多久执行一次，在此项目中，我们用的是字段参数interval，值设置为202. settimeout和setinterval()这两个都是腾讯提供的API，他们有什么区别吗？settimeout隔一段时间执行函数且执行一次，场景是我们可能希望一个任务隔一段时间后再执行etinterval()函数是 每 隔一段时间便执行，就是会一直循环执行，如果想停止的话可以使用clearinterval3.跑马灯实现原理第一步：计算跑马灯文字长度第二步：每隔一段时间，移动一点距离，产生移动第三步：当移出屏幕，重置跑马灯的距离为屏幕宽度，然后就可以继续循环第一步操作了根据代码君说的这几步，读者可以去一一对照代码，方法函数runMarquee里面的代码逻辑就是执行以上三步，在此代码君就不过多解释了总结以上就是跑马灯效果的整个流程，原理也不是很难，一个计时器，轻松就可以实现，如果还想学习更多教程，关注《代码集中营》公众号获取最新教程"}
{"title": "微信小程序及各种平台对接常用可逆加密算法aes256 ", "author": "Rolan", "pub_time": "2018-10-15 00:21", "content": "不同程序之间经常会交换数据,我们经常采用的套路是:假设要传输的信息是json,我们假设其为json_data,通过http传递信息为json_data_encode=json_data&sign=md5(json_data+key)接收方通过验证sign就知道内容有没有被篡改.但是,这样json_data作为明码传送会让我们不太开心,所以今天的我们要介绍的aes256出马了,他是一强度很高的可逆加密算法!aes256加密出来的内容是二进制的,不好通过http协议传输,所以我们再配合上base64转成ascii码加密前,aes256要求字节数必须是32字节的倍数,所以使用pkcs7进行填充可以解决问题..介绍完原理,直接贴代码写了3个版本,openresty及python和php的...请查收local aes = require 'resty.aes' local base64_encode = ngx.encode_base64 local base64_decode = ngx.decode_base64 local key = \"a12e93c9edadeaa47eb1aeabe27dabef\" local iv = \"a12e93c9edadeaa4\" -- AES 128 CBC with IV and no SALT local cipher = aes.cipher(256,\"cbc\") local aes_256_cbc_with_iv = aes:new(key,nil,cipher,{iv=iv}) local function decrypt(input)     input = base64_decode(input)     input = aes_256_cbc_with_iv:decrypt(input)     -- 取最后一个字符的ascii值     --local padding = string.byte(input,-1)     --return string.sub(input,-padding)     return input end local function pkcs7_padding(text)     local text_length = string.len(text)     local amount_to_pad = 32 - (text_length % 32)     if amount_to_pad == 0 then         amount_to_pad = 32     end     local pad = string.char(amount_to_pad) return text .. string.rep(pad,amount_to_pad) end local function encrypt (text)     text = pkcs7_padding(text)     text = aes_256_cbc_with_iv:encrypt(text)     return base64_encode(text) end print(decrypt(encrypt('linbc')))接着是python版本的#!/usr/bin/env python# -*- coding: utf-8 -*-import base64from Crypto.Cipher import AESimport binasciiimport StringIOclass PKCS7Encoder(object):    '''    RFC 2315: PKCS#7 page 21    Some content-encryption algorithms assume the    input length is a multiple of k octets, where k > 1, and    let the application define a method for handling inputs    whose lengths are not a multiple of k octets. For such    algorithms, the method shall be to pad the input at the    trailing end with k - (l mod k) octets all having value k -    (l mod k), where l is the length of the input. In other    words, the input is padded at the trailing end with one of    the following strings:             01 -- if l mod k = k-1            02 02 -- if l mod k = k-2                        .                        .                        .          k k ... k k -- if l mod k = 0    The padding can be removed unambiguously since all input is    padded and no padding string is a suffix of another. This    padding method is well-defined if and only if k < 256;    methods for larger k are an open issue for further study.    '''    def __init__(self, k=16):        self.k = k    ## @param text The padded text for which the padding is to be removed.    # @exception ValueError Raised when the input padding is missing or corrupt.    def decode(self, text):        '''        Remove the PKCS#7 padding from a text string        '''        nl = len(text)        val = int(binascii.hexlify(text[-1]), 16)        if val > self.k:            raise ValueError('Input is not padded or padding is corrupt')        l = nl - val        return text[:l]    ## @param text The text to encode.    def encode(self, text):        '''        Pad an input string according to PKCS#7        '''        l = len(text)        output = StringIO.StringIO()        val = self.k - (l % self.k)        for _ in xrange(val):            output.write('%02x' % val)        return text + binascii.unhexlify(output.getvalue())# 使用256位的AES，Python会根据传入的Key长度自动选择，长度为16时使用128位的AESkey = 'a12e93c9edadeaa47eb1aeabe27dabef'mode = AES.MODE_CBC#iv = '1234567812345678'  # AES的CBC模式使用IViv = 'a12e93c9edadeaa4'  # AES的CBC模式使用IVencoder = PKCS7Encoder()text = \"This is for test.\"def encrypt(data):    encryptor = AES.new(key, AES.MODE_CBC, iv)    padded_text = encoder.encode(data)    encrypted_data = encryptor.encrypt(padded_text)    return base64.b64encode(encrypted_data)def decrypt(data):    cipher = base64.b64decode(data)    decryptor = AES.new(key, AES.MODE_CBC, iv)    plain = decryptor.decrypt(cipher)    return encoder.decode(plain)#encrypted_text = encrypt(text)encrypted_text = 'MD1ZOvuyvut4VEed4rf+8YKaOHyECJK/RWLcfVsJwjAEZp8Hhi1zi7oH3PLSygjFCAxCRJqMBzm/qhreznkg34Vgbho+zwprTgl4M0c0lRkvLzWzXmSYG8pcqth1qnbNSwQeS3MPuofgVXR0SGMTIzicCXDlmwQV9uvIJekgES2LMse4pVndcrftI9f6UbIiT085DhAaiV9yGsV3r4FES+LnwP9ZNi58TButNC9owyKh9RuRn7z04LfNy++7iLjzk/HurOkBkJewHSchLER+pK94qhg6Lj8mW7dl+y5j3wbXY9SodNK+S8LDRYCa1JyZ/w8rffUK8YCY+jCT3ZmV8G5vdUENTqsrB4jX87C+XQCY9WEG+VQ5MK5XlhhvMPZyn2NLZUi6gW1HjqE6i/uefzq/LFl47cL2Hmr/cLbfI5rF+d1hMAIZGNnRxjYkVVvipEwRSlkD47ZVFLiWRKPusB7Lke3mnGJ1O+5eQnREL7Q/xpRT+3JuCcOqZIZJFFrJXMj9CXsJGMXxFkfnKT3UAhOi/lRA65Vwt1BEswHuZzLLHquyEYQMc3cOW1vy1Fv4zpYkjHYmxB1g50gwVryrEW2kY58sDdxwDYua3jLwERk='clean_text = decrypt(encrypted_text)print \"encrypted_text:\", encrypted_textprint \"clean_text: \", clean_text再来个php版本的<?php//function aes256EcbPkcs7PaddingEncrypt($key, $data) {//    $padding = 16 - (strlen($data) % 16);//    $data .= str_repeat(chr($padding), $padding);//    return mcrypt_encrypt(MCRYPT_RIJNDAEL_256, hash('SHA256', $key, true), $data, MCRYPT_MODE_ECB);//}////function aes256EcbPkcs7PaddingDecrypt($key, $data) {//    $data = mcrypt_decrypt(MCRYPT_RIJNDAEL_256, hash('SHA256', $key, true), $data, MCRYPT_MODE_ECB);//    $padding = ord($data[strlen($data) - 1]); //    return substr($data, 0, -$padding); //}$txt=\"MD1ZOvuyvut4VEed4rf+8YKaOHyECJK/RWLcfVsJwjAEZp8Hhi1zi7oH3PLSygjFCAxCRJqMBzm/qhreznkg34Vgbho+zwprTgl4M0c0lRkvLzWzXmSYG8pcqth1qnbNSwQeS3MPuofgVXR0SGMTIzicCXDlmwQV9uvIJekgES2LMse4pVndcrftI9f6UbIiT085DhAaiV9yGsV3r4FES+LnwP9ZNi58TButNC9owyKh9RuRn7z04LfNy++7iLjzk/HurOkBkJewHSchLER+pK94qhg6Lj8mW7dl+y5j3wbXY9SodNK+S8LDRYCa1JyZ/w8rffUK8YCY+jCT3ZmV8G5vdUENTqsrB4jX87C+XQCY9WEG+VQ5MK5XlhhvMPZyn2NLZUi6gW1HjqE6i/uefzq/LFl47cL2Hmr/cLbfI5rF+d1hMAIZGNnRxjYkVVvipEwRSlkD47ZVFLiWRKPusB7Lke3mnGJ1O+5eQnREL7Q/xpRT+3JuCcOqZIZJFFrJXMj9CXsJGMXxFkfnKT3UAhOi/lRA65Vwt1BEswHuZzLLHquyEYQMc3cOW1vy1Fv4zpYkjHYmxB1g50gwVryrEW2kY58sDdxwDYua3jLwERk=\";$txt=base64_decode($txt);$key=\"a12e93c9edadeaa47eb1aeabe27dabef\";$iv ='a12e93c9edadeaa4';$module = mcrypt_module_open(MCRYPT_RIJNDAEL_128, '', MCRYPT_MODE_CBC, '');mcrypt_generic_init($module, $key, $iv);$data = mdecrypt_generic($module, $txt);mcrypt_generic_deinit($module);mcrypt_module_close($module);$padding = ord($data[strlen($data) - 1]); $result = substr($data, 0, -$padding); echo $result;exit();?>php果然是...很省事的语言..看他多简短啊."}
{"title": "小程序国际化实现机制 ", "author": "Rolan", "pub_time": "2018-10-15 00:34", "content": "需求可手动设置使用语言根据不同的语言显示不同的语言文字（目前是支持中英文，如需其他语言，可直接配置即可） 如果没有配置相应语言的信息，则使用默认的数据 国际化分为文字和图片（有的图片上有文字信息）两类 限制因素小程序2m的限制所以图片网络化\" style=\"margin: 20px 0px; font-family: \"PingFang SC\", \"Hiragino Sans GB\", \"Helvetica Neue\", \"Microsoft Yahei\", \"WenQuanYi Micro Hei\", sans-serif; font-weight: 500; line-height: 40px; color: rgb(44, 62, 80); text-rendering: optimizeLegibility; font-size: 21px; background-color: rgb(249, 249, 245);\">因小程序2M的限制，所以图片网络化地图上的图片（如markers、controls、polyline等），不能使用网络图片，只能使用本地图片；所以图片的话分为本地图片和网络图片两种实现机制目录结构信息res │ resUtils.js │ ├─values │ img.js │ strings.js│ ├─values_en │ img.js │ strings.js │└─values_zh_CN strings.js values中是默认的是数据配置，values_en是英文坏境下的配置，values_zh_CN中文简体环境下的配置 后面如果需要配置其他的语言（如zh_TW，中文繁体，台湾地区），只需要新建文件名 values_zh_TW即可 resUtils.js是国际化的核心代码位置，这个文件会根据不同的语言来引用引用对应的文件； 首次如果没有设置过语言，或跟从当前手机的语言环境，后面如果设置过语言的话，跟从设置的语言来（暂定，具体的需求还未出） 具体配置文字国际化，直接在对应的环境下strings.js中添加要用的文字信息，文件会自动导出module.exports = {  LOGIN_STATUS_INVALID: '登录失效',  LOGIN_LOG_AGAIN: '请重新登录',}module.exports = {  LOGIN_STATUS_INVALID: 'Login status invalid',  LOGIN_LOG_AGAIN: 'Log in again',}图片国际化（分为本地和网络图片两种）； 网络图片直接调用getImg('drawableName.png')，即可； 本地图片，使用绝对路径即可/** * 默认环境图片配置 * @author Shirley.jiang  */const ICON_URL = 'https://***';let env = 'zh_CN';let getImg = (name) => {  return ICON_URL + '/' + env + '/' + name;}module.exports = {  IC_BTN_PHONE: getImg('btn_phone.png'), // 网络图片  ICON_LOCATION: '/imgs/icon_location.png', // 本地图片}/** * en环境图片配置 * @author Shirley.jiang  */const ICON_URL = 'https://***';let env = 'en';let getImg = (name) => {  return ICON_URL + '/' + env + '/' + name;}module.exports = {  IC_CHANGE_LANGUAGE: getImg('ic_change_language.png')};使用方式const resUtils = require('../../res/resUtils.js'); // 引入resUtils.strings.LOGIN_STATUS_INVALID; // 文字调用resUtils.imgs.IC_CHANGE_LANGUAGE； // 图片调用注意事项因wxml 文件不能应用js文件，所以数据全部通过data进行中转 data的加载比生命周期要早，导致切换语言的时候，data数据没有更新；所以在Page和Component中的ready方法之后，手动setData一次（因未找到更好的解决方案，暂定这种方式） 附带[resUtils.js]代码const localStorage = require('../utils/LocalStorage.js');/*** 国际化* @author Shirley.jiang*/class ResUtils {  static mInstance;  mStrings = {};  mImgs = {};  mEnv;  static getInstance() {    if (!ResUtils.mInstance) {      ResUtils.mInstance = new ResUtils();    }    return ResUtils.mInstance;  }  init(env) {      this.mEnv = env;      this.initStrings();          this.initImgs();  }   /**   * 引用字符配置   */  initStrings() {       this.mStrings = {};       let strings;       let defaultStrings;       try {      strings = require('./values_' + this.mEnv + '/strings.js');   } catch (err) { }       try {      defaultStrings = require('./values/strings.js');   } catch (err) { }       // 初始化默认的数据   for (let key in defaultStrings) {             if (!defaultStrings.hasOwnProperty(key)) {                   continue;       }             this.mStrings[key] = defaultStrings[key];   }       // 如果当前语言文件中定义的有，则直接覆盖   for (let key in strings) {             if (!this.mStrings.hasOwnProperty(key)) {                   continue;       }             this.mStrings[key] = strings[key];    }  }     /**   * 引用图片配置   */  initImgs() {       this.mImgs = {};       let imgs;       let defaultImgs;       try {      imgs = require('./values_' + this.mEnv + '/img.js');    } catch (err) { }       try {      defaultImgs = require('./values/img.js');    } catch (err) { }       // 初始化默认的数据   for (let key in defaultImgs) {             if (!defaultImgs.hasOwnProperty(key)) {                   continue;       }             this.mImgs[key] = defaultImgs[key];    }        // 如果当前语言文件中定义的有，则直接覆盖    for (let key in imgs) {              if (!this.mImgs.hasOwnProperty(key)) {                    continue;        }              this.mImgs[key] = imgs[key];    }  }     /**   * 切换语言   * @param {string} env 语言值   */  changeLanguage(env) {    localStorage.setEnv(env);        this.init(env);  }}/*** zh_CN 中文* zh_TW 中文繁体(台湾)* en 英文环境*/let env = localStorage.getEnv();ResUtils.getInstance().init(env);module.exports = ResUtils.getInstance();感谢《小程序开发一群》的Shirley.jiang投稿。"}
{"title": "小程序产品设计中的坑 ", "author": "Rolan", "pub_time": "2018-10-16 00:01", "content": "本文系统地罗列了微信小程序在产品设计上的出现的问题，并提出了相应的建议。资质不是所有功能都可以做，根据不同主体，会有不同的开放类目。主体分为「非个人主体」「个人主体」「海外主体」。有些类目需要有资质，比如社交类（包括社区、笔记等），都要 ICP 证。如果做了功能提交审核，发现的话会被拒绝，要求添加相关分类。官方文档： 小程序开放的服务类目对策：做服务端开关，审核时把功能隐藏（暂时貌似没有程序静态检查，只有人工审核），审核后再打开，但要承担被下架的风险。虚拟支付18年5月，由于苹果公司要求，iOS的小程序虚拟商品支付被禁止，即内容付费、工具服务类等，不包括外卖、电商这些；如果被发现，会屏蔽支付接口。对策：加入实体商品的性质，比如购买课程变成购买课程+书，加入收货地址等信息。模版消息推送可以给用户推送模版消息，会在「服务通知」里提醒，对留存比较有帮助（唤起用户）。有次数和时间限制，两种方式可以获得下发次数：支付：每次支付有 3 条下发次数，可以在 7 天内推送。提交表单：每次提交有 1 条下发次数，可以在 7 天内推送。官方文档： 模版消息大部分小程序都没有支付，主要靠提交表单，即需要用 <form/> 组件，让用户手动触发确认。常见做法会把 <form/> 伪装成一个列表项、某个按钮等，用户在使用过程中就获得了下发次数，但有违规风险。Tab bar 的 action button有的产品想要在 tab bar 加上 action button，比如：发布内容、新建文章等。但小程序原生 tab bar 目前不支持跳转新页面，只支持在当前打开页面。而如果自己实现 tab bar，性能会很差（切换 tab 时卡顿、页面闪烁）。有种做法，依然用原生 tab bar，但把 icon 素材做成 action button 的样式，然后在当前打开页面，列出一些选项让用户选择，再进入子页面。比如可以参考「美篇」的开始创作，先让用户选择文字、图片、视频，然后再进入文章编辑的子页面。自定义导航栏例如「知乎热榜」小程序，搜索框在导航栏。怎么做到的？其实是微信版本 6.6.0 后支持的特性，navigationStyle 可以设置为 custom，设置后顶栏就消失了，页面会自动顶到最顶部。所以「知乎热榜」那个搜索栏不是属于顶栏，而是属于页面内容，这下就好理解了。 ​​​​官方文档： 全局配置 – windowWebview小程序中可以使用 webview 组件，直接把 mobile web 套到小程序里，比如「多抓鱼」就是以 webview 为主的。好处：节省工作量，已有的 mobile web 不用重复开发。不需要等审核，随时部署更新。直接兼容一些小程序不支持的原生标签，比如 <pre/>。坏处：一个页面里只能有一个 <webview/> 组件，不能有其它。比如想用原生的 <button/> 来调起支付、分享，就不可以。只有绑定为业务域名的 url 才能跳转，不可以随便打开什么网页，上限 20 个。其它杂七杂八绑定的服务器域名，需要国内 ICP 备案，所以想做个 dribbble 客户端，直接利用 dribbble API 是不行的，只能想办法用自己服务器做数据转发。小程序之间可以互相跳转，但必须绑定在同一公众号下，而且具体跳转的是哪个小程序、哪个页面，要手动配置小程序 AppID 和路径。不能长按别二维码，也没办法下载 app。如果需要绑定手机号，可以使用小程序的 获取手机号 接口，调的是微信绑定了的手机号，很方便。作者：刘英滕链接：https://www.jianshu.com/p/f36e0aceed98本文由 @刘英滕 授权发布于人人都是产品经理，未经作者许可，禁止转载。题图来自Unsplash，基于CC0协议"}
{"title": "mp-redux：解耦小程序中的业务与视图，让测试更容易 ", "author": "Rolan", "pub_time": "2018-10-16 00:34", "content": "项目地址：点我，欢迎star和issue\r\nmp-redux\r\n一个用于小程序和轻量级H5应用的状态管理工具， 使用方法是一个简化版本的Redux。之所以是适用于轻量级应用，主要是因为没有实现组件间的数据共享。因此不适合于复杂，庞大的前端应用。\r\n是否你需要使用它？\r\n如果你也和我有同样的困惑，那么你就该尝试一下：\r\n\r\n代码耦合严重，业务代码重复，往往改一处就会引起诸多功能也要跟着修改\r\n业务逻辑都写在视图逻辑层，但是有苦于没有办法将业务代码剥离\r\n代码越来越臃肿不堪\r\n对老代码不敢碰，会影响很多业务逻辑\r\n\r\n为什么借鉴redux\r\n\r\n用为redux是框架无关的，所以具有更好的可移植性，当然我这里在内部还是做了一些\"猥琐\"处理来兼容多平台\r\n单一数据源，让状态更容易被跟踪\r\n将业务逻辑与视图层分离，让代码更清晰，耦合更低\r\n状态都应该放在页面的根容器去管理，分发到各个子组件。以便更好的控制业务逻辑\r\n业务逻辑都放入model中，而model都是纯函数，让测试更加容易\r\n\r\n如何使用？\r\n拷贝 /mp-redux/index.js文件到项目中引入即可。开包即用。\r\n为什么没有使用npm?\r\n懒\r\napi使用方法\r\n\r\n在系统入口我们必须初始化store\r\n\r\n  const mpState = require('./mp-redux/index.js');\r\n  const userInfo = require('./model/userinfo.js');\r\n  const logs = require('./model/logs.js');\r\n\r\n  mpState.createStore({\r\n    logs, // 这些model 就是redux的reduce，必须是纯函数，并且需要返回一个纯对象\r\n    userInfo // 这些model 就是redux的reduce，必须是纯函数，并且需要返回一个纯对象\r\n  }, 'onShow') // 第二个参数是劫持的生命周期函数，这是为了解决不同平台的差异性问题导致的。后期会考虑优化\r\n复制代码\r\n创建model\r\n\r\n  // model 就是数据模型，是根据业务而来的\r\n  // model/userinfo.js\r\n  const actions = require('./../action/logs.js'); // 这里同样采用了redux的action机制\r\n\r\n  const initState = {\r\n    logs: []\r\n  }\r\n\r\n  module.exports = function (state = initState, action = {}) {\r\n    const newState = { ...state };\r\n    switch (action.type) {\r\n      case actions.addLogs:\r\n        const now = new Date();\r\n        newState.logs.push({\r\n          time: now.getHours() + \":\" + now.getMinutes() + \":\" + now.getSeconds(),\r\n          value: action.data\r\n        });\r\n        return newState;\r\n      case actions.clearLogs:\r\n        newState.logs = [];\r\n        return newState;\r\n      default:\r\n        return newState;\r\n    }\r\n  }\r\n  // action/userinfo.js\r\n  module.exports = {\r\n    addLogs: 'LOGS_ADD',\r\n    clearLogs: 'LOGS_CLEAR'\r\n  }\r\n复制代码\r\n在Page中使用\r\n\r\n  // 使用connect来注入需要订阅的状态，并且mp-redux会在页面对象中自动注入dispatch方法 \r\n  const mpState = require('./../../mp-redux/index.js');\r\n  const util = require('../../utils/util.js');\r\n  const logActions = require('./../../action/logs.js');\r\n\r\n  Page(mpState.connect((state) => {\r\n    return {\r\n      userInfo: state.userInfo.userInfo,\r\n      logs: state.logs.logs\r\n    }\r\n  },\r\n  { // 在这里所有的业务数据都保存在store中，所以页面如果只有业务数据的话，是不需要data属性的。\r\n    clearLogs() {\r\n      this.dispatch({ // 通过dispatch方法来发出action，从而更新store中的数据\r\n        type: logActions.clearLogs\r\n      })\r\n    }\r\n  }))\r\n复制代码\r\n更容易被测试的业务代码\r\n从上面我们将业务数据声明到model中，而所有的业务数据更新以及业务数据更新的逻辑都在model中完成(参考/model/logs.js)。而model都是纯函数，因此业务代码更加容易被测试。\r\n\r\n  // 不要吐槽，，，，，，我第一次写测试用例。(-_-)\r\n  const actions = require('./../action/logs.js');\r\n  const model = require('./../model/logs.js');\r\n\r\n  test('1. init logs data', () => {\r\n    expect(model()).toEqual({\r\n      logs: []\r\n    })\r\n  })\r\n\r\n  test('2. add new log into empty logs', () => {\r\n    const newState = model(undefined, {\r\n      type: actions.addLogs,\r\n      data: \"Test new log\"\r\n    });\r\n\r\n    expect({\r\n      value: newState.logs[0].value,\r\n      len: newState.logs.length\r\n    }).toEqual({\r\n      value: \"Test new log\",\r\n      len: 1\r\n    });\r\n  })\r\n\r\n  test('3. add new log into logs', () => {\r\n    const newState = model({logs: [{time: '00:00:00', value: 'the first log'}]}, {\r\n      type: actions.addLogs,\r\n      data: \"the second log\"\r\n    });\r\n\r\n    expect({\r\n      log1: newState.logs[0].value,\r\n      log2: newState.logs[1].value,\r\n      len: newState.logs.length\r\n    }).toEqual({\r\n      log1: \"the first log\",\r\n      log2: \"the second log\",\r\n      len: 2\r\n    });\r\n  })\r\n\r\n  test('4. clear all logs', () => {\r\n    const newState = model({ logs: [\r\n      { time: '00:00:00', value: 'log1' }, \r\n      { time: '00:00:00', value: 'log2' }\r\n      ] }, {\r\n        type: actions.clearLogs\r\n      });\r\n\r\n    expect({\r\n      len: newState.logs.length\r\n    }).toEqual({\r\n      len: 0\r\n    });\r\n  })\r\n复制代码因为互联网产品都是toC业务，UI基本上每天都在变化，但是业务的变化其实是很小的。我们通过将业务建模，在前端构建业务数据模型。而这些模型是可以预知的。因此也就可测试。\r\n而对于一些互联网产品，前端测试是一件非常繁琐而复杂的事情。因此这个简单的方案大大的降低了前端代码变动引起的风险，而增加的工作量也并不是很大。可以一定程度上降低业务代码的回归测试成本。作者：YaHuiLiang(Ryou)链接：https://juejin.im/post/5bbb315d6fb9a05cf039ffed来源：掘金"}
{"title": "在小程序开发中使用 npm ", "author": "Rolan", "pub_time": "2018-10-17 00:11", "content": "微信小程序在 2.2.1 版本后增加了对 npm 包加载的支持，使得小程序支持使用 npm 安装第三方包。1. 在小程序中加载 npm 包npm install miniprogram-datepicker --production\r\nnode_modules可以 在小程序根目录下，也可以存在于小程序根目录下的各个子目录中。但是不可以 在小程序根目录外。使用--production选项，可以减少安装一些业务无关的 npm 包，从而减少整个小程序包的大小。2. 构建 npm 包在微信小程序开发工具的「工具」菜单下点击「构建 npm」命令，进行 npm 包的构建，此构建可以将 npm 包构建成在小程序中可加载使用的包。node_modules 目录不会参与编译、上传和打包中，所以小程序想要使用 npm 包必须走一遍“构建 npm”的过程，在最外层的 node_modules 的同级目录下会生成一个 miniprogram_npm 目录，里面会存放构建打包后的 npm 包，也就是小程序真正使用的 npm 包。构建打包分为两种：小程序 npm 包会直接拷贝构建文件生成目录下的所有文件到 miniprogram_npm 中；其他 npm 包则会从入口 js 文件开始走一遍依赖分析和打包过程（类似 webpack）。寻找 npm 包的过程和 npm 的实现类似，从依赖 npm 包的文件所在目录开始逐层往外找，直到找到可用的 npm 包或是小程序根目录为止。构建完成后还需要确认项目已勾选了「使用 npm 模块」。3.使用npm包js 中引入 npm 包：const package = require('packageName')\r\n使用 npm 包中的自定义组件：{\r\n    \"usingComponents\": {\r\n      \"datepicker\": \"miniprogram-datepicker\"\r\n    }\r\n}\r\nminiprogram-datepicker组件运行效果其他微信小程序npm支持文档：https://developers.weixin.qq...."}
{"title": "9块钱部署一个小程序 ", "author": "Rolan", "pub_time": "2018-10-17 00:11", "content": "小程序制作和部署从本质上是和其他的网站是一样的，需要域名、服务器空间和数据库。域名就是你们家的地址，服务器空间就是你们家房子，数据库就是你们家的保险柜。但是小程序和网站又有不同，小程序的前端部分是需要通过微信开发工具上传到微信的服务器上，就是说你们家的装潢都在微信的服务器上。当然你也可以把小程序的全部代码上传到自己的服务器上去。小程序的制作流程第一步：注册小程序https://mp.weixin.qq.com/按步骤注册小程序，获取appId和appSecret。第二步：微信开发工具你可以下微信的demo，了解小程序的前端和后端的开发结构。小程序前端包括的js,json,wxml,wxss.对应到网页就是js,html,css。微信开发里面有很多坑，先说个简单的微信授权吧，其他的以后说。第三步：微信的后台处理购买主机建站会获得一个可用的无备案的域名。但是里面的空间不能用ci框架，ci框架需要配置nginx来做路由设置。9块钱购买的空间里面不支持设置nginx。而且这个空间会隔几个小时让你输入密码，如果你是开发做实验，这个空间是足够的。如果你是自己开发，你可能要买一些好的服务器空间。可以自己操作里面的nginx。第四步：微信的提交体验和开发版点击微信开发者工具的上传按钮可以把你的版本上传到线上作为体验版本。然后可以提交审核变成线上版本。总结：开发部署练习9块钱就行！"}
{"title": "尝试解决微信小程序分页最后setData数据太大限制的问题 ", "author": "Rolan", "pub_time": "2018-10-17 00:43", "content": "前些天，突然接到用户的大量反馈，我们的小程序频繁出现闪退，崩溃的现象。如图，于是马上着手追查问题，首先确定了导致闪退的页面。是在一个有长列表的页面，当上拉加载更多，翻页翻多几页的时候就导致闪退了。经过重重排查（时间问题，这里就不详细描述排查的方法了，大多数用的都是缩小范围排除法啦），最后终于确定了问题所在，原来是在列表中，同事最近新加上的css3动画所致，这里的列表是循环渲染的一个组件，组件中的一个弹窗的弹出和收起，使用动画，但是这里没有加上wx:if,导致了循环渲染该动画，所以翻页翻着翻着就挂掉了。 确定了问题，就很好办了，加上条件判断，只有需要的时候，才渲染弹出弹窗。真机调试，暴力狂刷数据，发现闪退的现象不再出现了，闪退问题解决，然而高兴不到三分钟，又出问题了，发现翻页到十几页的时候，再也刷不动后面的数据了，明明是还有更多数据的。再在开发工具上看查看数据，结果控制台报了这么一个错在真机上为：这是什么问题呢，查看官方文档，发现是有这样的限制的回顾我们的代码，这里的分页加载数据，上拉加载，数据是放在一个for循环里去加载，数据源是一个数组对象。在加载下一页数据时，将下一页的数据拼到当前数组后面。这里是常规的做法。可以看看代码：这里可以看到，每次获取新的一页，都要重新setData新的数组，仔细想想，当这个数组到后面越来越大的时候，很容易就超出了单次设置数据超过1024kb的限制了。那么怎么解决这个问题呢，这里官方文档里面其实有提到一个注意点，既然这里是支持改变数组的某一项，那么分页的问题，可以改变为一个二维数组，还是直接看代码吧。这里的方法则暂时摆脱了单次设置数据多大的问题。当然，要是单页的数据过多，还是会出现问题的。最合适的还是对数据结构进行精简，前端不必要的数据，可以不传过来前端。写在最后，这次第一次写类似的分享，描述还是有些不清晰，以后可以多尝试这样的总结吧。"}
{"title": "利用云开发优化博客小程序（三）——生成海报功能 ", "author": "Rolan", "pub_time": "2018-10-17 00:52", "content": "欠下的生成海报的功能终于补上了周末花了点时间把小程序版博客中的生成海报的功能给完成了，对于新手的我来说遇到的问题还是挺多的，这里简单记录下坑。首先看下效果图：思路还是比较简单，主要就是利用微信提供的画布 canvas 来动态构造海报。引导用户保存至本地相册，用于分享。主要涉及小程序画布和图片相关的API，若是不太熟悉的话可以优先参考下文档。资源准备首先需要准备构成海报的一些资源，比如文章的首图，标题，需要分享的小程序码。对于文章的首图，是从腾讯云的对象存储中获取，需要在开发设置中配置好 downloadFile合法域名 ,至于为什么转战腾讯云对象存储可以参考 免费的对象存储——七牛云还是腾讯云获取图片可直接通过 wx.getImageInfo ,对应的API还是比较简单的：wx.getImageInfo({\r\n  src: url,\r\n  success (res) {\r\n    console.log(res.path)\r\n  }\r\n})至于小程序码，目前使用的是小程序本身的，暂时没有动态生成，后期会迭代。直接将小程序码上传至云存储上,获取时也比较简单：wx.cloud.downloadFile({\r\n  fileID: fileID\r\n}).then(res => {\r\n  console.log(res.tempFilePath)\r\n})最后，其他需要在海报上展现的内容，根据实际情况进行获取。生成海报资源准备完之后，就需要利用画布进行构造海报了。在wxml添加canvas元素，需要注意的是避免在页面上展示，可以将位置设置在屏幕之外，比如 top:99999rpx\r\n<view class=\"canvas-box\">\r\n  <canvas style=\"width: 600px;height: 970px;\" canvas-id=\"mycanvas\" />\r\nview>然后需要了解下canvas相关API和属性了。优先创建canvas的绘图上下文 CanvasContext 对象,然后通过CanvasContext中的属性进行绘制，最后通过 draw() 将之前在绘图上下文中的描述（路径、变形、样式）画到 canvas 中。具体可以参考下面的代码，结合注释和官方文档很容易理解：var context = wx.createCanvasContext('mycanvas');\r\n    context.setFillStyle('#ffffff');//设置填充色\r\n    context.fillRect(0, 0, 600, 970);//填充一个矩形。用 setFillStyle 设置矩形的填充色\r\n    context.drawImage(postImageLocal, 0, 0, 600, 300); //绘制首图\r\n    context.drawImage(qrcodeLoal, 210, 650, 180, 180); //绘制二维码\r\n    context.setFillStyle(\"#000000\");\r\n    context.setFontSize(20);//设置字体大小\r\n    context.setTextAlign('center');//设置字体对齐\r\n    context.fillText(\"阅读文章,请长按识别二维码\", 300, 895);\r\n    context.setFillStyle(\"#000000\");\r\n    context.beginPath() //分割线\r\n    context.moveTo(30, 620)\r\n    context.lineTo(570, 620)\r\n    context.stroke();\r\n    context.setTextAlign('left');\r\n    context.setFontSize(40);\r\n\r\n    if (title.lengh <= 12) {\r\n      context.fillText(title, 40, 360);//文章标题\r\n    } else {\r\n      context.fillText(title.substring(0, 12), 40, 360);\r\n      context.fillText(title.substring(12, 26), 40, 410);\r\n    }\r\n\r\n    context.setFontSize(20);\r\n    if (custom_excerpt.lengh <= 26) {\r\n      context.fillText(custom_excerpt, 40, 470);//文章描述\r\n    } else {\r\n      context.fillText(custom_excerpt.substring(0, 26), 40, 470);\r\n      context.fillText(custom_excerpt.substring(26, 50) + '...', 40, 510);\r\n    }\r\n\r\n    context.draw();这里需要注意的是填写文字时，画布是不会自动换行的，所以这里需要根据字体大小和字体多少来自行控制换行。在填充完canvas之后，通过 wx.canvasToTempFilePath 来生成图片，并保存在临时路径下，具体代码如下：wx.canvasToTempFilePath({\r\n  canvasId: 'mycanvas',\r\n  success: function(res) {\r\n    var tempFilePath = res.tempFilePath;\r\n    wx.hideLoading();\r\n    console.log(\"海报图片路径：\" + res.tempFilePath);\r\n    that.setData({\r\n      showPosterPopup: true,//展示弹窗\r\n      showPosterImage: res.tempFilePath //对应路径\r\n    })\r\n  },\r\n  fail: function(res) {\r\n    console.log(res);\r\n  }\r\n});到这里，最简单的海报生成完成了，接下来就是涉及交互了。交互样式首先利用zanui的 zan-popup 来实现弹出层，还是比较方便的。具体样式就不贴了，可以直接看我的源码。弹出层中加载生成好的海报图片，通过按钮引导用户保存至本地相册，在保存相册时，需要用户授权本地相册的权限，这里需要做好交互，当用户拒绝之后再次想保存时，让他重新授权。当用户取消时，再次提醒：具体代码如下，供参考：/**\r\n * 保存海报图片\r\n */\r\nsavePosterImage: function() {\r\n  let that = this\r\n  wx.saveImageToPhotosAlbum({\r\n    filePath: that.data.showPosterImage,\r\n    success(result) {\r\n      console.log(result)\r\n      wx.showModal({\r\n        title: '提示',\r\n        content: '二维码海报已存入手机相册，赶快分享到朋友圈吧',\r\n        showCancel: false,\r\n        success: function(res) {\r\n          that.setData({\r\n            showPosterPopup: false\r\n          })\r\n        }\r\n      })\r\n    },\r\n    fail: function(err) {\r\n      console.log(err);\r\n      if (err.errMsg === \"saveImageToPhotosAlbum:fail auth deny\") {\r\n        console.log(\"再次发起授权\");\r\n        wx.showModal({\r\n          title: '用户未授权',\r\n          content: '如需保存海报图片到相册，需获取授权.是否在授权管理中选中“保存到相册”?',\r\n          showCancel: true,\r\n          success: function(res) {\r\n            if (res.confirm) {\r\n              console.log('用户点击确定')\r\n              wx.openSetting({\r\n                success: function success(res) {\r\n                  console.log('打开设置', res.authSetting);\r\n                  wx.openSetting({\r\n                    success(settingdata) {\r\n                      console.log(settingdata)\r\n                      if (settingdata.authSetting['scope.writePhotosAlbum']) {\r\n                        console.log('获取保存到相册权限成功');\r\n                      } else {\r\n                        console.log('获取保存到相册权限失败');\r\n                      }\r\n                    }\r\n                  })\r\n\r\n                }\r\n              });\r\n            }\r\n          }\r\n        })\r\n      }\r\n    }\r\n  });\r\n}到这里，小程序的生成海报功能基本上就完成了。总结其实生成海报的功能还有很多小问题，由于最近项目比较紧匆匆上了，后面找时间会优化。通过生成海报的功能，主要还是学习了画布的API，并通过实战也基本可以上手canvas，至于画布上排版，样式就需要自己耐心了，尤其是一些小地方。程序上线后我才发现，海报上的标题，由于有中英文，所占的字符不同，所以换行的处理过于草率了，导致有英文的标题在位置上存在偏差。后期有空的话再持续改善吧～"}
{"title": "各种小程序的组件机制差异 ", "author": "Rolan", "pub_time": "2018-10-18 00:12", "content": "在蚂蚁金服的开放平台上看到一些贴子，说提供一个工具，一键转换微信小程序为支付宝小程序。我与百度的人交流时，也听到相似的东西。其实都没有这么简单，它们最多是将一些循环条件分支指令改一下名，将一些文件的后缀名改一下，更多的差异点在API与各式的配置对象上，细节是魔鬼，我在娜娜奇的官网也列举了许多相关的东西，但也不能打票说已经很齐全。。。。各种小程序的差异点-文档补充一句，娜娜奇是我们公司的小程序开发框架，以React方式转译成各种小程序与快应用的框架。类似于京东的taro。最近忙于支付宝小程序的开发，我得到许多有关小程序的一手资料，包括自己测试得到的，及从百度，小米快应用与支付宝内部人士提供的。本文将重点说一下小程序的组件机制，之前娜娜奇的组件机制是基于template标签实现的，但百度的template有点BUG，给他们提了，不知现在修了没有。与template机制在快应用又出入太大，于是转向用自定义组件机制开发娜娜奇的组件机制。下面链接有一些相关的测试与说明转换小程序 · Issue #133 · RubyLouvre/anu经测试，使用了自定义组件机制的确是比template实现的简洁一些。但自定义组件机制是一个比较高级的特性，因此兼容性上比template差多了。只能内部推到各方改进了。微信在Component的配置对象提供了一些对象如methods， lifetimes，pageLifetimes，来减少其直辖的配置项。比如说lifetimes收纳了created、attached、ready、moved、detached这些生命周期钩子，pageLifetimes收纳了onShow, onHide这些与页面切换的钩子，methods收纳剩下的方法，另外还有许多配置项。的确，微信小程序独自发布这么久，肯定是最完善的支付宝的自定义组件机制没有properties，只有props，并且作用也不一样，props只是指定默认值，不是规定参数类型。支付宝也没有lifetimes与pageLifetimes对象，生命周期函数的名字也不一样 didMount 、didUpdate 、didUnmount，数量也少了，但从名称来看，支付宝在内部应该运行一个自己的迷你React。其他方面，支付宝没有 dataset， selectComponent，selectAllComponents，getRelationNodes这些东西，但支持了早被React废弃的mixin机制。支付宝没有created这样的钩子是相当麻烦的事，因此积级推动他们加上这个钩子！百度的自定义组件机制与微信的较为相近，但也没有lifetimes与pageLifetimes对象，只有4种生命周期钩子：created，attached，ready，detached。有selectComponent，selectAllComponents。快应用的页面与组件的配置对象都是一样，但它没有构造函数，只是要求我们export一个对象有props对象，用来定义类型与默认值，也有与state相似的data对象，也有三个做了访问限制的private, protected, public对象。生命周期钩子上有onInit、onReady、onDestroy这三个。从组件的设计来看， 微信 > 百度 > 支付宝 > 快应用因此想兼容这么多种小程序，我们必须自己写一个工厂方法，根据不同的平台生成不同的配置项，并且放弃掉一些微信的强大功能了。var hooksName = {\r\n\twx: ['created', 'attached', 'detached'],\r\n\tbu: ['created', 'attached', 'detached'],\r\n\tali: ['didMount', 'didMount', 'didUnmount'],\r\n\tquick: ['onInit', 'onReady', 'onDestroy'],\r\n};\r\n\r\nexport function registerComponent(type, name) {\r\n\tregisterComponents[name] = type;\r\n\tvar reactInstances = (type.reactInstances = []);\r\n\tvar wxInstances = (type.wxInstances = []);\r\n\tvar hooks = [\r\n\t\tfunction created() {\r\n\t\t\tvar instance = reactInstances.shift();\r\n\t\t\tif (instance) {\r\n\t\t\t\tconsole.log('created时为', name, '添加wx');\r\n\t\t\t\tinstance.wx = this;\r\n\t\t\t\tthis.reactInstance = instance;\r\n\t\t\t} else {\r\n\t\t\t\tconsole.log('created时为', name, '没有对应react实例');\r\n\t\t\t\twxInstances.push(this);\r\n\t\t\t}\r\n\t\t},\r\n\t\tfunction attached() {\r\n                        if(appType == \"ali\"){\r\n                            created.call(this)\r\n                        }\r\n\t\t\tif (this.reactInstance) {\r\n\t\t\t\tupdateMiniApp(this.reactInstance);\r\n\t\t\t\tconsole.log('attached时更新', name);\r\n\t\t\t} else {\r\n\t\t\t\tconsole.log('attached时无法更新', name);\r\n\t\t\t}\r\n\t\t},\r\n\t\tfunction detached() {\r\n\t\t\tthis.reactInstance = null;\r\n\t\t},\r\n\t];\r\n\tvar data = {\r\n\t\tprops: {},\r\n\t\tstate: {},\r\n\t\tcontext: {},\r\n\t};\r\n\tvar config = {\r\n\t\tdata: data,\r\n\t\tpublic: data,\r\n\t\tdispatchEvent: eventSystem.dispatchEvent,\r\n\t\tmethods: {\r\n\t\t\tdispatchEvent: eventSystem.dispatchEvent,\r\n\t\t},\r\n\t};\r\n\thooksName[appType].forEach(function(name, index) {\r\n\t\tconfig[name] = hooks[index];\r\n\t});\r\n\r\n\treturn config;\r\n}"}
{"title": "当微信小程序遇上 TensorFlow：接收 base64 编码图像数据 ", "author": "Rolan", "pub_time": "2018-10-18 00:21", "content": "这是 当微信小程序遇上TensorFlow 系列文章的第四篇文章，阅读本文，你将了解到：如何查看tensorflow SavedModel的签名如何加载tensorflow SavedModel如何修改现有的TensorFlow模型，增加输入层如果你想要了解更多关于本项目，可以参考这个系列的前三篇文章：当微信小程序遇上TensorFlow：Server端实现当微信小程序遇上TensorFlow：Server端实现补充当微信小程序遇上TensorFlow：小程序实现关于Tensorflow SavedModel格式模型的处理，可以参考前面的文章：Tensorflow SavedModel模型的保存与加载如何查看tensorflow SavedModel格式模型的信息如何合并两个TensorFlow模型问题截至到目前为止，我们实现了一个简单的微信小程序，使用开源的Simple TensorFlow Serving部署了服务端。但这种实现方案还存在一个重大问题：小程序和服务端通信传递的图像数据是(299, 299, 3)二进制数组的JSON化表示，这种二进制数据JSON化的最大缺点是数据量太大，一个简单的299 x 299的图像，这样表示大约有3 ～ 4 M。其实HTTP传输二进制数据常用的方案是对二进制数据进行base64编码，经过base64编码，虽然数据量比二进制也会大一些，但相比JSON化的表示，还是小很多。所以现在的问题是，如何让服务器端接收base64编码的图像数据？查看模型的签名为了解决这一问题，我们还是先看看模型的输入输出，看看其签名是怎样的？这里的签名，并非是为了保证模型不被修改的那种电子签名。我的理解是类似于编程语言中模块的输入输出信息，比如函数名，输入参数类型，输出参数类型等等。借助于Tensorflow提供的saved_model_cli.py工具，我们可以清楚的查看模型的签名：python ./tensorflow/python/tools/saved_model_cli.py show --dir /data/ai/workspace/aiexamples/AIDog/serving/models/inception_v3/ --all\r\n\r\nMetaGraphDef with tag-set: 'serve' contains the following SignatureDefs:\r\n\r\nsignature_def['serving_default']:\r\n  The given SavedModel SignatureDef contains the following input(s):\r\n    inputs['image'] tensor_info:\r\n        dtype: DT_FLOAT\r\n        shape: (-1, 299, 299, 3)\r\n        name: Placeholder:0\r\n  The given SavedModel SignatureDef contains the following output(s):\r\n    outputs['prediction'] tensor_info:\r\n        dtype: DT_FLOAT\r\n        shape: (-1, 120)\r\n        name: final_result:0\r\n  Method name is: tensorflow/serving/predict从中我们可以看出模型的输入参数名为image，其shape为(-1, 299, 299, 3)，这里-1代表可以批量输入，通常我们只输入一张图像，所以这个维度通常是1。输出参数名为prediction，其shape为(-1, 120)，-1和输入是对应的，120代表120组狗类别的概率。现在的问题是，我们能否在模型的输入前面增加一层，进行base64及解码处理呢？也许你认为可以在服务器端编写一段代码，进行base64字符串解码，然后再转交给Simple Tensorflow Serving进行处理，或者修改Simple TensorFlow Serving的处理逻辑，但这种修改方案增加了服务器端的工作量，使得服务器部署方案不再通用，放弃！修改模型，增加输入层其实在上一篇文章《 如何合并两个TensorFlow模型 》中我们已经讲到了如何连接两个模型，这里再稍微重复一下，首先是编写一个base64解码、png解码、图像缩放的模型： base64_str = tf.placeholder(tf.string, name='input_string')\r\n  input_str = tf.decode_base64(base64_str)\r\n  decoded_image = tf.image.decode_png(input_str, channels=input_depth)\r\n  # Convert from full range of uint8 to range [0,1] of float32.\r\n  decoded_image_as_float = tf.image.convert_image_dtype(decoded_image,\r\n                                                        tf.float32)\r\n  decoded_image_4d = tf.expand_dims(decoded_image_as_float, 0)\r\n  resize_shape = tf.stack([input_height, input_width])\r\n  resize_shape_as_int = tf.cast(resize_shape, dtype=tf.int32)\r\n  resized_image = tf.image.resize_bilinear(decoded_image_4d,\r\n                                           resize_shape_as_int)\r\n  tf.identity(resized_image, name=\"DecodePNGOutput\")接下来加载retrain模型： with tf.Graph().as_default() as g2:\r\n    with tf.Session(graph=g2) as sess:\r\n      input_graph_def = saved_model_utils.get_meta_graph_def(\r\n          FLAGS.origin_model_dir, tag_constants.SERVING).graph_def\r\n\r\n      tf.saved_model.loader.load(sess, [tag_constants.SERVING], FLAGS.origin_model_dir)\r\n\r\n      g2def = graph_util.convert_variables_to_constants(\r\n          sess,\r\n          input_graph_def,\r\n          [\"final_result\"],\r\n          variable_names_whitelist=None,\r\n          variable_names_blacklist=None)这里调用了graph_util.convert_variables_to_constants将模型中的变量转化为常量，也就是所谓的冻结图(freeze graph)操作。利用tf.import_graph_def方法，我们可以导入图到现有图中，注意第二个import_graph_def，其input是第一个graph_def的输出，通过这样的操作，就将两个计算图连接起来，最后保存起来。代码如下： with tf.Graph().as_default() as g_combined:\r\n    with tf.Session(graph=g_combined) as sess:\r\n      x = tf.placeholder(tf.string, name=\"base64_string\")\r\n      y, = tf.import_graph_def(g1def, input_map={\"input_string:0\": x}, return_elements=[\"DecodePNGOutput:0\"])\r\n      z, = tf.import_graph_def(g2def, input_map={\"Placeholder:0\": y}, return_elements=[\"final_result:0\"])\r\n\r\n      tf.identity(z, \"myOutput\")\r\n\r\n      tf.saved_model.simple_save(sess,\r\n                                 FLAGS.model_dir,\r\n                                 inputs={\"image\": x},\r\n                                 outputs={\"prediction\": z})如果你不知道retrain出来的模型的input节点是啥（注意不能使用模型部署的signature信息）？可以使用如下代码遍历graph的节点名称：for n in g2def.node:\r\n  print(n.name)模型部署及测试注意，我们可以将连接之后的模型保存在./models/inception_v3/2/目录下，原来的./models/inception_v3/1/也不用删除，这样两个版本的模型可以同时提供服务，方便从V1模型平滑过渡到V2版本模型。我们修改一下原来的test_client.py代码，增加一个model_version参数，这样就可以决定与哪个版本的模型进行通信： with open(file_name, \"rb\") as image_file:\r\n    encoded_string = str(base64.urlsafe_b64encode(image_file.read()), \"utf-8\")\r\n\r\n  if enable_ssl :\r\n    endpoint = \"https://127.0.0.1:8500\"\r\n  else:\r\n    endpoint = \"http://127.0.0.1:8500\"\r\n\r\n  json_data = {\"model_name\": model_name,\r\n               \"model_version\": model_version,\r\n               \"data\": {\"image\": encoded_string}\r\n              }\r\n  result = requests.post(endpoint, json=json_data)小结经过一个多星期的研究和反复尝试，终于解决了图像数据的base64编码通信问题。难点在于虽然模型是编写retrain脚本重新训练的，但这段代码不是那么好懂，想要在retrain时增加输入层也是尝试失败。最后从Tensorflow模型转Tensorflow Lite模型时的freezing graph得到灵感，将图中的变量固化为常量，才解决了合并模型变量加载的问题。虽然网上提供了一些恢复变量的方法，但实际用起来并不管用，可能是Tensorflow发展太快，以前的一些方法已经过时了。本文的完整代码请参阅：https://github.com/mogoweb/aiexamples/tree/master/AIDog/serving点击 阅读原文 可以直达在github上的项目。到目前为止，关键的问题已经都解决，接下来就需要继续完善微信小程序的展现，以及如何提供识别率，敬请关注我的微信公众号：云水木石，获取最新动态。参考How to Show Signatures of Tensorflow Saved ModelServing Image-Based Deep Learning Models with TensorFlow-Serving’s RESTful APITensorflow: How to replace a node in a calculation graph?"}
{"title": "微信小程序图片预加载组件 wxapp-img-loader ", "author": "Rolan", "pub_time": "2018-10-18 00:25", "content": "由于微信小程序没有提供类似 Image 这样的 JS 对象，要实现图片的预加载要麻烦一些， wxapp-img-loader自定义组件可以在微信小程序中实现图片预加载功能。使用1、下载 wxapp-img-loader项目源代码（https://github.com/o2team/wxa...），将 img-loader 目录拷贝到你的项目中2、在页面的 WXML 文件中添加以下代码，将组件模板引入<import src=\"../../img-loader/img-loader.wxml\"/>\r\n<template is=\"img-loader\" data=\"{{ imgLoadList }}\"></template>\r\n3、在页面的 JS 文件中引入组件脚本const ImgLoader = require('../../img-loader/img-loader.js')\r\n\r\n4、实例化一个 ImgLoader 对象，将 this(当前 Page 对象) 传入，第二个参数可选，为默认的图片加载完成的回调方法this.imgLoader = new ImgLoader(this)\r\n\r\n5、调用 ImgLoader 实例的 load 方法进行图片加载，第一个参数为图片链接，第二个参数可选，为该张图片加载完成时的回调方法。图片加载完成的回调方法的第一个参数为错误信息（加载成功则为 null），第二个参数为图片信息（Object 类型，包括 src、width 及 height）。this.imgLoader.load(imgUrlOriginal, (err, data) => {    console.log('图片加载完成', err, data.src, data.width, data.height)\r\n})\r\nwxapp-img-loader组件可以加载单张图片、也可以加载多张图片。运行效果：其他wxapp-img-loader项目地址：https://github.com/o2team/wxa..."}
{"title": "微信小程序通过ip获取用户所在城市 ", "author": "Rolan", "pub_time": "2018-9-26 00:37", "content": "在微信小程序中, 获取用户的地理位置是需要权限的, 如果只是获取用户所在的城市信息, 那只需查看用户ip所在的城市就好了, 下面我们就完成获取用户ip的小程序逻辑~根据用户ip获取地理位置根据用户ip获取用户地理位置, 用爬虫实现! 博主所用的api:\"http://www.ip138.com/ips138.asp?ip=\"+ ip_addr查询ip的函数import requestsfrom lxml import etree# 查询ip归属地def query_ip_attribution(ip_addr):    # 设置用户代理头    headers = {        # 设置用户代理头(为狼披上羊皮)        \"User-Agent\": \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36\",    }    target_url = \"http://www.ip138.com/ips138.asp?ip=\"+ ip_addr    response = requests.get(target_url, headers = headers).content    data_etree = etree.HTML(response)    ip_attr = data_etree.xpath('//tr[3]/td/ul/li[1]//text()')    ip_attr = ip_attr[0].strip(\"本站数据：\")    return {\"ip_attr\": ip_attr, \"ip\": ip_addr}nginx配置nginx负责将请求转发到django(django在9000端口开启了服务)proxy_set_header Host $http_host;proxy_set_header X-Real-IP $remote_addr;proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;proxy_set_header X-Forwarded-Proto $scheme;Host包含客户端真实的域名和端口号； X-Real-IP表示客户端真实的IP； X-Forwarded-For这个Header和X-Real-IP类似，但它在多层代理时会包含真实客户端及中间每个代理服务器的IP。 X-Forwarded-Proto表示客户端真实的协议（http还是https）；Django读取用户ip, 查询并返回结果from django.http import JsonResponse# 获取用户ipdef get_ip(request):    if 'HTTP_X_FORWARDED_FOR' in request.META:        ip =  request.META['HTTP_X_FORWARDED_FOR']    else:        ip = request.META['REMOTE_ADDR']    return JsonResponse(query_ip_attribution(ip))微信小程序获取返回的数据可以作为开源接口调用 (支持http, https, 无需参数) 返回ip归属接口1: http://fangyuanxiaozhan.com/get_ip 返回ip归属接口2: https://fangyuanxiaozhan.com/get_ip小结:网页云音乐, 非常注重分析自己的用户, 并对用户的歌单进行个性化定制, 收获了大量好评, 对于个人开发者, 用复杂的算法分析用户, 不太现实,但通过分析用户所在城市, 对软件定位做一些优化, 还是很容易实现的。"}
{"title": "微信小程序 授权登录 41003 ", "author": "Rolan", "pub_time": "2018-9-26 00:43", "content": "最近遇到这么个坑，偶然请求己方服务器授权登录失败，百度上一堆复制黏贴的文章并不靠谱，最终在微信论坛上看到解决方案。 网上有些是说iv内空格导致解密失败，我出错的情况下并没有出现空格，排除这种情况。 有说是因为请求顺序，但是按照微信官方文档，似乎并不是最新的，至少我授权方式不完全跟文档一样。我的授权方式 通过添加一个按钮并且设置 open-type=\"getUserInfo\"<button class='wxBtn'         open-type=\"getUserInfo\"         bindgetuserinfo=\"wechatAction\">使用微信账号登录</button>在按钮点击事件里，会返回一些授权登录需要用到的字段如：iv、encryptedData、signature、rawData 这个时候再调用 wx.login() 去获取code，整合以上数据向己方服务器发送请求获取用户唯一标识 token。 通过以上的方式是可以成功登录，但是偶然会出现请求己方服务器授权登录失败，再一次就会成功。 原因在于请求顺序，这里的请求顺序是先请求 wx.getUserInfo(按钮) 再请求 wx.login()。有时候获取code后iv已经失效，所以失败。 解决方案：在请求 wx.login() 后，调用一次 wx.getUserInfo(废弃接口) ，更新iv等信息。注意：这里调用的废弃接口只是不再弹出授权请求窗口，但还是能够获取到 iv 等信息，授权接口弹窗已将在点击按钮的时候弹出，并且授权了，所以没毛病。 再总结一下，正确的顺序：wx.getUserInfo(按钮) -> wx.login() -> wx.getUserInfo(废弃接口)，整合以上操作获取到的最近数据 code、iv、encryptedData、signature、rawData 传给己方服务器，授权登录成功。以下贴上我的业务代码  // 点击微信登录  wechatAction: function(e) {      // 用户点击授权    // 先保存获取到的微信用户信息    const { nickName, avatarUrl } = JSON.parse(e.detail.rawData)     this.setData({      nickName: nickName,      avatarUrl: avatarUrl    })    // 获取微信code    this.reqWechatCode()  },  // 微信登录：获取code  reqWechatCode: function() {    // 授权接口登录接口    let that = this     // 从微信获取code    wx.showLoading({      title: '获取code',    })    wx.login({      success: function (res) {         if (res.code) {          wx.getUserInfo({            success: function (res) {              // 保存微信登录参数              const { encryptedData, iv, signature, rawData } = res              that.setData({                encryptedData: encryptedData,                iv: iv,                signature: signature,                rawData: rawData              })               that.wxLoginReq(res.code)            }          })        } else {          wx.showToast({            title: '获取code失败,请重试',            icon: 'none'          })        }        wx.hideLoading()      }    })   },  // 根据获取到的code 向服务器发送登录请求 获取token  wxLoginReq: function (code) {    let that = this     wx.showLoading({      title: '获取token中',    })    // 拿到code 再加上 encryptedData, iv, rawData, signature 等参数，请求token    let encryptedData = that.data.encryptedData    let iv = that.data.iv    let signature = that.data.signature    let rawData = that.data.rawData    var req = require('../../util/Request.js')    // 请求成功    let success = function(res) {      // console.log(res)      wx.hideLoading()      // 缓存token      const { token, user_id } = res.data.data      let userInfo = {        token: token,        user_id: user_id,        nickName: that.data.nickName,        avatarUrl: that.data.avatarUrl      }      getApp().setUserInfo(userInfo)      // 同步用户信息       getApp().loginSuccess(function () {        wx.navigateBack({})      })    }    // 请求失败    let fail = function(res) {      wx.hideLoading()      wx.showToast({        title: '获取token失败,请重试',        icon: 'none'      })    }     // 登录请求    req.reqLogin(code, encryptedData, iv, rawData, signature, success, fail)   },"}
{"title": "小程序应用中WebView中原生组件限制问题解析 ", "author": "Rolan", "pub_time": "2018-9-26 00:46", "content": "背景在微信的文档中有一个章节说明了『 原生组件的使用限制 』有这么一段话『由于原生组件脱离在 WebView 渲染流程外，因此在使用时有以下限制：原生组件的层级是最高的，所以页面中的其他组件无论设置 z-index 为多少，都无法盖在原生组件上。 后插入的原生组件可以覆盖之前的原生组件。 原生组件还无法在 scroll-view、swiper、picker-view、movable-view 中使用。 部分CSS样式无法应用于原生组件，例如： 无法对原生组件设置 CSS 动画 无法定义原生组件为 position: fixed 不能在父级节点使用 overflow: hidden 来裁剪原生组件的显示区域 原生组件的事件监听不能使用 bind:eventname 的写法，只支持 bindeventname。原生组件也不支持 catch 和 capture 的事件绑定方式 在iOS下，原生组件暂时不支持触摸相关事件。 在工具上，原生组件是用web组件模拟的，因此很多情况并不能很好的还原真机的表现，建议开发者在使用到原生组件时尽量在真机上进行调试。』解析所谓的原生组件，即非Web组件系统扩展Native组件。因为小程序在视图渲染层面使用了WebView，而在Video，Map这类组件，使用WebView的WebCore渲染之后体验不佳的诟病一直存在，而且标准不一。小程序上因使用原生的WebView进行渲染，而不是用修改的WebView内核（至少在iOS上没有这么干），而无法对web原生标签扩展。基于用户体验，和坑爹的技术限制，小程序提出了原生组件的概念，也就是在WebView上面使用原生组件填充占位元素的方式修补这类组件用户体验问题。因为WebView和原生组件在应用层本身就不是一个渲染层级，于是出现Web上面的标签无法浮于Video之上(直播应用的恶梦)，在不修改技术思路的前提下，position: fixed， overflow: hidden这样的属性是不可能用于原生组件的样式的。不过伪同层渲染也不是说不可能，即在渲染原生组件时候根据层级镂空面积。特别在Map上使用WebView作为渲染之后体验不佳的诟病一直存在，特别是地图上marker标记过多的重度场景下，笔者所在的公司的在使用高德地图Web端提供出来的C端具备反人类的体验，地图拖拉龟速，点击响应缓慢，加载loading地图区域等待时间过长。而Video则支持的格式有限，列出部分浏览器的支持的如下：Firefox：支持 Ogg Vorbis和WAV Opera ：支持Ogg Vorbis和WAV Safari ：支持MP3，AAC格式 ，和MP4 Chrome ：支持Ogg Vorbis，MP3，WAV，AAC和MP4 Internet Explorer 9+ ：支持MP3，AAC格式 ，和MP4 IOS ：支持MP3，AAC格式 ，和MP4 Android ：支持AAC和MP3 上述，可以知道视频支持有限（限于版权）。而就我们关注的移动端iOS和Andoroid，实现一个视频播放，我们可能都会有以下几点的需求：1、全屏处理； 2、覆盖层效果； 3、自动播放； 4、播放控制； 5、隐藏播放控件；在iOS上如果使用WebView，你无法修改全屏下的工具这一点体验已经足够让所有的产品经理抓狂，更不用说Android的这么多的机型。覆盖层效果在微信上不得不使用微信提供原生组件cover-view实现，而限于原生实现限制，cover-view的支持有限。设计方案1、组件层于WebView层之上 这也应该是微信小程序团队现阶段使用的方案，通过特殊的占位标签，使用getBoundingClientRect获取组件位置，而原生组件跟随Webview滚动。 Talking is cheap. Show me your code，那么用代码实现的效果的如下。now_lowest_gif.gif从图中可见，覆盖层确实位于原生组件之下。2、组件层于WebView层之下 此方式略微复杂。需要通过与Webview scroll联动的置于Webview之下的Component Layer实现，而Webview背景设置为透明。至于事件，通过Webview的事件透传，传递到Component Layer，需要通过缓存webview中元素再计算是否被点中通过重写hitTest方法实现。通过此技术方案实现的好处也是明显的，因为原生组件层很多时候都是置于最底层，而Web上的组件可以轻松覆盖于Native之上，无需使用cover-view之类的hack方法。 效果如下所示图片发自简书App Tips 在iOS上还特别需要注意一点UIWebview的坑。在使用-webkit-overflow-scrolling 使用，你会发现momentum scroll阶段并不会触发scroll事件，而且 scrollTop 属性不会变化，当然getBoundingClientRect也同样失效。如果考虑使用touchmove 这样事件你也仅仅在手指还在屏幕上的时候触发，检测滚动区域内部元素的getBoundingClientRect 同样无效。当然幸运的是，这么大一个坑只是发生在UIWebview，对WKWebview并没有影响。"}
{"title": "优化小程序自身的Storage ", "author": "Rolan", "pub_time": "2018-9-27 00:16", "content": "1、小程序中的存储只有 Storage ，特性如下：上限为 10MB 以用户纬度隔离，同一个设备，A 无法访问 B 用户的数据。 持久缓存，只有在用户关掉小程序才会删除，如果空间不足，会进行 LRU ，也就是不经常使用的小程序的数据缓存区域会被全部清空。在体验版、开发版、和线上版都共用一套，并不会隔离。没有 Cookie2、因此我们要在 Storage 中隔离一个 Cookie ，用来模拟浏览器中的 Cookie ，解析接口返回的 Header，设置 Cookie，在发送接口请求前，自动带上 Cookie。从上面知道，storage 不会自动销毁，而是在小程序销毁的时候再销毁。我们先了解一下小程序的运行机制。小程序运行机制：小程序没有重启的概念 当小程序进入后台，客户端会维持一段时间的运行状态，超过一定时间后（目前是5分钟）会被微信主动销毁 置顶的小程序不会被微信主动销毁 当收到系统内存告警也会进行小程序的销毁代码实现：const storage = {   set(){}, //设置缓存   get(){}, //获取缓存   remove(){}, // 移除缓存   checkAndClearExpired(){}, //将过期缓存清理掉 　　isExpired() {} //判断是否过期}在 storage 中隔离一个字段，用来做 cookielet cookie = (function(){    return wx.getStorageSync('cookies');}())const Cooke = {  getCookie(){}, //从内存中获取cookie  setCookie(){}, // 设置cookie  setCookieInHeader(){}, //根据response的Header设置cookie  removeCookie() {},  //删除cookie  isExpired() {} //判断是否过期}在设置storage的时候，增加一个字段 expire 用来表示过期时间。简化代码如下：function isExpired (expires) {    // 小于等于现在时间为过期    if (new Date(expires) <= new Date()) {        return true;    }}这样子，整体的流程如下：到底了，不知道是不是越来越懒了，博文写得越来越短。。。"}
{"title": "利用云开发优化博客小程序（一）——浏览量统计 ", "author": "Rolan", "pub_time": "2018-9-27 00:23", "content": "最近小程序云发开的开放让我又有了更新我的微信小程序版博客的动力。背景由于我的博客是基于开源博客框架ghost搭建的，虽然相较于wordpress轻量了很多，但在功能上远没有wordpress丰富，像基本的网站统计，文章统计，点评之类的通通没有。我的pc端博客是通过接入第三方组件来实现的，但小程序端一直无法实现「需要自己再搭建个服务端」。但有了云开发之后，这一切就变得有可能啦。想了解我的博客搭建和小程序版博客可以参考下面两篇文章：搭建Ghost 博客详细教程（总）微信小程序版博客——开发汇总总结（附源码）统计实现最想实现的还是统计功能啦，每篇文章的 浏览量 ， 点评数 ， 点赞数 之类的，这个应该是比较基本的。所以利用小程序云开发提供的数据库功能来存储这类数据，还是很方便可以实现该功能的。这里先简单说下浏览量的实现。首先需要改变下文件夹结构，因为会用到云函数的功能，所以我将云函数的文件夹和项目文件夹平级，同时小程序配置文件中新增 cloudfunctionRoot 节点，用于指向云函数文件夹，指定完之后文件夹的图标也会默认改变。创建集合接下来利用云开发的数据库创建一个集合，用于保存文章的统计数据，集合的字段如下：{\r\n    \"_id\": W5y6i7orBK9ufeyD //主键id\r\n    \"comment_count\": 0 //评论数\r\n    \"like_count\": 14 //点赞数\r\n    \"post_id\": 5b3de6b464546644ae0b7eb4 //文章id\r\n    \"view_count\": 113 //访问数\r\n}同时，最好加上索引，避免后续集合数据变多而影响查询效率，通常都是根据文章id进行查询：云函数编写集合创建完之后，需要编写云函数，用于操作数据库，当然你也可以直接在小程序端直接操作数据库。这里需要两个接口，一个用于查询文章数据，代码如下：// 云函数入口文件\r\nconst cloud = require('wx-server-sdk')\r\n\r\ncloud.init()\r\n\r\nconst db = cloud.database()\r\nconst _ = db.command\r\n\r\n// 根据文章Id集合批量查询统计数据\r\nexports.main = async (event, context) => {\r\n  try {\r\n    var result= await db.collection('posts_statistics').where({\r\n      post_id: _.in(event.post_ids)\r\n    }).get(); \r\n    return result.data \r\n  }\r\n  catch(e)\r\n  {\r\n    console.error(e)\r\n    return []\r\n  }\r\n}另一个用于新增或者更新文章统计数据,由于可能第一次访问，集合中不存在该文章ID的数据，所以加了一段默认新增的动作，代码如下：// 云函数入口文件\r\nconst cloud = require('wx-server-sdk')\r\n\r\ncloud.init()\r\n\r\nconst db = cloud.database()\r\n\r\n// 更新文章统计数据，没有则默认初始化一笔\r\nexports.main = async (event, context) => {\r\n  try {\r\n    var posts = await db.collection('posts_statistics').where({\r\n      post_id:event.post_id\r\n    }).get()\r\n\r\n    if (posts.data.length>0) {\r\n      await db.collection('posts_statistics').doc(posts.data[0]['_id']).update({\r\n        data: {\r\n          view_count: posts.data[0]['view_count'] + event.view_count ,//浏览量\r\n          comment_count: posts.data[0]['comment_count']+event.comment_count,//评论数\r\n          like_count: posts.data[0]['like_count'] + event.like_count//点赞数\r\n        }\r\n      })\r\n    }\r\n    else {\r\n      //默认初始化一笔数据\r\n      await db.collection('posts_statistics').add({\r\n        data: {\r\n          post_id: event.post_id,//文章id\r\n          view_count: 100 + Math.floor(Math.random() * 40),//浏览量\r\n          comment_count: 0,//评论数\r\n          like_count: 10 + Math.floor(Math.random() * 40)//点赞数\r\n        }\r\n      })\r\n    }\r\n    return true\r\n  } catch (e) {\r\n    console.error(e)\r\n    return false\r\n  }\r\n}小程序端接入数据库的操作编写完成之后，小程序端就可以接入了，在列表页增加对应的UI及样式：对应的代码也比较简单，在获取到文章信息之后，再调用下查询的云函数，获取到对应文章的统计数据渲染到页面，核心代码如下：//wxml部分\r\n<view class=\"icon-review\">\r\n  <view class=\"zan-icon zan-icon-browsing-history zan-pull-left zan-font-12 \"></view>\r\n  <view class=\"zan-pull-left zan-font-12\">\r\n    <text>{{item.view_count}}</text>\r\n  </view>\r\n</view>\r\n<view class=\"icon-comment\">\r\n  <view class=\"zan-icon zan-icon-records zan-pull-left zan-font-12 \"></view>\r\n  <view class=\"zan-pull-left zan-font-12\">\r\n    <text>{{item.comment_count}}</text>\r\n  </view>\r\n</view>\r\n<view class=\"icon-like\">\r\n  <view class=\"zan-icon zan-icon-like zan-pull-left zan-font-12 \"></view>\r\n  <view class=\"zan-pull-left zan-font-12\">\r\n    <text>{{item.like_count}}</text>\r\n  </view>\r\n</view>\r\n\r\n//js部分-详情页onLoad时\r\n//浏览数+1不需要知道调用结果，失败了不影响\r\nwx.cloud.callFunction({\r\n  name: 'upsert_posts_statistics',\r\n  data: {\r\n    post_id:blogId,\r\n    view_count:1,\r\n    comment_count:0,\r\n    like_count:0\r\n  }\r\n})\r\n\r\n//js部分-展示统计数据时\r\nwx.cloud.callFunction({\r\n  name: 'get_posts_statistics',\r\n  data: {\r\n    post_ids: postIds\r\n  }\r\n}).then(res => {\r\n  //访问数\r\n  post.view_count = res.result[0].view_count;\r\n  //点评数\r\n  post.comment_count = res.result[0].comment_count;\r\n  //点赞数\r\n  post.like_count = res.result[0].like_count;\r\n\r\n  this.setData({\r\n    post: post\r\n  });到这里，文章浏览量的统计接入基本就完成啦。总结目前还在开发评论功能，同时在开发的时候发现第一版的代码写的还是挺乱的，在开发新功能的同时也准备重构一下，有兴趣的小伙伴可以参考一下。"}
{"title": "微信小程序-canvas绘制文字实现自动换行 ", "author": "Rolan", "pub_time": "2018-9-27 00:32", "content": "在使用微信小程序canvas绘制文字时，时常会遇到这样的问题：因为canvasContext.fillText参数为我们只能设置文本的最大宽度，这就产生一定的了问题。如果我们绘制的文本长度不确定或者我们希望文本超出自动换行或者用省略号表示，光靠这个API是无法完成的。下面本人就讲下我在开发中是如何解决这个问题的。1 wxml代码。<canvas canvas-id=\"myCanvas\" style=\"border: 1px solid;\"/>12 wxss代码canvas {  width: 99%;  height: 600rpx;}12343 js代码Page({  data: {  },  onLoad: function (options) {    const context = wx.createCanvasContext('myCanvas')    var text = '这是一段文字用于文本自动换行文本长度自行设置欢迎大家指出缺陷';//这是要绘制的文本    var chr =text.split(\"\");//这个方法是将一个字符串分割成字符串数组    var temp = \"\";    var row = [];    context.setFontSize(18)    context.setFillStyle(\"#000\")    for (var a = 0; a < chr.length; a++) {      if (context.measureText(temp).width < 250) {        temp += chr[a];      }      else {        a--; //这里添加了a-- 是为了防止字符丢失，效果图中有对比        row.push(temp);        temp = \"\";      }    }    row.push(temp);     //如果数组长度大于2 则截取前两个    if (row.length > 2) {      var rowCut = row.slice(0, 2);      var rowPart = rowCut[1];      var test = \"\";      var empty = [];      for (var a = 0; a < rowPart.length; a++) {        if (context.measureText(test).width < 220) {          test += rowPart[a];        }        else {          break;        }      }      empty.push(test);      var group = empty[0] + \"...\"//这里只显示两行，超出的用...表示      rowCut.splice(1, 1, group);      row = rowCut;    }    for (var b = 0; b < row.length; b++) {      context.fillText(row[b], 10, 30 + b * 30, 300);    }    context.draw()      } })123456789101112131415161718192021222324252627282930313233343536373839404142434445464748494 效果展示添加了a- -和没有a- -的对比以上就是换行的方法，如果想设置为不换行超出用省略号显示，也可参照上面的方法，将数组截取为一行再设置，道理是一样的。本文来自 优雅的勒布朗 的CSDN 博客 ，全文地址请点击：https://blog.csdn.net/weixin_41941325/article/details/80274969?utm_source=copy"}
{"title": "Canvas绘图在微信小程序中的应用:生成个性化海报 ", "author": "Rolan", "pub_time": "2018-9-30 00:36", "content": "一、Canvas应用的背景(个人理解)及基础语法背景从2012年开始，微信那个时候用户的积累的量已经非常大了，推出公众号，当然大屏智能手机在那个时候也流行，传统的大众媒体逐步消亡，像微信公众号这样的新媒体盛行。企业的广告投入开始从电视等传统媒体向基于圈层文化的新媒体精准营销转移，甚至很多企业尤其互联网企业开始思考如何利用用户的自传播这种方式去宣传企业、实现商业目标。而用户的自传播很好的途径就是生产个性化的海报。举个最常见的例子，我第一次使用Keep是因为在朋友圈看到朋友分享她运动量的一个截图，当时在我看来非常酷，有心率脉搏呀、时速运动量啊、消耗的卡路里等，还有一个二维码，然后我就点了下载了Keep，这整个获客成本几乎为0，秒秒钟就多了一个用户。而实现这一过程的技术手段就可以用canvas。所以，canvas的盛行，与企业的精准营销和用户的自传播有很大的关系。如极客时间的一些实现案例：大家看第一张图的话是在2017年末的时候，Qcon全球软件开发大会预热阶段的海报。然后我们为程序员做了一个生成2018年关键字的一张海报，文案都非常有趣啊。第二张的话是在2018年元旦的时候做的极客时间助手，这个小程序当初主要是为程序员做的2018年新年签。那面就是一些极客时间的专栏，包括用户留言，你留言随手可以生成一张海报，可以转发等等大概就是这样。基础语法Canvas本质是一个可以使用脚本(通常为JavaScript)来绘制图形的 HTML 元素，默认大小为300像素×150像素(宽×高，像素的单位是px),通过JavaScript上下文对象动态创建图像。比如，画线、画矩形、涂颜色甚至生成带二维码的海报。原理就是一笔一笔的画，画一条横线，再画一条横线等等，就是不断地创建路径、绘制路径，然后把这个路径封闭起来可以涂色之类的，他的底层的封装就是放到一个数组里形成一个路径的数组，将这个数组传到js底层的一个方法，然后去绘制。举个栗子：画一个头像首先，你需要把这张图片画canvas上面，比如说你画你这个头像就是正方形，就在(0,0)开始画一个图片。那么你在这个图片的中心，作为原点，然后你画一个圆形。然后你再利用canvas语法画一个圆弧，在这个圆弧路径以外设置不可见以内设置可见，这个时候就形成了一个圆形头像。  <canvas id=\"canvas\" width=\"300\" height=\"300\"></canvas>\r\n  <script>\r\n    const canvas = document.getElementById('canvas')\r\n    const ctx = canvas.getContext('2d')\r\n    const img = new Image()\r\n    img.onload = function() {\r\n      circleImg(ctx, img, 100, 100, 50)\r\n    }\r\n    img.src=\"https://avatar-static.segmentfault.com/289/811/2898115528-58c35e9b79717_big64\"\r\n    function circleImg(ctx, img, x, y, r) {\r\n      ctx.save()\r\n      let d = 2 * r\r\n      let cx = x + r\r\n      let cy = y + r\r\n      ctx.arc(cx, cy, r, 0, 2 * Math.PI)\r\n      ctx.stroke();\r\n      ctx.clip()\r\n      ctx.drawImage(img, x, y, d, d)\r\n      ctx.restore()\r\n    }\r\n    // 微信小程序中的[canvas](https://developers.weixin.qq.com/miniprogram/dev/component/canvas.html)与HTML5的canvas在语法有些区别，比如API就不一样，\r\n    // 另外小程序中的canvas因为是原生组件的层级是最高的，所以页面中的其他组件无论设置 z-index 为多少，都无法覆盖原生组件\r\n  </script>二、常用的\"生成海报\"的方式我们会经常在朋友圈看到什么算命、性格分析、测算你的智商、情商等等这些东西，都是由用户分享出一张图片(海报)，这个图片就是用canvas做成的，上面画了二维码，二维码是一个数组两个或循环嵌套画小黑点用户识别这个二维码之后就进入他的程序，经过程序跑出来的测试结果啊什么的，点保存的时候，就会生成一张个性海报明白。怎么生成这种个性化海报呢？2.1 字符串模板此处应有案例主要实现：与服务端约定好数据格式-->前端做好模板-->服务端用第三方工具渲染返回到客户端img首先与服务端约定好数据格式，比如关键字是什么、头像URL、昵称等等，把所有放数据格式的地方用{{{}}}嵌套，告诉后端位置；然后，将前端模拟数据抠去，比如user.tags，把这一段html的字符串模板给到服务端，最后服务端拿到数据通过html2canvas这样的第三方工具把图片渲染返回给客户端展示，让用户可以长按这张图片保存到手机相册。这是比较传统的方式早些年基本上都是通过这种方式。有什么弊端呢？一是第三方工具维护不及时、不支持flex布局、ES6等语法，二是调试不方便，三是高并发的时候会出问题，特别是生成的是高清无码的海报的时候2.2 canvas绘制案例: '极客时间小助手'小程序主要实现：前端直接通过canvas生成海报摇晃手机抽取新年签跳到第一个页面，需要绘制头像、关键字以及保存按钮，黄色的保存按钮其实就是呃一张透明的png图片，把它画上去。那在这个button上面儿需要固定一个宽高和它差不多大小的一个空的、透明的div，在这个div上加点击事件，这个事件就是调第二张要保存的那个canvas。第二张这个是没有保存按钮的但有二维码。带二维码的这张canvas放哪里呢？一种方案是定位，给一个特别大的top或left，让它不显示在屏幕里边；另一个方案是层级，预览的这张canvas在真正要保存canvas图片之上，但是会有问题。手机浏览器版本低的话，定了层级不管用，一些安卓手机也会有问题，有时候会浮上来没被盖住。当然，如果要实现保存高清图的话，还是需要处理的，那就是放大，不过这个是笨方法。最优的方法是拆解这张图像，确保导出的canvas是最高清的，而且对用户来说也是最省流量的。解析：进到首页其实关键字在本地就随机取完了，在首页index.js中的onShow方法中就通过wx.getStorageSync缓存了要画的元素，比如关键字(这里是图片)、关键字解析语(也是图片,毕竟微信小程序的canvas不支持字体)等等。摇一摇触发重力感应事件wx.onAccelerometerChange监听里面的事件，获取用户授权拿到头像并跳转到poster页面。直接就开始画两张图片，一张有二维码的(shakepage1)，一张有button的(shakepage2)，这里二维码是'死码',button也是在图片的基础上覆盖一个view，画完之后调canvasToTempFilePath保导出那张带码的，此时带码的这张通过css设置visibility: hidden隐藏起来。点击按钮触发saveImageToPhotosAlbum将导出的这张 图片保存到手机相册，这里需要授权相应的要做一些处理，比如用户拒绝授权之后再次点击需要 wx.showModal再次请用户授权。基本代码如下：(详细源码))      wx.canvasToTempFilePath({\r\n        x: 0,\r\n        y: 0,\r\n        width: this.data.screenWidth,\r\n        height: this.data.screenHeight,\r\n        destWidth: this.data.screenWidth * this.data.pixelRatio,  // pixelRatio为设备的像素比  \r\n        destHeight: this.data.screenHeight * this.data.pixelRatio,\r\n        canvasId: \"canvasid\",\r\n        success: function(e) {\r\n          console.log(e)\r\n          this.setData({\r\n            bjtempFilePath: e.tempFilePath  // 拿到要保存的图片路径\r\n          }, function() {});\r\n        },\r\n        fail: function(e) {\r\n          console.log(e);\r\n        }\r\n      })  onUserSaveImageRight: function () {\r\n    console.log(\"-click-\");\r\n    var _this = this;\r\n    if (!wx.saveImageToPhotosAlbum) return wx.showModal({\r\n      title: \"提示\",\r\n      content: \"当前微信版本过低，无法使用该功能，请升级到最新微信版本后重试。\"\r\n    }), void console.log(\"version low\");\r\n    wx.getSetting({\r\n      success: function (res) {\r\n        res.authSetting[\"scope.writePhotosAlbum\"] ? (console.log(\"1-已经授权《保存图片》权限\"), _this.saveimgfn()) : wx.authorize({\r\n          scope: \"scope.writePhotosAlbum\",\r\n          success: function () {\r\n            console.log(\"用户对相册-授权成功\"), _this.saveimgfn();\r\n          },\r\n          fail: function () {\r\n            wx.showModal({\r\n              title: \"提示\",\r\n              content: \"请您授权保存到系统相册\",\r\n              showCancel: !1,\r\n              success: function (res) {\r\n                res.confirm && wx.openSetting({\r\n                  success: function (res) {\r\n                    res.authSetting[\"scope.writePhotosAlbum\"] ? setTimeout(function () {\r\n                      _this.saveimgfn();\r\n                    }, 500) : wx.showModal({\r\n                      title: \"提示\",\r\n                      content: \"您未授权，无法将海报保存到相册，你可以截屏得到海报，或者再次点击'保存海报'按钮并授权\",\r\n                      showCancel: !1\r\n                    });\r\n                  }\r\n                });\r\n              }\r\n            });\r\n          }\r\n        });\r\n      }\r\n    });\r\n  },\r\n  saveimgfn: function () {\r\n    var filePath = this.data.bjtempFilePath;\r\n    console.log(filePath), filePath ? wx.saveImageToPhotosAlbum({\r\n      filePath: filePath,\r\n      success: function (res) {\r\n        wx.showToast({\r\n          title: \"保存成功\",\r\n          icon: \"success\",\r\n          duration: 1500\r\n        });\r\n      },\r\n      fail: function () {\r\n        wx.showToast({\r\n          title: \"保存失败\",\r\n          icon: \"fail\",\r\n          duration: 1500\r\n        });\r\n      }\r\n    }) : this.saveImage()三、极客时间小程序-生成各种海报的解决方案微信小程序canvas与HTM5的canvas对比微信小程序canvas中层级z-index失效，小程序中canvas拥有最高级，无法二次设置;微信小程序canvas不支持字体功能，特殊字体只能用图片代替;微信小程序canvas不支持绘制在线图片，需要下载再绘制(安全域名的锅)微信小程序canvas可以实现不同尺寸屏幕自适应    var rpx;\r\n    //获取屏幕宽度，获取自适应单位\r\n    wx.getSystemInfo({\r\n      success: function(res) {\r\n        rpx = res.windowWidth/750\r\n      },\r\n    })\r\n    // 在绘制方法中将参数乘以相对单位即可实现自适应\r\n    const s = wx.createCanvasContext(\"canvas\")\r\n    s.drawImage(Url, 0, 0, 265 * rpx, 262.5 * rpx) 如何导出高清海报、如何封装；wx.canvasToTempFilePath({\r\n    canvasId: 'image-save',\r\n    x: 0,\r\n    y: 0,\r\n    success: res => {\r\n       wx.saveImageToPhotosAlbum({\r\n         filePath: res.tempFilePath,\r\n         success: () => {\r\n           this.setData({saving: false})\r\n           utils.success('保存成功')\r\n           setTimeout(() => {wx.navigateBack()}, 500)\r\n         },\r\n         fail: err => {\r\n           this.setData({saving: false})\r\n           wx.getSetting({\r\n             success: res => {\r\n               if(!res.authSetting || !res.authSetting['scrop.writePhotoAlbum']){\r\n                 wx.openSetting()\r\n               }\r\n             }\r\n           })\r\n         }\r\n       })\r\n    }\r\n})"}
{"title": "微信小程序踩坑系列——从wx.request谈谈异步处理 ", "author": "Rolan", "pub_time": "2018-9-30 00:40", "content": "见到wx.request的第一眼，就让我想起了$.ajax这东西，使用起来确实有很多不方便，不能忍，幸好小程序是支持ES6语法的，所以可以使用promise稍加改造。先来说说wx.request为什么不能忍。铺垫：“看得见却抓不住“的异步请求123456789101112131415161718192021222324Page({  data: {    myData: ''  },  // loadMyData函数用于打印myData的值  loadMyData () {    console.log('获取到的数据为：' + this.data.myData)  },  // 生命周期函数onload用于监听页面加载  onload: function () {    wx.request({      url: 'https://api',  // 某个api接口地址      success: res => {        console.log(res.data)        this.setData({          myData: res.data        })        console.log(this.data.myData)      }    })    // 调用之前的函数    this.loadMyData()  }})然后我们会在控制台到这样的结果：这其实是一个很简单的异步问题，wx.request是异步请求，JS不会等待wx.request执行完毕再往下执行，所以JS按顺序会先执行this.loadMyData()，等服务器返回数据以后，loadMyData()早就执行完了，当然也就没有拿到值啦。其实我们在同步流程中才说“返回”，异步没有“返回”这个概念（或者说异步返回是没有意义的），异步对应的是“回调”，也就是说，对于一个异步函数，我们应该传入一个“回调函数”来接收结果。初步解决：通过回调接收结果最简单的解决方案，就是把需要使用异步数据的函数写在回调里：123456789101112131415...onload: function () {  wx.request({    url: 'https://api',  // 某个api接口地址    success: res => {      console.log(res.data)      this.setData({        myData: res.data      })      console.log(this.data.myData)      // 把使用数据的函数写在回调函数success中      this.loadMyData()    }  })}这样就可以正确输出了：但是如果逻辑复杂，需要多层异步操作，会出现怎么样的情况呢？123456789101112131415asyncFn1(function(){  //...  asyncFn2(function(){    //...    asyncFn3(function(){      //...      asyncFn4(function(){        //...        asyncFn5(function(){           //...        });      });    });  });});有没有感觉头皮发麻？什么优雅什么可读性，瞬间荡然无存，这就是恐怖的“回调地狱”（Callback Hell）。而我们发现，微信小程序的网络请求wx.request，也正是这种依靠回调函数的形式，类似于以前的$.ajax，它在逻辑复杂、页面执行顺序要求多的情况下，弊端也是很明显的。不过好在小程序支持ES6，我们可以尽情地拥抱Promise！使用Promise包装wx.requestPromise这东西简单说来就是，它可以将异步的执行逻辑和结果处理分离，摒弃了一层又一层的回调嵌套，使得处理逻辑更加清晰。想具体了解的还请自行查找资料。现在我们就用Promise包装一下wx.request：12345678910111213141516/** * requestPromise用于将wx.request改写成Promise方式 * @param：{string} myUrl 接口地址 * @return: Promise实例对象 */const requestPromise = myUrl => {  // 返回一个Promise实例对象  return new Promise((resolve, reject) => {    wx.request({      url: myUrl,      success: res => resolve(res)    })  })}// 我把这个函数放在了utils.js中，这样在需要时可以直接引入module.exports = requestPromise现在再使用试试：123456789101112131415161718// 引用模块const utilApi = require('../../utils/util.js')Page({  ...  // 生命周期函数onload用于监听页面加载  onLoad: function () {    utilApi.requestPromise(\"https://www.bilibili.com/index/ding.json\")    // 使用.then处理结果    .then(res => {      console.log(res.data)      this.setData({        myData: res.data      })      console.log(this.data.myData)      this.loadMyData()    })  }})结果和使用回调函数一致。当有多个异步请求时，直接不断地.then(fn)去处理即可，逻辑清晰。当然，这里只是写了一个最简单的Promise函数，还不完整。更完整的Promise化wx.request，等以后业务需要再完善吧。另外各种小程序开发框架也都有了现成的promise化API，拿来即用。"}
{"title": "Westore 发布小程序插件开发模板和其他重大更新及原理 ", "author": "Rolan", "pub_time": "2018-9-30 00:45", "content": "Westore 开源两天就突破了 1000 star，还登顶过Github日榜第一名。期间受到了海量关注，收到了大量的中肯和实用的反馈和意见。小程序插件开发的诉求是非常重要的意见之一。所以我马不停蹄地努力连夜更新，看 Github 提交记录就知道我凌晨 3 点钟有合并 PR，也有提交代码 = =！Github地址: github.com/dntzhang/we…先回顾一下小程序现有的痛点:使用 this.data 可以获取内部数据和属性值，但不要直接修改它们，应使用 setData 修改setData 编程体验不好，很多场景直接赋值更加直观方便setData 卡卡卡慢慢慢，JsCore 和 Webview 数据对象来回传浪费计算资源和内存资源组件间通讯或跨页通讯会把程序搞得乱七八糟，变得极难维护和扩展所以没使用 westore 的时候经常可以看到这样的代码:使用 Westore 对编程体验的改善:上面两种方式也可以混合使用。这里需要特别强调，虽然 this.update 可以兼容小程序的 this.setData 的方式传参，但是更加智能，this.update 会按需 Diff 或者 透传给 setData。原理:再举个例子：this.store.data.motto = 'Hello Store222'\r\nthis.store.data.b.arr.push({ name: 'ccc' })\r\nthis.update()\r\n复制代码等同于this.update({\r\n  motto:'Hello Store222',\r\n  [`b.arr[${this.store.data.b.arr.length}]`]:{name:'ccc'}\r\n})\r\n复制代码小程序插件小程序插件是对一组 js 接口、自定义组件或页面的封装，用于嵌入到小程序中使用。插件不能独立运行，必须嵌入在其他小程序中才能被用户使用；而第三方小程序在使用插件时，也无法看到插件的代码。因此，插件适合用来封装自己的功能或服务，提供给第三方小程序进行展示和使用。插件开发者可以像开发小程序一样编写一个插件并上传代码，在插件发布之后，其他小程序方可调用。小程序平台会托管插件代码，其他小程序调用时，上传的插件代码会随小程序一起下载运行。插件开发者文档插件使用者文档插件开发Westore 提供的目录如下:|--components\r\n|--westore\t\r\n|--plugin.json\t\r\n|--store.js\r\n复制代码创建插件:import create from '../../westore/create-plugin'\r\nimport store from '../../store'\r\n\r\n//最外层容器节点需要传入 store，其他组件不传 store\r\ncreate(store, {\r\n  properties:{\r\n    authKey:{\r\n      type: String,\r\n      value: ''\r\n    }\r\n  },\r\n  data: { list: [] },\r\n  attached: function () {\r\n    // 可以得到插件上声明传递过来的属性值\r\n    console.log(this.properties.authKey)\r\n    // 监听所有变化\r\n    this.store.onChange = (detail) => {\r\n      this.triggerEvent('listChange', detail)\r\n    }\r\n    // 可以在这里发起网络请求获取插件的数据\r\n    this.store.data.list = [{\r\n      name: '电视',\r\n      price: 1000\r\n    }, {\r\n      name: '电脑',\r\n      price: 4000\r\n    }, {\r\n      name: '手机',\r\n      price: 3000\r\n    }]\r\n\r\n    this.update()\r\n\r\n    //同样也直接和兼容 setData 语法\r\n    this.update(\r\n        { 'list[2].price': 100000 }\r\n    )\r\n  }\r\n})\r\n复制代码在你的小程序中使用组件：<list auth-key=\"{{authKey}}\" bind:listChange=\"onListChange\" />\r\n复制代码这里来梳理下小程序自定义组件插件怎么和使用它的小程序通讯:通过 properties 传入更新插件，通过 properties 的 observer 来更新插件通过 store.onChange 收集 data 的所有变更通过 triggerEvent 来抛事件给使用插件外部的小程序这么方便简洁还不赶紧试试 Westore插件开发模板 ！特别强调插件内所有组件公用的 store 和插件外小程序的 store 是相互隔离的。原理页面生命周期函数名称描述onLoad监听页面加载onShow监听页面显示onReady监听页面初次渲染完成onHide监听页面隐藏onUnload监听页面卸载组件生命周期函数名称描述created在组件实例进入页面节点树时执行，注意此时不能调用 setDataattached在组件实例进入页面节点树时执行ready在组件布局完成后执行，此时可以获取节点信息（使用 SelectorQuery ）moved在组件实例被移动到节点树另一个位置时执行detached在组件实例被从页面节点树移除时执行由于开发插件时候的组件没有 this.page，所以 store 是从根组件注入，而且可以在 attached 提前注入:export default function create(store, option) {\r\n    let opt = store\r\n    if (option) {\r\n        opt = option\r\n        originData = JSON.parse(JSON.stringify(store.data))\r\n        globalStore = store\r\n        globalStore.instances = []\r\n        create.store = globalStore\r\n    }\r\n\r\n    const attached = opt.attached\r\n    opt.attached = function () {\r\n        this.store = globalStore\r\n        this.store.data = Object.assign(globalStore.data, opt.data)\r\n        this.setData.call(this, this.store.data)\r\n        globalStore.instances.push(this)\r\n        rewriteUpdate(this)\r\n        attached && attached.call(this)\r\n    }\r\n    Component(opt)\r\n}\r\n复制代码"}
{"title": "小程序即时通讯demo ", "author": "Rolan", "pub_time": "2018-10-10 00:21", "content": "前段时间写了一个小程序即时聊天demo,仿微信，效果如下:项目地址是： github.com/lirongrong/… ,大家可以自行下载，按照提示运行，就能看到效果；现在只是做了要给基本版的，要做复杂功能，可以继续添加。功能发送文字发送图片（图片可点击放大）发送拍摄照片 （图片可点击放大）发送位置 （map组件默认在最顶层，样式控制不了，bug还在修复中...）发送语音 （包括语音时长，可点击播放）websorket长连接是基于nodejs-websocket的服务，代码如下：(最基础版)var ws = require(\"nodejs-websocket\")\r\n\r\n// Scream server example: \"hi\" -> \"HI!!!\"\r\n//创建一个server\r\nvar server = ws.createServer(function (conn) {\r\n\tconsole.log(\"New connection\")\r\n\tconn.on(\"text\", function (str) { \r\n\t\t// console.log(\"Received \"+str)\r\n\t\t// conn.sendText(str.toUpperCase()+\"!!!\")\r\n\t\t//链接成功之后，发送欢迎语\r\n\t\tconsole.log(\"连接成功\")\r\n\t\t//欢迎语\r\n\t\tif(str == 'null'){\r\n\t\t\tconn.sendText(\"有什么能帮到您？\");\r\n\t\t}\r\n\t\t//输入文字\r\n\t\telse if(str != 'null' && str){\r\n\t\t\tconn.sendText(\"文字\")\r\n\t\t}\r\n\t\t//输入多媒体\r\n\t\telse{\r\n\t\t\tconn.sendText(\"多媒体文本\")\r\n\t\t}\r\n\t\tconsole.log(str);\r\n\t})\r\n\tconn.on(\"close\", function (code, reason) {\r\n\t\tconsole.log(\"Connection closed\")\r\n\t})\r\n}).listen(8001)\r\n复制代码在项目根目录下运行 npm run dev 服务就能启动了， 启动之后websorket地址为： ws://localhost:8001chat.js直接看代码，注释都写清楚了// pages/user/chat.js\r\nvar util = require('../utils/util.js');\r\nvar app = getApp();\r\n//websocket心跳重连对象\r\nlet heartCheck = {\r\n  timeout: 1000,//1s\r\n  timeoutObj: null,\r\n  serverTimeoutObj: null,\r\n  //重置\r\n  reset: function () {\r\n    clearTimeout(this.timeoutObj);\r\n    clearTimeout(this.serverTimeoutObj);\r\n    return this;\r\n  },\r\n  //开始\r\n  start: function () {\r\n    wx.sendSocketMessage({\r\n      data: \"null\",\r\n    });\r\n  }, \r\n}; \r\n//微信小程序新录音接口，录出来的是aac或者mp3，这里要录成mp3\r\nconst recorderManager = wx.getRecorderManager();\r\nconst options = {\r\n  duration: 600000,//录音时长，这里设置的是最大值10分钟\r\n  sampleRate: 44100,\r\n  numberOfChannels: 1,\r\n  encodeBitRate: 192000,\r\n  format: 'mp3',\r\n  //frameSize: 50 \r\n};\r\n\r\n//音频播放\r\nconst innerAudioContext = wx.createInnerAudioContext()\r\n\r\nPage({ \r\n  data: {  \r\n    taskId:'',\r\n    userId:'',\r\n    chatList:[],//聊天内容\r\n    isShowModelUp:false,//底部弹框显示true,隐藏为false \r\n    isLuYin:false,//没有录音false,开始录音true\r\n    luYinText:'按住说话',\r\n    audioUrl:'',//录音文件地址\r\n    isShowLuYin:false,//true为开始播放，false为取消播放\r\n    inputValue:'',//输入框内容\r\n    lockReconnect:false,//默认进来是断开链接的\r\n    limit:0,//重连次数\r\n  }, \r\n  onLoad: function (options) { \r\n    this.linkSocket(); \r\n  }, \r\n  //连接socket\r\n  linkSocket:function(){\r\n    let that = this;\r\n    wx.connectSocket({\r\n      //url: app.globalData.wsUrl + 'websocket?' + this.data.taskId + '&' + this.data.userId,\r\n      url:app.globalData.wsUrl,\r\n      success() {\r\n        console.log('连接成功')\r\n        wx.onSocketMessage((res) => {\r\n          console.log(res.data);\r\n          //收到消息\r\n          that.pushChatList(0, {\r\n            text: res.data\r\n          });\r\n        })\r\n        wx.onSocketOpen(() => {\r\n          console.log('WebSocket连接打开')\r\n          heartCheck.reset().start()\r\n        })\r\n        wx.onSocketError(function (res) {\r\n          console.log('WebSocket连接打开失败')\r\n          that.reconnect()\r\n        })\r\n        wx.onSocketClose(function (res) {\r\n          console.log('WebSocket已关闭！')\r\n          that.reconnect()\r\n        })\r\n      }\r\n    }) \r\n  }, \r\n  //断线重连\r\n  reconnect() { \r\n    var that = this;\r\n    if (that.lockReconnect) return;\r\n    that.lockReconnect = true;\r\n    clearTimeout(that.timer)\r\n    if (that.data.limit < 12) {\r\n      that.timer = setTimeout(() => {\r\n        that.linkSocket();\r\n        that.lockReconnect = false;\r\n      }, 5000);\r\n      that.setData({\r\n        limit: that.data.limit + 1\r\n      })\r\n    } \r\n  }, \r\n  //打开底部弹框\r\n  showModelUp:function(){ \r\n    var that=this; \r\n    if (that.data.isShowModelUp==false){\r\n      that.setData({\r\n        isShowModelUp: true, \r\n      })\r\n    }else{\r\n      that.setData({\r\n        isShowModelUp: false, \r\n      })\r\n    } \r\n  },\r\n  //关闭底部弹框\r\n  closeModelUp:function(){\r\n    var that=this;\r\n    that.setData({\r\n      isShowModelUp:false, \r\n    })\r\n  },\r\n  //选择照片\r\n  chooseImage:function(){\r\n    var that=this;\r\n    wx.chooseImage({ \r\n      count: 1, // 默认9\r\n      sizeType: ['original', 'compressed'], // 可以指定是原图还是压缩图，默认二者都有\r\n      sourceType: ['album'], // 可以指定来源是相册还是相机，默认二者都有\r\n      success: function (res) { \r\n        // 返回选定照片的本地文件路径列表，tempFilePath可以作为img标签的src属性显示图片\r\n        var tempFilePaths = res.tempFilePaths;\r\n        console.log(res);\r\n        that.pushChatList(1,{\r\n          imgUrl: tempFilePaths,\r\n        }) \r\n        //关闭弹窗\r\n        that.closeModelUp();\r\n        that.pageScrollToBottom();\r\n      }\r\n    })\r\n  },\r\n  //界面滚到最底端\r\n  pageScrollToBottom: function () {\r\n    wx.createSelectorQuery().select('#bottom').boundingClientRect(function (rect) {\r\n      console.log(rect.top);\r\n      console.log(rect.bottom);\r\n      // 使页面滚动到底部\r\n      wx.pageScrollTo({\r\n        scrollTop: rect.bottom + 200\r\n      })\r\n    }).exec()\r\n  },\r\n  //预览图片\r\n  previewImage:function(e){\r\n    console.log(e);\r\n    var url=e.currentTarget.dataset.src;\r\n    var that=this;\r\n    wx.previewImage({\r\n      current: url[0], // 当前显示图片的http链接\r\n      urls: url // 需要预览的图片http链接列表\r\n    })\r\n  },\r\n  //拍摄\r\n  paishe:function(){\r\n    var that = this;\r\n    wx.chooseImage({\r\n      count: 1, // 默认9\r\n      sizeType: ['original', 'compressed'], // 可以指定是原图还是压缩图，默认二者都有\r\n      sourceType: ['camera'], // 可以指定来源是相册还是相机，默认二者都有\r\n      success: function (res) {\r\n        // 返回选定照片的本地文件路径列表，tempFilePath可以作为img标签的src属性显示图片\r\n        var tempFilePaths = res.tempFilePaths;\r\n        console.log(res);\r\n        that.pushChatList(1,{\r\n          imgUrl: tempFilePaths,\r\n        })\r\n        //关闭弹窗\r\n        that.closeModelUp();\r\n        that.pageScrollToBottom();\r\n      }\r\n    })\r\n  },\r\n  //发送位置\r\n  getlocat: function () {\r\n    var that = this\r\n    wx.getLocation({\r\n      type: 'gcj02', //返回可以用于wx.openLocation的经纬度\r\n      success: function (res) {\r\n        that.setData({\r\n          latitude: res.latitude,\r\n          longitude: res.longitude,\r\n          markers: [{\r\n            latitude: res.latitude,\r\n            longitude: res.longitude,\r\n            name: '时代一号',\r\n            desc: '现在的位置'\r\n          }], \r\n        })\r\n        that.pushChatList(1,{\r\n          map: true\r\n        })\r\n      }\r\n    })\r\n    that.closeModelUp();\r\n    that.pageScrollToBottom();\r\n  },\r\n  //切换是否录音按钮\r\n  btnRecord:function(){ \r\n    var that=this;\r\n    if (that.data.isLuYin==false){\r\n      that.setData({\r\n        isLuYin: true\r\n      });\r\n    }else{\r\n      that.setData({\r\n        isLuYin: false,\r\n        luYinText: '按住说话'\r\n      });\r\n    }  \r\n  },\r\n  //开始录音\r\n  startRecord:function(e){ \r\n    var that=this;\r\n    that.setData({\r\n      luYinText:'录音中...', \r\n    }); \r\n    recorderManager.start(options); \r\n    recorderManager.onStart(() => {\r\n      console.log('recorder start')\r\n    })\r\n  },\r\n  //结束录音\r\n  stopRecord:function(){ \r\n    var that = this;\r\n    that.setData({\r\n      luYinText: '按住说话'\r\n    });\r\n    recorderManager.stop();  \r\n    recorderManager.onStop((res) => {\r\n      console.log('recorder stop', res)\r\n      const { tempFilePath } = res;\r\n      that.pushChatList(1,{\r\n        audioUrl: res.tempFilePath,\r\n        audioDuration: (res.duration / 60000).toFixed(2),//录音时长,转为分,向后取两位,\r\n      })\r\n      that.setData({\r\n        audioUrl: res.tempFilePath,\r\n        audioDuration: (res.duration / 60000).toFixed(2),//录音时长,转为分,向后取两位,\r\n      })\r\n    })\r\n    //关闭弹窗\r\n    that.closeModelUp();\r\n    that.pageScrollToBottom();\r\n  },\r\n  //录音、停止播放\r\n  playRecord:function(e){  \r\n    console.log(e);\r\n    var that=this;  \r\n    innerAudioContext.autoplay = true;\r\n    innerAudioContext.src = that.data.audioUrl\r\n    //innerAudioContext.src = 'http://ws.stream.qqmusic.qq.com/M500001VfvsJ21xFqb.mp3?guid=ffffffff82def4af4b12b3cd9337d5e7&uin=346897220&vkey=6292F51E1E384E061FF02C31F716658E5C81F5594D561F2E88B854E81CAAB7806D5E4F103E55D33C16F3FAC506D1AB172DE8600B37E43FAD&fromtag=46';//测试音频文件\r\n    if (!e.currentTarget.dataset.isshowluyin){//开始播放 \r\n      //innerAudioContext.play();//兼容起见用它\r\n      innerAudioContext.onPlay(() => {\r\n        console.log('开始播放');\r\n        that.setData({ \r\n          isShowLuYin: true\r\n        }); \r\n        return;\r\n      }); \r\n    }else{//暂停播放 \r\n      innerAudioContext.pause();\r\n      console.log(\"暂停\");\r\n      that.setData({\r\n        isShowLuYin: false\r\n      });\r\n      return; \r\n    } \r\n  },\r\n  //输入框点击完成按钮时触发\r\n  btnConfirm:function(e){\r\n    var that = this;\r\n    if (typeof (e) == 'undefined' || e.detail.value == ''){\r\n      return false;\r\n    }else {  \r\n      var value = e.detail.value;\r\n      that.pushChatList(1,{\r\n        text: value\r\n      });\r\n      that.setData({\r\n        inputValue:''//清空输入框\r\n      })\r\n      //发送数据\r\n      wx.sendSocketMessage({\r\n        data: value\r\n      })\r\n      //关闭弹窗\r\n      that.closeModelUp();\r\n      that.pageScrollToBottom();\r\n    }\r\n  },\r\n  //页面隐藏/切入后台时触发\r\n  onHide:function(){\r\n    wx.onSocketClose(function (res) {\r\n      console.log('WebSocket已关闭！') \r\n    })\r\n  },\r\n  //页面卸载时触发\r\n  onUnload:function(){\r\n    wx.onSocketClose(function (res) {\r\n      console.log('WebSocket已关闭！')\r\n    })\r\n  },\r\n  //pushchatList\r\n  //enu:0 是客服发送的消息\r\n  //enu:1 是我发送的消息\r\n  pushChatList:function(enu,options){\r\n    var that = this;\r\n    var defaults = {\r\n      userImage: '',\r\n      text: '',\r\n      isAdmin: false,\r\n    }\r\n    options = util.extendObj(defaults,options);\r\n    options.time = util.formatDateTime(util.getNowFormatDate());\r\n    console.log(options); \r\n    if(enu == 0){\r\n      options.userImage = '../images/admin.png';\r\n      options.isAdmin = false;  \r\n    }else if(enu==1){\r\n      options.userImage = app.globalData.wxUserInfo.avatarUrl;\r\n      options.isAdmin = true;\r\n    }\r\n    var t = that.data.chatList;\r\n    t.push(options)\r\n    that.setData({\r\n      chatList: t\r\n    });\r\n  }\r\n})\r\n复制代码需要优化的地方上传图片应该要支持多图上传并压缩一下，我做h5的聊天功能的时候压缩了，这个简版的小程序没做，大家可以自行加上这个demo只是实现了UI和文字的通讯，图片、视频、地图等的通讯还没完善发送消息之后滚到底部的方法需要改进，因为发送图片、地图、语音没有滚到底部需要改进的请大神指点"}
{"title": "利用云开发优化博客小程序（二）——评论功能 ", "author": "Rolan", "pub_time": "2018-10-10 00:34", "content": "这几天陆陆续续抽了点时间迭代了一版我的小程序版博客，一来是因为云开发的出现，让很多功能成为了可能，二来正好也正好深度熟悉下云开发。这次迭代主要是完善了评论功能「不知道审核能不能过」，一开始觉得很快能搞定，然而真正开发的时候还是碰到很多问题，这篇文章既是回顾总结，也是记录下自己在开发过程中遇到的一些坑，仅供参考。开发回顾具体思路还是比较简单的，利用云开发中的数据库来保存评论数据，在文章详情页的底部呈现具体的评论数据。在上一篇云发开初体验中，我已经创建了 posts_statistics 集合，用来存储文章的 访问数 ， 喜欢数 和 评论数 ,这次新建了 posts_comments 集合用于存储具体的评论数据，结构如下：\"_id\": \"集合id\"\r\n\"_openid\": \"评论人openid\"\r\n\"cAvatarUrl\": \"头像url\"\r\n\"cNickName\": \"昵称\"\r\n\"comment\": \"评论内容\"\r\n\"createDate\": \"创建日期\"\r\n\"flag\": 0\r\n\"postId\": \"文章id\"\r\n\"timestamp\": \"时间戳\"\r\n\"childComment\":\r\n    [{\"cAvatarUrl\": \"评论人url\"\r\n    \"cNickName\": \"评论人昵称\"\r\n    \"cOpenId\": \"评论人openid\"\r\n    \"comment\": \"评论内容\"\r\n    \"createDate\": 2018-09-29\r\n    \"flag\": \"数据标识\"\r\n    \"tNickName\": \"对方昵称\"\r\n    \"tOpenId\": \"对方openid\"\r\n    \"timestamp\": \"时间戳\"}]在创建完集合之后，需要编写对应的查询，新增，和新增子评论的方法。主要说下查询和新增子评论。查询的话肯定需要分页加载，控制一次性数据的加载量，会用到 skip 和 limit ,大致写法如下：return db.collection('posts_comments')\r\n    .where({postId: postId})\r\n    .orderBy('timestamp', 'desc')\r\n    .skip((page - 1) * 10)\r\n    .limit(10)\r\n    .get()然后是新增子评论，相当于在主评论下回复别人，主要在集合中 childComment 下新增评论，这里使用 db.command.push 更新指令，往数组尾部添加一个或多个值。大致写法如下：const _ = db.command\r\nreturn db.collection('posts_comments').doc(id).update({\r\n    data: {\r\n      childComment: _.push(data)\r\n    }在文章详情底部功能栏的样式上，还是比较纠结的，参考了一些UI，最终还是使用这种折叠的方式，具体的样式代码就不贴了。其中有几个交互可以唠叨下。首先是点 加号 会上拉底部的功能按钮，这个没什么问题，但细节需要注意，通常情况下点空白处时会自动缩回去，但这个实现有点凌乱，于是我在功能菜单以外的视图外层套了层view:<view catchtap=\"hiddenMenubox\">\r\n...文章主题部分...\r\n</view>\r\n\r\n/**\r\n * 非评论区隐藏菜单\r\n*/\r\nhiddenMenubox: function() {\r\n\tthis.setData({\r\n\t  isShow: false,\r\n\t  menuBackgroup: false\r\n\t})\r\n},然后是评论输入框中的提示，默认是 评论... ，当点击回复具体某个人的评论时，默认修改成 回复*** 。然后是喜欢和收藏两个按钮，喜欢和收藏之后图标自动点亮。还有就是提交完评论之后默认重新刷新评论列表，最后一条评论之后停止刷新，没有评论友好提示等。总之一些小的交互点还是挺多的。这里就不一一说明了，有兴趣的可以浏览下我的小程序，并看看源码。问题点整理主要还是说说开发过程中的问题点和如何解决的。1.获取用户的openid首先是获取用户的openid问题，在没有云函数之前，获取用户的openid还是比较麻烦的，需要通过wx.login获取code，然后通过code和小程序的appid和secret请求接口从而获取到openid。而有云函数之后，可以简单调用下云函数，经过微信鉴权之后可直接获取到用户的openid：exports.main = (event, context) => {\r\n  return {\r\n    openid: event.userInfo.openId,\r\n  }\r\n}2. 数据库操作权限问题因为每月云函数有调用次数的限制，所以想直接在客户端调用数据库。一开始挺顺利的，但当更新子评论的时候出现问题了，由于客户端对于数据库最大权限是 所有用户可读，仅创建者及管理员可写 ,所以导致子评论无法更新进去「创建者和子评论者是两个用户」。所以没办法，只能包一层云函数，云函数中调用数据库，因为服务端调用数据库没有这个权限的限制。// 云函数入口函数\r\nexports.main = async (event, context) => {\r\n  return await db.collection('posts_comments').doc(event.id).update({\r\n    data: {\r\n      childComment: _.push(event.comments)\r\n    }\r\n  })\r\n}其实个人感觉数据库操作最好都放在服务端比较好，由云函数统一收口，设计好的话，云函数还能当作路由的作用。3.catchtap与bindtap一开始没有仔细看文档，所以猜了坑，稍微关注下就可以避免了，同为点击事件， bindtap 事件绑定不会阻止冒泡事件向上冒泡,而 catchtap 事件绑定可以阻止冒泡事件向上冒泡。所以在由多层嵌套的时候一定要注意下，是否需要冒泡。4.promise上一版本中的方法基本都采用的回调方式，之前功能简单感觉阅读起来还好。但这次改动之后发现代码就坑了，回调方法太多感觉有点眼花了。原本打算使用ES7的特性 async/await ，但发现目前微信web开发者工具还不支持，相信以后应该会支持吧，不太愿意引用其他插件了，所以还是使用了 promise ,使用下来代码可阅读性提高了很多，可以一直 then 下去。但毕竟不是专业前端，总感觉代码写的还是比较糟糕，后期打算再迭代优化下代码。5. 样式在样式上遇到的问题其实挺多的，主要还是自己的基本功不扎实，所以踩了很多的布局的坑，这里就不一一说了，也说不清楚，自己亲自搭建之后还是会有很深印象的。其他优化点在开发评论功能的同时，也优化了一些问题点，这里也说明下：引流公众号组件也是最近更新的功能，所以将此功能加上去了，比较简单，在公众平台中启用关注组件并绑定公众号，然后代码中引用下即可：<official-account></official-account>效果可以看下，还是挺有意思的：2. 授权原本的授权是跳转到单独的页面的，访问过我的小程序的知道，那个页面有个可爱的gif的萌妹子但发现体验不是很好，首先这个gif萌妹子体积比较大，影响首次加载。其次是跳转时效果也不是很理想。所以改成弹窗的方式，并首次使用了模板页：3. 修复wxParse的问题有网友反馈部分安卓机文章详情页加载不出来，后来发现是因为 wxParse 中 console.dir 的问题，部分安卓机不支持，注释掉即可。总结2.0的代码提交审核了，不懂能不能通过，希望在国庆节可以和大家见面吧。其实要优化的点和开发的功能还是有很多，比如生成海报还没有开发，发送的文本框不能换行，体验不太好等等。后期慢慢迭代吧，也欢迎大家使用体验，并多提宝贵意见。Ps.需要源码的可以关注我的微信公众号 Bug生活2048 ，平时会推送一些技术文章和职场趣事"}
{"title": "小程序解决方案 Westore - 组件、纯组件、插件开发 ", "author": "Rolan", "pub_time": "2018-10-10 00:40", "content": "数据流转先上一张图看清 Westore 怎么解决小程序数据难以管理和维护的问题:非纯组件的话，可以直接省去 triggerEvent 的过程，直接修改 store.data 并且 update，形成缩减版单向数据流。Github: https://github.com/dntzhang/westore组件这里说的组件便是自定义组件，使用原生小程序的开发格式如下:Component({\r\n  properties: { },\r\n\r\n  data: { },\r\n\r\n  methods: { }\r\n})使用 Westore 之后:import create from '../../utils/create'\r\n\r\ncreate({\r\n  properties: { },\r\n\r\n  data: { },\r\n\r\n  methods: { }\r\n})看着差别不大，但是区别：Component 的方式使用 setData 更新视图create 的方式直接更改 store.data 然后调用 updatecreate 的方式可以使用函数属性，Component 不可以，如：export default {\r\n  data: {\r\n    firstName: 'dnt',\r\n    lastName: 'zhang',\r\n    fullName:function(){\r\n      return this.firstName + this.lastName\r\n    }\r\n  }\r\n}绑定到视图:<view>{{fullName}}</view>小程序 setData 的痛点:使用 this.data 可以获取内部数据和属性值，但不要直接修改它们，应使用 setData 修改setData 编程体验不好，很多场景直接赋值更加直观方便setData 卡卡卡慢慢慢，JsCore 和 Webview 数据对象来回传浪费计算资源和内存资源组件间通讯或跨页通讯会把程序搞得乱七八糟，变得极难维护和扩展没使用 westore 的时候经常可以看到这样的代码:使用完 westore 之后:上面两种方式也可以混合使用。可以看到，westore 不仅支持直接赋值，而且 this.update 兼容了 this.setData 的语法，但性能大大优于 this.setData，再举个例子：this.store.data.motto = 'Hello Westore'\r\nthis.store.data.b.arr.push({ name: 'ccc' })\r\nthis.update()等同于this.update({\r\n  motto:'Hello Westore',\r\n  [`b.arr[${this.store.data.b.arr.length}]`]:{name:'ccc'}\r\n})这里需要特别强调，虽然 this.update 可以兼容小程序的 this.setData 的方式传参，但是更加智能，this.update 会先 Diff 然后 setData。原理:纯组件常见纯组件由很多，如 tip、alert、dialog、pager、日历等，与业务数据无直接耦合关系。组件的显示状态由传入的 props 决定，与外界的通讯通过内部 triggerEvent 暴露的回调。triggerEvent 的回调函数可以改变全局状态，实现单向数据流同步所有状态给其他兄弟、堂兄、姑姑等组件或者其他页面。Westore里可以使用 create({ pure: true }) 创建纯组件（当然也可以直接使用 Component），比如 ：import create from '../../utils/create'\r\n\r\ncreate({\r\n  pure : true,\r\n  \r\n  properties: {\r\n    text: {\r\n      type: String,\r\n      value: '',\r\n      observer(newValue, oldValue) { }\r\n    }\r\n  },\r\n\r\n  data: {\r\n    privateData: 'privateData'\r\n  },\r\n\r\n  ready: function () {\r\n    console.log(this.properties.text)\r\n  },\r\n\r\n  methods: {\r\n    onTap: function(){\r\n      this.store.data.privateData = '成功修改 privateData'\r\n      this.update()\r\n      this.triggerEvent('random', {rd:'成功发起单向数据流' + Math.floor( Math.random()*1000)})\r\n    }\r\n  }\r\n})需要注意的是，加上 pure : true 之后就是纯组件，组件的 data 不会被合并到全局的 store.data 上。组件区分业务组件和纯组件，他们的区别如下：业务组件与业务数据紧耦合，换一个项目可能该组件就用不上，除非非常类似的项目业务组件通过 store 获得所需参数，通过更改 store 与外界通讯业务组件也可以通过 props 获得所需参数，通过 triggerEvent 与外界通讯纯组件与业务数据无关，可移植和复用纯组件只能通过 props 获得所需参数，通过 triggerEvent 与外界通讯大型项目一定会包含纯组件、业务组件。通过纯组件，可以很好理解单向数据流。小程序插件小程序插件是对一组 JS 接口、自定义组件或页面的封装，用于嵌入到小程序中使用。插件不能独立运行，必须嵌入在其他小程序中才能被用户使用；而第三方小程序在使用插件时，也无法看到插件的代码。因此，插件适合用来封装自己的功能或服务，提供给第三方小程序进行展示和使用。插件开发者可以像开发小程序一样编写一个插件并上传代码，在插件发布之后，其他小程序方可调用。小程序平台会托管插件代码，其他小程序调用时，上传的插件代码会随小程序一起下载运行。插件开发者文档插件使用者文档插件开发Westore 提供的目录如下:|--components\r\n|--westore  \r\n|--plugin.json  \r\n|--store.js创建插件:import create from '../../westore/create-plugin'\r\nimport store from '../../store'\r\n\r\n//最外层容器节点需要传入 store，其他组件不传 store\r\ncreate(store, {\r\n  properties:{\r\n    authKey:{\r\n      type: String,\r\n      value: ''\r\n    }\r\n  },\r\n  data: { list: [] },\r\n  attached: function () {\r\n    // 可以得到插件上声明传递过来的属性值\r\n    console.log(this.properties.authKey)\r\n    // 监听所有变化\r\n    this.store.onChange = (detail) => {\r\n      this.triggerEvent('listChange', detail)\r\n    }\r\n    // 可以在这里发起网络请求获取插件的数据\r\n    this.store.data.list = [{\r\n      name: '电视',\r\n      price: 1000\r\n    }, {\r\n      name: '电脑',\r\n      price: 4000\r\n    }, {\r\n      name: '手机',\r\n      price: 3000\r\n    }]\r\n\r\n    this.update()\r\n\r\n    //同样也直接和兼容 setData 语法\r\n    this.update(\r\n        { 'list[2].price': 100000 }\r\n    )\r\n  }\r\n})在你的小程序中使用组件：<list auth-key=\"{{authKey}}\" bind:listChange=\"onListChange\" />这里来梳理下小程序自定义组件插件怎么和使用它的小程序通讯:通过 properties 传入更新插件，通过 properties 的 observer 来更新插件通过 store.onChange 收集 data 的所有变更通过 triggerEvent 来抛事件给使用插件外部的小程序这么方便简洁还不赶紧试试 Westore插件开发模板 ！特别强调插件内所有组件公用的 store 和插件外小程序的 store 是相互隔离的。原理页面生命周期函数组件生命周期函数由于开发插件时候的组件没有 this.page，所以 store 是从根组件注入，而且可以在 attached 提前注入:export default function create(store, option) {\r\n    let opt = store\r\n    if (option) {\r\n        opt = option\r\n        originData = JSON.parse(JSON.stringify(store.data))\r\n        globalStore = store\r\n        globalStore.instances = []\r\n        create.store = globalStore\r\n    }\r\n\r\n    const attached = opt.attached\r\n    opt.attached = function () {\r\n        this.store = globalStore\r\n        this.store.data = Object.assign(globalStore.data, opt.data)\r\n        this.setData.call(this, this.store.data)\r\n        globalStore.instances.push(this)\r\n        rewriteUpdate(this)\r\n        attached && attached.call(this)\r\n    }\r\n    Component(opt)\r\n}总结组件 - 对 WXML、WXSS 和 JS 的封装，与业务耦合，可复用，难移植纯组件 - 对 WXML、WXSS 和 JS 的封装，与业务解耦，可复用，易移植插件 - 小程序插件是对一组 JS 接口、自定义组件或页面的封装，与业务耦合，可复用Star & Fork 小程序解决方案https://github.com/dntzhang/westoreLicenseMIT @dntzhang"}
{"title": "Serverless实战驾校小程序【考题练习】二 ", "author": "Rolan", "pub_time": "2018-10-11 00:32", "content": "准备工作做完后，今天我们从核心模块，分类与题目练习开始做。由于开发时间比较紧，这里主要写实习思路，与核心代码。image.png页面一、首页这里我们主要优先实现功能逻辑，UI后面调整，我们用iview 拖一个大致结构的页面。这里用了以下组件{  \"usingComponents\": {    \"i-tab-bar\": \"../../dist/tab-bar/index\",    \"i-tab-bar-item\": \"../../dist/tab-bar-item/index\",    \"i-grid\": \"../../dist/grid/index\",    \"i-grid-item\": \"../../dist/grid-item/index\",    \"i-grid-icon\": \"../../dist/grid-icon/index\",    \"i-grid-label\": \"../../dist/grid-label/index\",    \"i-tabs\": \"../../dist/tabs/index\",    \"i-tab\": \"../../dist/tab/index\"  }}页面二、专项练习页面这个页面，我们从数据库里取出数据，首先建立好数据表，这个表结构昨天有讲。我们导入一个CSV格式数据到表里CSV文件内容bSubjects,title 1,时间题 1,速度题 1,距离题 1,罚款题 1,记分题 1,标志题 1,标线题 1,手势题 1,信号灯 1,灯光题 1,仪表题 1,装置题 1,路况题 1,酒驾题 1,动画题 1,情景题 然后我们取出这里的数据，在小程序里面显示核心代码// 库文件const getQuestionTypeList=()=>{    return new Promise((resolve, reject) => {      const query = wx.Bmob.Query('questionType');      query.find().then(res => {          console.log(res)          resolve(res)      }).catch(err=>{        console.error(err)        reject(err)      })    });}// 页面js文件wechatApp-questions2/pages/topic/index.jsonLoad(e){    wx.u.getQuestionTypeList().then(r=>{      console.log(r,`k`)      this.setData({        result:r      })    })  },  // wxml文件  <i-panel title=\"题型列表\" hide-top>    <!-- <view style=\"padding: 15px;\">头部距离为 0 的 Panel</view> -->    <i-row>        <i-col wx:for=\"{{result}}\" span=\"12\" i-class=\"col-class\">            <i-panel bindtap=\"handleTabClick\" data-id=\"{{item.objectId}}\" class=\"cell-panel-demo\" title=\"\">                <i-cell title=\"{{item.title}}\" value=\"\">                     <i-icon type=\"enterinto\" slot=\"icon\" />                </i-cell>            </i-panel>        </i-col>    </i-row></i-panel>首页点击到分类，分类点击到题目页面，下一个是题目页面，这个页面是整个项目的核心， 所以的题目都在这个页面进行计算，判断。页面三、答题页面 这个页面会是最复杂的一个页面， 涉及到，计时，判断、记录历史等等操作。之前只想到模拟考试，没考虑到这种按照顺序练习， 第二次进入，可以继续之前的题目练习。 这里建个学习表，记录他的顺序练习相关数据，以下是数据表暂定的结构学习表 learning第一步：还是一样，用iview 复制出对应组件第二步：查询出此类别的题目， 并且默认显示一道题，点击下一题，显示数组下一个元素第三步：先做单选题，点击选择，判断是否正确， 如果正确，记录到结果对象 [{\" id \":\" XXX ', '0'}, {\" id \":\" XXX \", \"1\"}] ，0代表回答错误，1正确第四步：点击下一题计算进度条位置，判断当前是否选择了题目，否则提示请选择结果。目前做到这个一步，明天继续。作者：微信小程序开发 链接：https://www.jianshu.com/p/19283a793c60 來源：简书 简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。"}
{"title": "io.Reader游标引发的血案 ", "author": "Rolan", "pub_time": "2018-10-12 00:05", "content": "背景线上运行了一个图片合成程序，默认的小程序二维码中奖是小程序LOGO，不满足需求，所以将微信小程序二维码和用户头像合成在一张图片。由于微信图片有时候返回的Content-Type不对应（比如内容是PNG的，头确是image/jpeg）所以使用jpeg/png/gif的顺序进行图片数据解析，哪个成功就返回解析结果。问题总是出现诸如 invalid JPEG format: missing SOI marker解决过程我去查看jpeg.Decode的源码，如下：func (d *decoder) decode(r io.Reader, configOnly bool) (image.Image, error) {\r\n    d.r = r\r\n\r\n    // Check for the Start Of Image marker.\r\n    if err := d.readFull(d.tmp[:2]); err != nil {\r\n        return nil, err\r\n    }\r\n    if d.tmp[0] != 0xff || d.tmp[1] != soiMarker {\r\n        return nil, FormatError(\"missing SOI marker\")\r\n    }\r\n...soiMarker常量soiMarker  = 0xd8 // Start Of Image.可以看到判断了第1个字节如果不是 0xff 或者第2个字节不是 0xd8 就报错。打印图片的bytes前几个字节如下：[]byte{0xff, 0xd8, 0xff, 0xe0, 0x0, 0x10}可以看到第1个字节和第2个字节满足要求，按理说不会出现这个问题，无奈只能求助于Google,搜索了invalid JPEG format: missing SOI marker 关键字出现一篇 Covert base64 string to JPG 引起了我的注意。打开看到答案You need to create a new reader for each decoder:pngI, errPng := png.Decode(bytes.NewReader(unbased))\r\n\r\n// ...\r\n\r\njpgI, errJpg := jpeg.Decode(bytes.NewReader(unbased))原来需要重新创建读取器，重新创建读取器后问题解决。后续抱着打破砂锅问到底的心态，查看了一下 bytes.Reader 的源码，发现游标读取完后并未重置// Read implements the io.Reader interface.\r\nfunc (r *Reader) Read(b []byte) (n int, err error) {\r\n    if r.i >= int64(len(r.s)) {\r\n        return 0, io.EOF\r\n    }\r\n    r.prevRune = -1\r\n    n = copy(b, r.s[r.i:])\r\n    r.i += int64(n)\r\n    return\r\n}Reader定义type Reader struct {\r\n    s        []byte\r\n    i        int64 // current reading index\r\n    prevRune int   // index of previous rune; or < 0\r\n}可以看到 r.i 就是游标了。问题圆满解决"}
{"title": "小程序构建骨架屏的探索 ", "author": "Rolan", "pub_time": "2018-9-18 00:12", "content": "首屏一般情况下，在首屏数据未拿到之前，为了提升用户的体验，会在页面上展示一个loading的图层，类似下面这个其中除了菊花图以外网上还流传这各种各样的loading动画，在PC端上几乎要统一江湖了，不过最近在移动端上面看到不同于菊花图的加载方式，就是这篇文章需要分享的Skeleton Screen，中文称之为\"骨架屏\"概念A skeleton screen is essentially a blank version of a page into which information is gradually loaded.在H5中，骨架屏其实已经不是什么新奇的概念了，网上也有各种方案生成对应的骨架屏，包括我们经常使用的知乎、饿了么、美团等APP都有应用骨架屏这个概念图片来源网络，侵删方案先从H5生成骨架屏方案开始说起，总的来说H5生成骨架屏的方案有2种完全靠手写HTML和CSS方式给每个页面定制一套骨架屏利用预渲染的方式生成静态骨架屏第一套方案，毫无疑问是最简单最直白的方式，缺点也很明显，假如页面布局有修改的话，那么除了修改业务代码之外还需要额外修改骨架屏，增加了维护的成本。第二套方案，一定程度上改善了第一套方案带来的维护成本增加的缺点，主要还是使用工具预渲染页面，获取到DOM节点和样式，保留页面结构，覆盖样式，生成灰色块盖在原有文本、图片或者是canvas等节点上面，最后将生成的HTML和CSS打包出来，就是一个带有骨架屏的页面。最后再利用webpack工具将生成的骨架屏插入到HTML里面，详细的话可以看看饿了么的分享，这里就不多描述了。调研了下H5生成骨架屏的方案，对于小程序生成骨架屏的方案也有了一个大致的想法，主要有2个难点需要实现预渲染获取节点预渲染再说回饿了么提供的骨架屏的方案，使用 puppeteer 渲染页面（或者使用服务端渲染，vue或者react都有提供相应的方案），拿到DOM节点和样式，这里有一点需要注意的是，页面的渲染是需要初始化的数据，数据的来源可以是初始化的data（vue）或者mock数据，当然小程序是无法直接使用 puppeteer 来做预渲染（有另外的方案可以实现），需要利用小程序初始化的 data + template 渲染之后得到一个初始化结构作为骨架屏的结构//index.js\r\nPage({\r\n    data: {\r\n        motto: 'Hello World',\r\n        userInfo: {\r\n            avatarUrl: 'https://wx.qlogo.cn/mmopen/vi_32/SYiaiba5faeraYBoQCWdsBX4hSjFKiawzhIpnXjejDtjmiaFqMqhIlRBqR7IVdbKE51npeF6X1cXxtDQD2bzehgqMA/132',\r\n            nickName: 'jay'\r\n        },\r\n        lists: [\r\n            'aslkdnoakjbsnfkajbfk',\r\n            'qwrwfhbfdvndgndghndeghsdfh',\r\n            'qweqwtefhfhgmjfgjdfghaefdhsdfgdfh',\r\n        ],\r\n        showSkeleton: true\r\n    },\r\n    onLoad: function () {\r\n        const that = this;\r\n        setTimeout(() => {\r\n            that.setData({\r\n                showSkeleton: false\r\n            })\r\n        }, 3000)\r\n    }\r\n})\r\n\r\n//index.wxml\r\n<view class=\"container\">\r\n    <view class=\"userinfo\">\r\n        <block>\r\n            <image class=\"userinfo-avatar skeleton-radius\" src=\"{{userInfo.avatarUrl}}\"\r\n                   mode=\"cover\"></image>\r\n            <text class=\"userinfo-nickname skeleton-rect\">{{userInfo.nickName}}</text>\r\n        </block>\r\n    </view>\r\n    <view style=\"margin: 20px 0\">\r\n        <view wx:for=\"{{lists}}\" class=\"lists\">\r\n            <icon type=\"success\" size=\"20\" class=\"list skeleton-radius\"/>\r\n            <text class=\"skeleton-rect\">{{item}}</text>\r\n        </view>\r\n    </view>\r\n\r\n    <view class=\"usermotto\">\r\n        <text class=\"user-motto skeleton-rect\">{{motto}}</text>\r\n    </view>\r\n\r\n    <view style=\"margin-top: 200px;\">\r\n        aaaaaaaaaaa\r\n    </view>\r\n</view>有了上面的 data + template 之后，就有了一个初始化的页面结构，接下来就需要拿到节点信息节点小程序基础库1.4.0之后小程序基础库提供了一组新的API，可用于获取节点信息，具体API戳这里。跟H5方式一样，根据class或者id获取节点信息，不同的是只能获取到当前的节点信息，无法获取到其父或者子节点信息，所以只能手动给需要渲染骨架屏的节点添加相应的class或者id<view class=\"container\">\r\n    <view class=\"userinfo\">\r\n        <block>\r\n            <image class=\"userinfo-avatar skeleton-radius\" src=\"{{userInfo.avatarUrl}}\"\r\n                   mode=\"cover\"></image>\r\n            <text class=\"userinfo-nickname skeleton-rect\">{{userInfo.nickName}}</text>\r\n        </block>\r\n    </view>\r\n    <view style=\"margin: 20px 0\">\r\n        <view wx:for=\"{{lists}}\" class=\"lists\">\r\n            <icon type=\"success\" size=\"20\" class=\"list skeleton-radius\"/>\r\n            <text class=\"skeleton-rect\">{{item}}</text>\r\n        </view>\r\n    </view>\r\n\r\n    <view class=\"usermotto\">\r\n        <text class=\"user-motto skeleton-rect\">{{motto}}</text>\r\n    </view>\r\n\r\n    <view style=\"margin-top: 200px;\">\r\n        aaaaaaaaaaa\r\n    </view>\r\n</view>约定2个特殊的class作为获取节点信息的标记skeleton-rect和skeleton-radius，在页面中获取相应的top、left、width、height进行骨架屏的绘制结果具体的调用方式和源码，请看 github ，最后求start总结上文有说到小程序也可以使用 page-skeleton-webpack-plugin 方式一样生成骨架屏，最重要的一点就是需要将小程序跑在chrome上面，后面的流程就一样了，至于怎么将小程序跑在chrome上面呢？可以利用 wept ，缺点就是目前作者已经停止维护这个工具了，不支持新版小程序的API。说回来我这个生成骨架屏的方案，其实跟 page-skeleton-webpack-plugin 有点相似，不同的是，page-skeleton-webpack-plugin 采用离线渲染的方式生成静态骨架屏插入路由中，而我采用运行时先渲染页面默认结构，然后根据默认结构再绘制骨架屏。从性能角度出发确实不如 page-skeleton-webpack-plugin，但是也差不了多少了，主要还是小程序并没有提供类似服务端渲染的方案。目前从使用上来讲，还是有点小麻烦，需要默认数据撑开页面结构，需要给相应的节点添加class，后面有时间再研究下有没有更好的方案吧~~~"}
{"title": "微信小程序评论/留言功能，附：前端+后端代码+视频讲解！ ", "author": "Rolan", "pub_time": "2018-9-18 00:27", "content": "前端界面：演示：<!-- 表单 -->\r\n<form bindsubmit=\"formSubmit\">\r\n<input type=\"text\" name=\"liuyantext\" placeholder='输入留言内容' class=\"input-style\"/>\r\n<button formType=\"submit\" class=\"btn\" wx:if=\"{{nickName == empty}}\" open-type=\"getUserInfo\" bindgetuserinfo=\"bindGetUserInfo\" bindtap='login'>授权登录</button>\r\n<button formType=\"submit\" class=\"btn\" wx:else>留言</button>\r\n<input type=\"text\" name=\"nickname\" value='{{nickName}}' style=\"display:none;\"/>\r\n<input type=\"text\" name=\"headimg\" value='{{avatarUrl}}' style=\"display:none;\"/>\r\n</form>\r\n\r\n<view wx:for=\"{{re}}\" wx:key=\"re\">\r\n  <view class=\"result\">{{item.result}}</view>\r\n</view>\r\n<view style=\"text-align:center;font-size:14px;color:#ccc;margin-top:20px;\">以下是留言内容</view>\r\n<view wx:for=\"{{liuyanlist}}\" wx:key=\"liuyanlist\" class=\"liuyanview\">\r\n  <view class=\"headimg\"><image src=\"{{item.headimg}}\"></image></view>\r\n  <view class=\"nickname_liuyantext\">\r\n    <view class=\"nickname\">{{item.nickname}} <view class=\"time\">{{item.lytime}}</view></view>\r\n    <view class=\"text\">{{item.liuyantext}}</view>\r\n  </view>\r\n  <!-- 占位符 -->\r\n  <view style=\"width:100%;height:10px;\"></view>\r\n</view>\r\n//index.js\r\n//获取应用实例\r\nconst app = getApp()\r\nPage({\r\n  /**\r\n   * 页面的初始数据\r\n   */\r\n  data: {\r\n    \r\n  },\r\n\r\n  //授权登录\r\n  login: function () {\r\n    var that = this;\r\n    // 查看是否授权\r\n    wx.getSetting({\r\n      success(res) {\r\n        if (res.authSetting['scope.userInfo']) {\r\n          // 已经授权，可以直接调用 getUserInfo 获取头像昵称\r\n          wx.getUserInfo({\r\n            success: function (res) {\r\n              console.log(res.userInfo),\r\n                that.setData({\r\n                  nickName: res.userInfo.nickName,\r\n                  avatarUrl: res.userInfo.avatarUrl,\r\n                })\r\n            }\r\n          })\r\n        }\r\n      }\r\n    })\r\n  },\r\n  bindGetUserInfo(e) {\r\n    console.log(e.detail.userInfo)\r\n  },\r\n\r\n\r\n  formSubmit: function (e) {\r\n    wx.showToast({\r\n      title: '已留言',\r\n      icon: 'success'\r\n    })\r\n    var that = this;\r\n    var liuyantext = e.detail.value.liuyantext; //获取表单所有name=liuyantext的值 \r\n    var nickName = e.detail.value.nickname; //获取表单所有name=nickName的值 \r\n    var headimg = e.detail.value.headimg; //获取表单所有name=headimg的值 \r\n    wx.request({\r\n      url: 'http://localhost/liuyanserver/liuyan.php?liuyantext=' + liuyantext + '&nickname=' + nickName + '&headimg=' + headimg,\r\n      data: {\r\n        liuyantext,\r\n        nickName,\r\n        headimg\r\n      },\r\n      header: { 'Content-Type': 'application/json' },\r\n      success: function (res) {\r\n        console.log(res.data)\r\n        that.setData({\r\n          re: res.data,\r\n        })\r\n        wx.hideToast();\r\n      }\r\n    })\r\n  },\r\n\r\n  onPullDownRefresh: function () {\r\n    wx.showNavigationBarLoading();\r\n    var that = this\r\n    wx.request({\r\n      url: 'http://localhost/liuyanserver/loadliuyan.php',\r\n      headers: {\r\n        'Content-Type': 'application/json'\r\n      },\r\n      success: function (res) {\r\n        //将获取到的json数据，存在名字叫list的这个数组中\r\n        that.setData({\r\n          liuyanlist: res.data,\r\n          //res代表success函数的事件对，data是固定的，liuyanlist是数组\r\n        })\r\n        // 隐藏导航栏加载框\r\n        wx.hideNavigationBarLoading();\r\n        // 停止下拉动作\r\n        wx.stopPullDownRefresh();\r\n      }\r\n    })\r\n  },\r\n\r\n  //加载最新数据\r\n  onLoad: function () {\r\n    var that = this\r\n    wx.request({\r\n      url: 'http://localhost/liuyanserver/loadliuyan.php',\r\n      headers: {\r\n        'Content-Type': 'application/json'\r\n      },\r\n      success: function (res) {\r\n        //将获取到的json数据，存在名字叫list的这个数组中\r\n        that.setData({\r\n          liuyanlist: res.data,\r\n          //res代表success函数的事件对，data是固定的，liuyanlist是数组\r\n        })\r\n      }\r\n    })\r\n  }\r\n})/**index.wxss**/\r\n.input-style{\r\n  width: 90%;\r\n  height: 50px;\r\n  border:1px solid #ccc;\r\n  margin:10px auto;\r\n}\r\n\r\n.btn{\r\n  width: 88%;\r\n  margin:5px auto;\r\n}\r\n\r\n.liuyanview{\r\n  width: 90%;\r\n  margin: 10px auto;\r\n}\r\n\r\n.result{\r\n  text-align: center;\r\n  font-size: 14px;\r\n  color: #f00;\r\n  margin-top: 20px;\r\n}\r\n\r\n.headimg{\r\n  width: 45px;\r\n  height: 45px;\r\n  border-radius: 100%;\r\n}\r\n\r\n.headimg image{\r\n  width: 45px;\r\n  height: 45px;\r\n  border-radius: 100%;\r\n}\r\n\r\n.nickname_liuyantext{\r\n  width: calc(100% - 55px);\r\n  float: right;\r\n  margin-top:-45px;\r\n}\r\n\r\n.nickname_liuyantext .nickname{\r\n  font-size: 15px;\r\n  color: #999;\r\n}\r\n\r\n.nickname_liuyantext .nickname .time{\r\n  font-size: 11px;\r\n  color: #999;\r\n  float: right;\r\n}\r\n\r\n.nickname_liuyantext .text{\r\n  font-size: 16px;\r\n  color: #666;\r\n}以上是前端部分后端有两个文件。点击下载后端，后端需要修改自己的数据库配置！http://www.youka.la/product/5...数据库格式：视频:https://www.lanzous.com/i1w1deb"}
{"title": "在微信小程序中渲染HTML内容 ", "author": "Rolan", "pub_time": "2018-9-18 00:36", "content": "大部分Web应用的富文本内容都是以HTML字符串的形式存储的，通过HTML文档去展示HTML内容自然没有问题。但是，在微信小程序（下文简称为「小程序」）中，应当如何渲染这部分内容呢？解决方案wxParse小程序刚上线那会儿，是无法直接渲染HTML内容的，于是就诞生了一个叫做「 wxParse 」的库。它的原理就是把HTML代码解析成树结构的数据，再通过小程序的模板把该数据渲染出来。rich-text后来，小程序增加了「rich-text」组件用于展示富文本内容。然而，这个组件存在一个极大的限制： 组件内屏蔽了所有节点的事件 。也就是说，在该组件内，连「预览图片」这样一个简单的功能都无法实现。web-view再后来，小程序允许通过「web-view」组件嵌套网页，通过网页展示HTML内容是兼容性最好的解决方案了。然而，因为要多加载一个页面，性能是较差的。当「WePY」遇上「wxParse」基于用户体验和功能交互上的考虑，我们抛弃了「rich-text」和「web-view」这两个原生组件，选择了「wxParse」。然而，用着用着却发现，「wxParse」也不能很好地满足需要：我们的小程序是基于「WePY」框架开发的，而「wxParse」是基于原生的小程序编写的。要想让两者兼容，必须修改「wxParse」的源代码。「wxParse」只是简单地通过image组件对原img元素的图片进行显示和预览。而在实际使用中，可能会用到云存储的接口对图片进行缩小，达到「 用小图显示，用原图预览 」的目的。「wxParse」直接使用小程序的video组件展示视频，但是video组件的 层级问题 经常导致UI异常（例如把某个固定定位的元素给挡了）。此外，围观一下「wxParse」的代码仓库可以发现，它已经两年没有迭代了。所以就萌生了基于「WePY」的组件模式重新写一个富文本组件的想法，其成果就是「WePY HTML」项目。实现过程解析HTML首先仍然是要把HTML字符串解析为树结构的数据，我采用的是「特殊字符分隔法」。HTML中的特殊字符是「<」和「>」，前者为开始符，后者为结束符。如果待解析内容以开始符开头，则截取 开始符到结束符之间 的内容作为节点进行解析。如果待解析内容不以开始符开头，则截取 开头到开始符之前 （如果开始符不存在，则为末尾）的内容作为纯文本解析。剩余内容进入下一轮解析，直到无剩余内容为止。正如下图所示：为了形成树结构，解析过程中要维护一个上下文节点（默认为根节点）：如果截取出来的内容是开始标签，则根据匹配出的标签名和属性，在当前上下文节点下创建一个子节点。如果该标签不是自结束标签（br、img等），就把上下文节点设为新节点。如果截取出来的内容是结束标签，则根据标签名关闭当前上下文节点（把上下文节点设为其父节点）。如果是纯文本，则在当前上下文节点下创建一个文本节点，上下文节点不变。过程正如下面的表格所示：经过上述流程，HTML字符串就被解析为节点树了。对比把上述算法与其他类似的解析算法进行对比（性能以「解析10000长度的HTML代码」进行测定）：可见，在不考虑容错性（产生错误的结果，而非抛出异常）的情况下，本组件的算法与其余两者相比有压倒性的优势，符合小程序「 小而快 」的需要。而一般情况下，富文本编辑器所生成的代码也不会出现语法错误。因此，即使容错性较差，问题也不大（但这是需要改进的）。模板渲染树结构的渲染，必然会涉及到子节点的 递归 处理。然而，小程序的模板并不支持递归，这下仿佛掉入了一个大坑。看了一下「wxParse」模板的实现，它采用简单粗暴的方式解决这个问题：通过13个长得几乎一模一样的模板进行嵌套调用（1调用2，2调用3，……，12调用13），也就是说最多可以支持12次嵌套。一般来说，这个深度也足够了。由于「WePY」框架本身是有构建机制的，所以不必手写十来个几乎一模一样的模板，通过一个构建的插件去生成即可。以下为需要重复嵌套的模板（精简过），在其代码的开始前和结束后分别插入特殊注释进行标识，并在需要嵌入下一层模板的地方以另一段特殊注释（「<!-- next template -->」）标识：<!-- wepyhtml-repeat start -->\r\n<template name=\"wepyhtml-0\">\r\n\t<block wx:if=\"{{ content }}\" wx:for=\"{{ content }}\">\r\n\t\t<block wx:if=\"{{ item.type === 'node' }}\">\r\n\t\t\t<view class=\"wepyhtml-tag-{{ item.name }}\">\r\n\t\t\t\t<!-- next template -->\r\n\t\t\t</view>\r\n\t\t</block>\r\n\t\t<block wx:else>{{ item.text }}</block>\r\n\t</block>\r\n</template>\r\n<!-- wepyhtml-repeat end -->以下是对应的构建代码（需要安装「 wepy-plugin-replace 」）：// wepy.config.js\r\n{\r\n\tplugins: {\r\n\t\treplace: {\r\n\t\t\tfilter: /\\.wxml$/,\r\n\t\t\tconfig: {\r\n\t\t\t\tfind: /<\\!-- wepyhtml-repeat start -->([\\W\\w]+?)<\\!-- wepyhtml-repeat end -->/,\r\n\t\t\t\treplace(match, tpl) {\r\n\t\t\t\t\tlet result = '';\r\n\t\t\t\t\t// 反正不要钱，直接写个20层嵌套\r\n\t\t\t\t\tfor (let i = 0; i <= 20; i++) {\r\n\t\t\t\t\t\tresult += '\\n' + tpl\r\n\t\t\t\t\t\t\t.replace('wepyhtml-0', 'wepyhtml-' + i)\r\n\t\t\t\t\t\t\t.replace(/<\\!-- next template -->/g, () => {\r\n\t\t\t\t\t\t\t\treturn i === 20 ?\r\n\t\t\t\t\t\t\t\t\t'' :\r\n\t\t\t\t\t\t\t\t\t`<template is=\"wepyhtml-${ i + 1 }\" wx:if=\"{{ item.children }}\" data=\"{{ content: item.children\"></template>`;\r\n\t\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn result;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}然而，运行起来后发现，第二层及更深层级的节点都没有渲染出来，说明嵌套失败了。再看一下dist目录下生成的wxml文件可以发现，变量名与组件源代码的并不相同：<block wx:if=\"{{ $htmlContent$wepyHtml$content }}\" wx:for=\"{{ $htmlContent$wepyHtml$content }}\">「WePY」在生成组件代码时，为了避免组件数据与页面数据的变量名冲突，会 根据一定的规则给组件的变量名增加前缀 （如上面代码中的「$htmlContent$wepyHtml$」）。所以在生成嵌套模板时，也必须使用带前缀的变量名。先在组件代码中增加一个变量「thisIsMe」用于识别前缀：<!-- wepyhtml-repeat start -->\r\n<template name=\"wepyhtml-0\">\r\n\t{{ thisIsMe }}\r\n\t<block wx:if=\"{{ content }}\" wx:for=\"{{ content }}\">\r\n\t\t<block wx:if=\"{{ item.type === 'node' }}\">\r\n\t\t\t<view class=\"wepyhtml-tag-{{ item.name }}\">\r\n\t\t\t\t<!-- next template -->\r\n\t\t\t</view>\r\n\t\t</block>\r\n\t\t<block wx:else>{{ item.text }}</block>\r\n\t</block>\r\n</template>\r\n<!-- wepyhtml-repeat end -->然后修改构建代码：replace(match, tpl) {\r\n\tlet result = '';\r\n\tlet prefix = '';\r\n\r\n    // 匹配 thisIsMe 的前缀\r\n\ttpl = tpl.replace(/\\{\\{\\s*(\\$.*?\\$)thisIsMe\\s*\\}\\}/, (match, p) => {\r\n\t\tprefix = p;\r\n\t\treturn '';\r\n\t});\r\n\r\n\tfor (let i = 0; i <= 20; i++) {\r\n\t\tresult += '\\n' + tpl\r\n\t\t\t.replace('wepyhtml-0', 'wepyhtml-' + i)\r\n\t\t\t.replace(/<\\!-- next template -->/g, () => {\r\n\t\t\t\treturn i === 20 ?\r\n\t\t\t\t\t'' :\r\n\t\t\t\t\t`<template is=\"wepyhtml-${ i + 1 }\" wx:if=\"{{ item.children }}\" data=\"{{ ${ prefix }content: item.children }}\"></template>`;\r\n\t\t\t});\r\n\t}\r\n\r\n\treturn result;\r\n}至此，渲染问题就解决了。图片为了节省流量和提高加载速度，展示富文本内容时，一般都会按照所需尺寸对里面的图片进行缩小，点击小图进行预览时才展示原图。这主要涉及节点属性的修改：把图片原路径（src属性值）存到自定义属性（例如「data-src」）中，并将其添加到预览图数组。把图片的src属性值修改为缩小后的图片URL（一般云服务商都有提供此类URL规则）。点击图片时，使用自定义属性的值进行预览。为了实现这个需求，本组件在解析节点时提供了一个钩子（ onNodeCreate ）：onNodeCreate(name, attrs) {\r\n\tif (name === 'img') {\r\n\t\tattrs['data-src'] = attrs.src;\r\n\t\t// 预览图数组\r\n\t\tthis.previewImgs.push(attrs.src);\r\n\t\t// 缩图\r\n\t\tattrs.src = resizeImg(attrs.src, 640);\r\n\t}\r\n}对应的模板和事件处理逻辑如下：<template name=\"wepyhtml-img\">\r\n\t<image class=\"wepyhtml-tag-img\" mode=\"widthFix\" src=\"{{ elem.attrs.src }}\" data-src=\"{{ elem.attrs['data-src'] || elem.attrs.src }}\" @tap=\"imgTap\"></image>\r\n</template>// 点击小图看大图\r\nimgTap(e) {\r\n\twepy.previewImage({\r\n\t\tcurrent: e.currentTarget.dataset.src,\r\n\t\turls: this.previewImgs\r\n\t});\r\n}视频在小程序中，video组件的层级是较高的（且无法降低）。如果页面设计上存在着可能挡住视频的元素，处理起来就需要一些技巧了：隐藏video组件，用image组件（视频封面）占位；点击图片时，让视频全屏播放；如果退出了全屏，则暂停播放。相关代码如下：<template name=\"wepyhtml-video\">\r\n\t<view class=\"wepyhtml-tag-video\" @tap=\"videoTap\" data-nodeid=\"{{ elem.nodeId }}\">\r\n\t\t<!-- 视频封面 -->\r\n\t\t<image class=\"wepyhtml-tag-img wepyhtml-tag-video__poster\" mode=\"widthFix\" src=\"{{ elem.attrs.poster }}\"></image>\r\n\t\t<!-- 播放图标 -->\r\n\t\t<image class=\"wepyhtml-tag-img wepyhtml-tag-video__play\" src=\"./imgs/icon-play.png\"></image>\r\n\t\t<!-- 视频组件 -->\r\n\t\t<video style=\"display: none;\" src=\"{{ elem.attrs.src }}\" id=\"wepyhtml-video-{{ elem.nodeId }}\" @fullscreenchange=\"videoFullscreenChange\" @play=\"videoPlay\"></video>\r\n\t</view>\r\n</template>{\r\n\t// 点击封面图，播放视频\r\n\tvideoTap(e) {\r\n\t\tconst nodeId = e.currentTarget.dataset.nodeid;\r\n\t\tconst context = wepy.createVideoContext('wepyhtml-video-' + nodeId);\r\n\t\tcontext.play();\r\n\t\t// 在安卓微信下，如果视频不可见，则调用play()也无法播放\r\n\t\t// 需要再调用全屏方法\r\n\t\tif (wepy.getSystemInfoSync().platform === 'android') {\r\n\t\t\tcontext.requestFullScreen();\r\n\t\t}\r\n\t},\r\n\t// 视频层级较高，为防止遮挡其他特殊定位元素，造成界面异常，\r\n\t// 强制全屏播放\r\n\tvideoPlay(e) {\r\n\t\twepy.createVideoContext(e.currentTarget.id).requestFullScreen();\r\n\t},\r\n\t// 退出全屏则暂停\r\n\tvideoFullscreenChange(e) {\r\n\t\tif (!e.detail.fullScreen) {\r\n\t\t\twepy.createVideoContext(e.currentTarget.id).pause();\r\n\t\t}\r\n\t}\r\n}开源最后贴一下「WePY HTML」的项目仓库： https://github.com/beiliao-web-frontend/wepy-html ，具体使用方法见项目内的 README 。如果你在使用过程中遇到了问题，或者是有好的建议和意见，都可以在 Issues 中提出。"}
{"title": "小程序无限层级路由方案 ", "author": "Rolan", "pub_time": "2018-9-19 00:21", "content": "小程序无限层级路由方案小程序原生页面存在层级限制，超过一定层数就会无法打开新页面。一开始这个限制为不超过5层，目前是不超过10层。这个限制对于体量较大的小程序来说，挺难受的。特别是只能打开5层那会儿，业务流程很容易一不小心就超了，比如：首页-搜索结果页-商品详情页-聊天页-下单页-地址选择页-...；更有访问回路防不胜防，比如：商品详情页-查看更多页-商品详情页-查看更多页-...、商品详情页-聊天页-个人主页-商品详情页-聊天页-个人主页-商品详情页-...、诸如此类。即使后来放宽至了10层，还是很容易遭遇层级溢出。一种处理思路是调整交互路径，严格控制层级数量。但是这种处理方案，一则很多时候会牺牲用户体验，比如为避免个人主页和商品详情页的访问回路，要么不能在个人主页中访问用户商品，要么不能在商品详情页中访问卖家主页，要么访问时需要替换当前不能返回继续浏览，不管怎么取舍都会牺牲某些用户的浏览诉求；二则维护成本特别高，业务逻辑越来越复杂，交互路径越来越发散，路径的统一梳理和规划就会越来越困难，而且管理过程对业务不透明，业务方在设计需求时要受到交互路径的种种限制，甚至一个需求的交互调整很可能无意中造成另一个需求层级溢出，维护成本高且不断膨胀。因而本文考虑并实现了另一种处理思路：在小程序中支持不限层级的路由过程。策略修改小程序默认导航行为，自行维护完整历史记录页面层级小于等于10时，导航行为与原生导航行为一致请求打开第11层及以上时，逻辑层级记录完整历史，实际层级每次都是直接将第10层替换为目标页面返回时，逻辑层级相应回退；若回退后逻辑层级大于等于10，则实际层级将第10层替换为目标页面，否则实际层级回退到相应页面demo:  逻辑层级 1 - 2 - ... - 8 - 9 - 10\r\n  实际层级 1 - 2 - ... - 8 - 9 - 10\r\n  \r\n  打开\r\n  \r\n  逻辑层级 1 - 2 - ... - 8 - 9 - 10 - 11\r\n  实际层级 1 - 2 - ... - 8 - 9 - 11\r\n  \r\n  打开，打开，打开\r\n  \r\n  逻辑层级 1 - 2 - ... - 8 - 9 - 10 - 11 - 12 - 13 - 14\r\n  实际层级 1 - 2 - ... - 8 - 9 - 14\r\n  \r\n  返回\r\n  \r\n  逻辑层级 1 - 2 - ... - 8 - 9 - 10 - 11 - 12 - 13\r\n  实际层级 1 - 2 - ... - 8 - 9 - 13\r\n  \r\n  返回，返回，返回\r\n  \r\n  逻辑层级 1 - 2 - ... - 8 - 9 - 10\r\n  实际层级 1 - 2 - ... - 8 - 9 - 10\r\n  \r\n  返回\r\n  \r\n  逻辑层级 1 - 2 - ... - 8 - 9\r\n  实际层级 1 - 2 - ... - 8 - 9实现转转 实现了上述策略，并提供开源使用，地址：https://github.com/zhuanzhuanfe/fancy-mini，欢迎使用或参阅。主要难点及实现方案：如何接管路由过程要求所有页面不使用<navigator>元素，统一使用js触发跳转要求所有页面不直接调用wx.navigateTo、wx.redirectTo等路由相关接口，统一改用模块封装的相应接口如何监听返回行为统一监听页面的onUnload函数，结合路由过程判断是否用户返回如何兼容系统交互问题：系统交互会跳出正常路由流程，并且难以接管或监控，如：用户点击右上角返回主页按钮、用户切后台后又从其它入口进入、用户强制关闭小程序进程等处理：引入校正机制，在合适的时机根据系统路由栈对自行维护的路由栈进行校正。这样可以保证10层以内路由正确性。系统交互多是回到第1层，会被成功校正。如何避免/兼容代码疏漏问题：接管&监听过程要求所有页面遵循一些编码约束，如何保证这些约束切实全面生效；万一有页面未遵循约束，能否依然保证健壮性处理1：编写并配置相应eslint规则，保证约束被切实遵循处理2：上一条中的校正机制，保证即使有代码疏漏，在10层内也会被校正；10层外可能会影响返回逻辑正确性，但一般不会造成页面功能问题。如何进行状态恢复问题：返回后逻辑层级大于等于10时，实际是在第10层重新载入目标页面；用户在前一页面的表单输入等状态信息并不会像系统返回一样正常保留处理：在合适的时机存储页面的data，返回时予以恢复成本接入成本需要引入并配置路由模块需要检查并修改项目中所有页面跳转过程，统一使用模块封装的接口需要统一监听所有页面的onUnload函数维护成本新增页面跳转过程，需统一使用模块封装的接口新增页面onUnload函数需接入统一监听性能成本模块执行逻辑相对简单，内存开销相对较小，页面性能暂未发现明显损耗收益无限层级避免复杂/循环访问导致页面无法打开可以放心地向用户提供适合的访问入口，不必过分担心路径限制完全的路由管控能力可以完全监控路由过程并实现或引入一些附加功能附加功能：实例覆盖自动恢复问题：wepy框架存在单实例问题，同一路径页面被打开两次时，其数据会相互影响，如：详情页A - 详情页B - 返回A，点击查看大图 - B的图片（而不是A的图片）  详见issue：[两级页面为同一路由时，后者数据覆盖前者](https://github.com/Tencent/wepy/issues/322)\r\n  - 策略：返回时，若判断目标页面数据已被覆盖，则自动予以恢复\r\n  - 引入：参见模块使用说明附加功能： 免并发- 问题：用户连续快速点击多个/多次按钮时，会一次性打开多个窗口，一则造成层级膨胀，二则影响浏览体验\r\n- 策略：第一次点击造成的跳转完成之前无视后续点击产生的跳转请求\r\n- 引入：参见模块使用说明附加功能：数据预先加载- 问题：小程序的page1跳转到page2，到page2的onLoad是存在一个300ms ~ 400ms的延时的，在page2的onLoad中才开始获取数据会浪费这个延时\r\n- 策略：在 page1 中预先拿取数据，然后在 page2 中直接使用数据；wepy框架对此有良好的实现，参见[WePY 在小程序性能调优上做出的探究](https://segmentfault.com/a/1190000008975448?winzoom=1) \r\n- 引入：参见模块使用说明\r\n效果无限层级路由方案已在 转转二手交易网 小程序中应用了很长一段时间，欢迎体验：无限层级路由方案已被抽离封装成独立开源模块，欢迎直接使用：https://github.com/zhuanzhuanfe/fancy-mini"}
{"title": "WePY - 小程序敏捷开发实践丨掘金开发者大会 ", "author": "Rolan", "pub_time": "2018-9-20 00:14", "content": "本主题虽然在其它地方讲了很多次，但还是有非常多新内容。因为很多东西正在做或者想要做。本次分享主要分为以下几个部分：WePY 的介绍WePY 的用户上面展示的 WePY 用户不是全部的数据。因为没有办法让 WePY 用户主动上报自己在使用 WePY，所以我只列了我知道的在使用 WePY 的公司，数据比较有限。就我所知道的，最近有一个刷爆朋友圈的小程序 —— 腾讯疫苗，前端采用的 WePY，后端用了腾讯开源的 TARS 项目。微信支付内部也有大量小程序在使用 WePY 框架。右边贴的聊天记录是我在 WePY 交流群收集到的用户反馈，就反馈的内容来看，有很多感谢的话，说明 WePY 这个框架确实能帮助开发者提高自己的开发效率。嘿嘿，我没有贴 WePY 的负面反馈，因为我担心一页 PPT 不够贴 :eyes:。WePY 的数据WePY 项目在 Github 上现在有13900多个 Star。拿其它前端框架对比，Vue、React 等 Star 数可能达到了 10W+，但是它们都是国际的项目。WePY 这个项目由于微信小程序的原因，算是一个国内项目，能有13000多个 Star 还是相当不错的。Star 数多不一定代表 WePY 这个框架好，但是能表明小程序这块流量很大，开发小程序也非常有前景。 开发者们需要 WePY 这样的框架来提供帮助。这也是为什么后来出现了 Taro、mpvue 等类似的非常优秀的框架。issues 目前有1300多个。这意味着我每天起床都有超过10条 to-do list 需要处理。加上每天还有公司的其它事情需要处理，比较头大。pull requests 目前有320多条。相比其它开源项目，这个 PR 数量相当不错，非常感谢为 WePY 作贡献的开发者们。用户数有4000多。这个数据的来源我是统计的我建立的 WePY 交流群，目前这个交流群里有 4000 多人。WePY 是什么将 Web App 和小程序进行对比。Web App 和小程序在功能上类似， Web App 在开发的时候，可能使用 Vue.js 作为其核心库，用 Webpack 进行打包。在微信小程序中，大家可以简单的将 WePY 理解为 Web App 里的 Vue.js + Webpack 的合体。WePY 的特点WePY 在开发中到底帮助开发者做了什么事情呢？WePY 又有哪些特点呢？脚手架：它提供了一个相当于 vue-cli 的脚手架，一行命令生成简单的 demo 项目。用户可以基于这个 demo 进行开发，省去了启动项目前繁琐的配置。编译打包：原生开发小程序缺失了许多能力，比如 LESS、SASS。很多用户面对这个问题都是做一个简单的 Gulp 编译。WePY 自带了编译打包能力，想用 LESS、SASS、NPM 等可以直接使用 WePY 的打包工具输出小程序可以运行的代码。核心库：核心库类似 Vue、React 等。WePY 核心库包含一些简单的 API 封装帮助处理一些事情。特性与优化：开发上，WePY 提供了一些语法糖，可以简单方便的实现一些复杂功能。性能上，小程序本身的性能有一些问题，WePY 把性能上的问题抹平了，开发者不用关心性能这部分。复用与扩展：复用方面，原生小程序使用 npm 资源需要将相对应的资源下载并放到代码目录中，利用 WePY 可以直接安装 npm 包并使用。扩展方面，在编译过程中，可以随意添加和扩展编译手段，比如 LESS、SASS、编译插件等。多端：利用 WePY 可以将一份代码运行在小程序、H5 等端。WePY 的规划16年8月参加小程序内测，10月份开始着手代码转换相关的工作。在不停的迭代中，我发现还有很多事情可以做。比如可以将相关的工作抽象出来提供给其它开发者。于是在11月我对代码进行了重构，将 Gulp 编译部分抛弃重写并于 Github 开源1.1版本。开源之后有很多人关注到这个项目，说明还是有不少人遇到了相应的问题。因此我做了更加具体的优化，在1.1版本上又一次重构，把编译流程抽象，提出了编译器和插件两个概念，方便用户进行扩展。17年1月份发布1.4版本，对整个开发流程和开发者使用框架时的体验进行了更多优化，包括性能优化等。1.6 版本开始考虑多端问题：小程序一套代码多端复用。17年11月左右，小程序推出了原生组件。WePY 本身就是为了解决小程序组件的问题，原生组件发布之后，WePY 的使用场景就没有以前那么强了，所以我开始思考， WePY 需要做一个完全重构的版本。18年2月份启动了该重构版本，这个版本主要是为了解决小程序原生组件相关的问题，是一个全新的重构版本。但由于各种原因，这个版本还没有正式公布。敬请期待！WePY 的实现原理接下来我会讲一下 WePY 在技术上的实现原理。WePY 解决的问题任何一个项目都是发现问题，解决问题的过程，WePY 要解决的问题就是：组件化开发：小程序原生组件出现之前，小程序没有很好的组件化开发模式。比如我自己实现了一套 dialog，别人想使用的时候可能要把我的代码拷贝一份。实现了组件化之后，我只要把这个组件给他就好了。npm 资源：Web 发展至今，npm 库上有非常庞大的资源。但是原生小程序没有使用 npm 资源的能力，WePY 提供了这个功能。前端工程化：前面提及的打包构建部分性能优化友好的开发体验：体验优化跨平台支持：多端这部分总的来说，WePY 解决的问题就是开发中遇到的痛点问题。WePY 的架构上面是我写的两个核心的部分：CLI 以及 Core。Core 通过 CLI 编译，生成小程序端运行的代码。CLI 部分又分为 wepy、wepy-web ，分别负责 wepy 的编译和 wepy-web 的编译。其上又分为编译器和插件两部分，编译器涉及到目前主流的预处理器，类似 Webpack 的 loader 。插件是在编译之后要做的事情，类似于 Webpack 的 plugin。Core 部分分为 wepy 核心库、小程序核心库和 wepy-web 核心库。wepy-web 核心库比小程序多了 wepy components 和 wepy API 。小程序本身的一些内置组件，比如弹窗组件，想要多端运行都需要封装起来放在 wepy components 。小程序原生 API 需要通过 wepy API 封装。web 本身还分很多平台种类，比如 browser、微信 h5、QQ h5，这些都需要分别适配，所以 wepy-web 之上是一个适配层。整个 Core 之上，是用户封装的一些组件，比如上报、异步。还有一些功能组件，比如用户做的弹窗、toast、imageloader 等。纵观整个 WePY，我的代码会通过 CLI 基于 Core 输出小程序端运行的代码。WePY 的编译过程WePY 本身定义了一个文件后缀 .wpy 。编译时将该文件解析并拆分为 Style、Template、Script。拆分时，会解析并记录组件关系，包括事件、引用等。每个节点的信息都会被记录，在注入时生成到 JS 中，在 JS 中就可以知道组件关系并进行调用。生成完之后进入到 plugin，plugin 是用户自定义的，需要进行图片压缩、JS 混淆、wxml 压缩等处理。依次做完这些处理之后才会得到可以在小程序中运行的代码。以上就是 WePY 的整个编译过程。多端的实现在实现多端方面，面临着以下问题：开发模式小程序开发模式自成一派，与现有开发模式都不相同。好在使用 WePY 开发时，WePY 使用的是类 Vue 的开发语法，跟 Vue 开发模式很贴近，所以开发模式问题借助 WePY 非常好解决。标签与样式小程序与 H5 的标签不一样，但是可以直接做一些简单的转换处理。比如 <view> 转换为 <div> 。样式上小程序有一个 rpx 单位，在 750 px 的情况下直接 /2 将 rpx 转为 px。模版语法小程序有自己的模版语法，比如 <wx-if> 等，解析时可以做简单的转换。模块化小程序原生可以使用 require ,但是H5不可以。好在有很多工具值得借鉴，比如 webpack,browserify。内置组件及内置 APIWePY 本身使用的是类 Vue 的语法，要转换为 Vue 运行在 Web 端的话，内置组件直接使用 Vue 的形式编写，使用时直接引入这个 Vue 组件。内置 API 使用 WePY 提供的 JSSDK 去模拟微信端、H5等提供的 API。因此，多端实现完全可行。我们的一些项目完全利用 WePY 实现多端。生态左边是在 Github 上看到的一些 UI 库，大家在使用 WePY 开发的时候可以直接利用这些 UI 库进行二次开发。右边是网上收集到的开发资源，包括开发组件、第三方模块等。Github 上 WePY 关键字搜索结果有900多页。从用户反馈来看，用户选择 WePY 的一个原因也是 WePY 诞生的时间长，生态比较完善。WePY 的规划现有问题WePY 目前存在的核心问题是静态组件编译WePY 项目做的比较仓促，花了大概一个多月就上线了。最开始只是为了解决组件化的问题。因此它采用了静态组件编译这套方案，在编译组件时，直接将我写的组件进行静态替换，将我写的组件注入到页面中，做了一些隔离相关的事情。这导致动态 repeat 时会出现比较严重的 BUG。这是设计上的缺陷，也是急需解决的问题。语法解析xml 的解析用了一个存在问题的库，导致 xml 解析时经常出错。js 的解析设计之初没有考虑用语法树解析，而是使用正则进行解析。因为目前仅涉及解析和语法注入，实现起来都比较简单，所以没有考虑用 AST 语法树进行解析，导致用户没有按照规范写的一些代码在解析时会出现错误。类 Vue 语法从用户的反馈来看，大家更希望用 Vue 的语法而不是类 Vue 语法。这两个之间还是有一些差异的。数据绑定性能优化数据绑定时做了一些优化和处理。但这些优化和处理是通过脏数据进行的，帮助用户减少 setDate 的次数。但是后来再看，这块还是有可以优化的空间。错误处理机制目前 WePY 的错误处理还比较简单，没有一个通用的错误处理机制。用户在使用和编译时的报错很难追溯和定位。后面希望能做到在报错时可以定位到报错的文件和代码。测试用例覆盖度WePY 目前只有核心库被测试用例覆盖。CLI 部分很复杂没有做测试用例覆盖。这导致目前大部分问题都和 CLI 相关。在下一个版本要全部被测试用例覆盖。编译上图是2.0版本编译部分的对比。左边是 1.0 的编译，右边是2.0正在做的事。前面有讲到1.0的编译是把.wpy 文件放到 CLI 中进行编译。CLI 本身涉及编译器和插件。在2.0中，将文件编译修改为了入口编译，从 App 入口，通过 CLI 自动解析依赖，CLI 中也只有插件，所有的核心功能都将通过插件实现。最后生成的除了小程序文件，还有 Vendor 文件（Vendor 文件是指所有的 npm 包都会打包到这个文件内）、资源文件以及自己引用的模块的文件。插件化编译的核心部分是参考 Webpack 做的插件化编译。插件化的概念参考我上面做的图：固定一块板子，板子上有固定数量的挂钩，每个挂钩都可以挂不同的东西。每个挂钩放什么不清楚，但是每个挂钩都可以实现不同的功能。我只需要规定编译的流程，通过在挂钩中写不同的内容实现整个编译流程。所以整个编译过程变为：配置初始化:arrow_right:核心编译:arrow_right:输出文件。插件化可以提供更高的扩展性和可复用性。所有的核心功能都依赖插件进行。用户觉得某个功能不合适的时候，完全可以自己写一个插件替换掉核心功能。用户可以对编译的任何一个环节进行修改。数据绑定v1v1 的数据绑定：在初始化的时候对数据进行深拷贝做数据备份。每个流程都会预置 apply 动作，比如有一个点击事件，点击事件对数据进行修改后进入到 apply 流程，在 apply 流程中进行深比较得到脏数据，脏数据最终进入到 setDate 中。右边是比较简单易懂的图：小明对文件 B 进行修改得到 B+,老师将 B+ 和 B 进行对比，得到修改的数据。这是一个同步流程。当小明叫小红修改 C 文件时，如果老师不再，需要小红主动叫老师对 C 文件进行对比。即手动调用 apply 流程。数据绑定v22.0 使用了 Vue 的数据绑定机制。在初始化时生成 Render Watcher，每个数据初始化时都会添加 observer。修改数据时记录修改的 key-path 并加入队列中，所有的修改动作都会触发 Watcher。在一个 nextTick 时间内会清空队列，并在 Render Watcher 中进行 setDate。setDate 环节根据记录的 key-path 进行 setDate。相比小明和老师的故事：小明在修改文件时会主动记录修改的内容并发起通知，小红的操作方式与小明一致。当老师收到通知时，根据小明、小红的修改记录对修改的内容进行 setDate 的处理。这种优化方式不需要手动调用 apply,也不需要关心异步流程。质量第二个版本会先在内部项目运用，内部实践之后没有问题再开源。另外2.0版本测试用例覆盖度要完全覆盖。开源经验分享规范如何保证开源项目的质量？第一是文档规范。Readme 部分要言简意赅的讲明这个项目能做什么，一个简单的示例说明如何启动项目。Readme 要简洁，大家一眼能看到他想要的东西。第二是 CI。将对应的状态放在 Readme，让开发者可以更安心的使用这个项目。第三是 license。还有 contributer 文档，代码规范、Git 规范等。测试使用了 Mocha 和 Istanbul，集成使用了 TravisCI，部署使用了 npm 和 lerna。推广运营推广运营方面主要靠自己发文章，做外链。另外我在公众号和微信群推了自己的文章。微信群做了一个机器人放入群码。还做了文档监控，官方文档修改之后，我可以第一时间知道官方文档都修改了什么。以及监控报告，每天都会给我的微信推送今天项目有多少 star 、多少 issue 。"}
{"title": "使用Taro框架开发小程序 ", "author": "Rolan", "pub_time": "2018-9-20 00:27", "content": "最近一直在做小程序项目的开发，上手直接就是wepy, 风格跟vue差不多，整体上，还算稳定，开发起来比原生的效率要高一点；很多人也知道，mpvue就是用vue搭建的，但始终觉得，失去了路由的vue，就像失去了灵魂；虽然接下来要给大家安利的框架，也貌似失去了该灵魂- taro框架（ Taro 是一套遵循React 语法规范的 多端开发 解决方案。）taro开发文档： nervjs.github.io/taro/docs/R…有兴趣的可以去看看，在这里我将我初步入坑的学习过程，以及构建了大致矿建与大家分享下：一：安装 Taro 开发工具 @tarojs/clinpm install -g @tarojs/cli\r\n复制代码二：使用命令创建模板项目taro init taro-react-mini-program\r\n复制代码可以根据自己的需要，选择是否使用ts, sass或者less, 接着等安装好依赖，项目就构建完成；三：项目目录结构├── dist                   编译结果目录\r\n├── config                 配置目录\r\n|   ├── dev.js             开发时配置\r\n|   ├── index.js           默认配置\r\n|   └── prod.js            打包时配置\r\n├── src                    源码目录\r\n|   ├── pages              页面文件目录\r\n|   |   ├── index          index页面目录\r\n|   |   |   ├── index.js   index页面逻辑\r\n|   |   |   └── index.css  index页面样式\r\n|   ├── app.css            项目总通用样式\r\n|   └── app.js             项目入口文件\r\n└── package.json\r\n复制代码框架的使用和注意事项，文档中有介绍，我这边主要写一些项目配置和踩过的坑;这里需要先安装一些依赖npm install tslint stylelint tslint-config-prettier -D\r\n复制代码代码规范 .prettierrc{\r\n    \"stylelintIntegration\": true,\r\n    \"tslintIntegration\": true,\r\n    \"tabWidth\": 2,\r\n    \"singleQuote\": true,\r\n    \"semi\": false\r\n}\r\n复制代码.prettierignore/**/libs/**\r\ndist/\r\nlib/\r\n复制代码样式规范： .stylelintrc.jsmodule.exports = {\r\n  ignoreFiles: ['**/*.md', '**/*.ts', '**/*.tsx', '**/*.js']\r\n}\r\n复制代码.stylelintignore**/dist\r\n复制代码tslint.json{\r\n  \"extends\": [\"tslint:recommended\", \"tslint-config-prettier\"],\r\n  \"rules\": {\r\n    \"ordered-imports\": false,\r\n    \"object-literal-sort-keys\": false,\r\n    \"member-access\": false,\r\n    \"member-ordering\": false,\r\n    \"no-empty-interface\": false,\r\n    \"no-console\": [true, \"warning\"],\r\n    \"interface-name\": [true, \"never-prefix\"],\r\n    \"no-empty\": false,\r\n    \"quotemark\": [true, \"single\"]\r\n    // \"semicolon\": [false], // 结尾比较分号\r\n    // \"trailing-comma\": [false], // 结尾必须逗号\r\n    // \"requireForBlockBody\": true,\r\n  }\r\n}\r\n复制代码接着配置git的提交commit提交验证，需要安装对应的依赖包，可以从我的另外一篇文章看：juejin.im/post/5b9867…再加上自己配置一个.gitignore文件，就这样，我们将大致需要的配置文件都配置好了；看看效果：当有不规范的代码提交的时候把所有问题都解决之后提交，当然tslint以及其他的一些配置都是自定义的，可以自己配置。觉得麻烦的可以根据自己的“口味”配置项目然后我们就可以愉快的开发我们的项目，运行npm run dev:weapp,打开我们的小程序很多人反馈用原生的 Taro.request或者用第三方axios等等做异步请求总会有错，我没亲测，但是自己用promise封装了方法, 在根目录src文件夹下创建utils文件夹， 在这里我简单的模拟微信授权登录，以及检测session是否过期，绑定用户的场景写一个大概例子，接口为虚构：├── utils                 \r\n|   ├── api.ts            请求接口设置\r\n|   ├── http.ts           http公共请求文件\r\n|   └── index.ts          \r\n\r\n复制代码http.ts代码如下：import Taro from '@tarojs/taro'\r\nimport md5 from 'blueimp-md5'\r\n\r\ntype HttpMethods = 'GET' | 'POST' | 'PUT' | 'DELETE'\r\n\r\n// 后端是否支持json格式\r\nconst contentType = 'application/x-www-form-urlencoded'\r\n// const contentType = 'application/json'\r\n\r\nexport default class Http {\r\n  noNeedToken = ['mockFakeApi']\r\n\r\n  get(url: string, data: object) {\r\n    return this.commonHttp('GET', url, data)\r\n  }\r\n\r\n  post(url: string, data: object) {\r\n    return this.commonHttp('POST', url, data)\r\n  }\r\n\r\n  async commonHttp(method: HttpMethods, url: string, data: object) {\r\n    return new Promise<any>(async (resolve, reject) => {\r\n      Taro.showNavigationBarLoading()\r\n      try {\r\n        const res = await Taro.request({\r\n          url,\r\n          method,\r\n          data,\r\n          header: {\r\n            'content-type': contentType\r\n          }\r\n        })\r\n        Taro.hideNavigationBarLoading()\r\n        switch (res.statusCode) {\r\n          case 200:\r\n            return resolve(res.data.response)\r\n          default:\r\n            console.log(res.data.message)\r\n            reject(new Error(res.data.msg))\r\n        }\r\n      } catch (error) {\r\n        Taro.hideNavigationBarLoading()\r\n        reject(new Error('网络请求出错'))\r\n      }\r\n    })\r\n  }\r\n}\r\n\r\n复制代码api.tsimport Http from './http'\r\n\r\nconst http = new Http()\r\n\r\n//  自动登录\r\nconst url = 'xxxxx'\r\nexport const login = (data: object) => http.post(url, data)\r\n\r\n复制代码index.ts (自定义公共处理接口文件)import Taro from '@tarojs/taro'\r\nimport { login } from './api'\r\n\r\n// 获取微信登录凭证\r\nexport const wxLogin = async () => {\r\n  try {\r\n    const res = await Taro.login()\r\n    return res.code\r\n  } catch (error) {\r\n    console.log('微信获取临时凭着失败')\r\n  }\r\n}\r\n\r\nexport const userLogin = async () => {\r\n  try {\r\n    await Taro.checkSession()\r\n    if (!Taro.getStorageSync('token')) {\r\n      throw new Error('本地没有缓存token')\r\n    }\r\n  } catch (error) {\r\n    const code = await wxLogin()\r\n    const loginRes: any = await login({\r\n      code\r\n      // ...(其他参数)\r\n    })\r\n    console.log('用户数据', loginRes)\r\n  }\r\n}\r\n\r\n复制代码最后在pages/index/index.tsx中引用就好了import { userLogin } from '../../utils/index'\r\n\r\n....\r\n\r\nasync componentDidMount() {\r\n    await userLogin()\r\n  }\r\n复制代码整个框架的使用大致就是这样了，react的书法风格还是挺舒服的，如果习惯了vue的写法可能刚开始会不习惯，有兴趣的可以尝试尝试，下面再简单的把一些小技巧给补上：一：图片以模块的方式的引入使用ts搭建的项目，引入静态资源，比如图片，会提示找不到模块，这时候就必须将图片声明为一个模块：在types目录的global.d.ts文件下:declare module ‘*.png’ {​ const img: any​ export default img}二：动态添加style<View style={{backgroundImage: `url(${bgImg})`}}></View>\r\n复制代码三：动态添加class1.<View className={data.length>0?’class-yes’: ’class-no'}></View>\r\n\r\n2.<View className={`common ${data.length>0?’class-yes’: ’class-no}`}></View>\r\n复制代码四：this的指向问题1）在 Taro 的页面和组件类中， this 指向的是 Taro 页面或组件的实例,如果我们要引用原生组件，需要使用到this的时候，如果如下引用：Taro.createCanvasContext(canvasId, this.$scope)\r\nwx.createLivePlayerContext(liveId, this.$scope)\r\n错误：wx.createLivePlayerContext(liveId, this)这样引入是没有效果的，this并不是指向 wx.createLivePlayerContext.(当前版本没有liveplayer的回调方法，所以直接用原生wx)"}
{"title": "微信小程序onLaunch异步，首页onLoad先执行? ", "author": "Rolan", "pub_time": "2018-9-20 00:32", "content": "本来按照事件顺序，小程序初始化时触发App里的onLaunch，后面再执行页面Page里的onLoad，但是在onLaunch里请求获取是否有权限，等待返回值的时候Page里的onLoad事件就已经执行了。//app.jsApp({  onLaunch: function () {    console.log('onLaunch');    wx.request({      url: 'test.php', //仅为示例，并非真实的接口地址      data: {      },      success: function(res) {        console.log('onLaunch-request-success');        // 将employId赋值给全局变量，提供给页面做判断        this.globalData.employId = res.employId;         }    })  },  globalData: {    employId: ''  }})//index.js//获取应用实例const app = getApp()Page({  data: {    albumDisabled: true,    bindDisabled: false  },  onLoad: function () {    console.log('onLoad');    console.log('onLoad app.globalData.employId = ' + app.globalData.employId);    //判断是用户是否绑定了    if (app.globalData.employId && app.globalData.employId != '') {      this.setData({        albumDisabled: false,        bindDisabled: true      });  }})控制台打印的结果是onLaunchonLoadonLoad app.globalData.employId = onLaunch-request-success要是能等完onLaunch请求完再执行Page的onLoad方法那该多好。 这里采用的方法是定义一个回调函数。 Page页面判断一下当前app.globalData.employId是否有值，如果没有（第一次）则定义定义一个app方法（回调函数）app.employIdCallback = employId => {...}。 App页面在请求success后判断时候有Page页面定义的回调方法，如果有就执行该方法。因为回调函数是在Page里面定义的所以方法作用域this是指向Page页面。//app.jsApp({  onLaunch: function () {    wx.request({      url: 'test.php', //仅为示例，并非真实的接口地址      data: {      },      success: function(res) {        this.globalData.employId = res.employId;        //由于这里是网络请求，可能会在 Page.onLoad 之后才返回        // 所以此处加入 callback 以防止这种情况        if (this.employIdCallback){           this.employIdCallback(res.employId);        }      }    })  },  globalData: {    employId: ''  }})//index.js//获取应用实例const app = getApp()Page({  data: {    albumDisabled: true,    bindDisabled: false  },  onLoad: function () {    //判断是用户是否绑定了    if (app.globalData.employId && app.globalData.employId != '') {      this.setData({        albumDisabled: false,        bindDisabled: true      });    } else {      // 由于 getUserInfo 是网络请求，可能会在 Page.onLoad 之后才返回      // 所以此处加入 callback 以防止这种情况      app.employIdCallback = employId => {        if (employId != '') {          this.setData({            albumDisabled: false,            bindDisabled: true          });        }      }    }  }})这样的话，就能实现想要的结果。执行顺序就是：[App] onLaunch -> [Page] onLoad -> [App] onLaunch sucess callback作者：mipaifu328 链接：https://www.jianshu.com/p/aaf65625fc9d"}
{"title": "小程序挖坑之路 ", "author": "Rolan", "pub_time": "2018-9-21 00:05", "content": "小程序出来那么久一直没有深入的开发，这次借着公司要做小程序，深入探索了一番，结果挖坑无数，当然，仅限挖坑，并没有填完。哈哈，就先mark一下。因为公司业务需求，这次小程序用的是 mpvue + typescript 进行开发。mpvue 相关的坑关于 input 问题因为设计想把输入框的交互做成这个样子：那用原生的输入框是满足不了的，只能自己写组件咯。那么就用vue的方式写了个组件，结果发现， mpvue 关于 input 的问题还真不少。input 用v-modal输入时候闪烁组件嵌套slot有问题input 不支持:type 和v-modalslot等标签不支持添加class，无法编译成wxss嵌套组件，props有问题修改slot时，不能热更新，只能重新npm run dev这是github上相关的issue：inout闪烁issue嵌套组件slot问题11嵌套组件slot问题222关于这个问题，试了上述的解决方法，但没有很好的解决（摔）。所以，自己用原生的方式重新撸了个组件。小程序相关的坑原生组件 canvas 问题因为公司因为，小程序里有不少的图表数据需要展现，自然就是需要用到 cavas ，而 canvas是属于原生组件，它的 z-index 无限大，一出现有弹窗内容需要把它覆盖就gg。实际上是能解决的，只要使用 cover-view 当做遮罩层（一开始我还以为，需要把 cover-view嵌套到原生组件的节点里），把弹窗内容一并放入 cover-view 里，但是很鸡肋的是， cover-view 里面包含的节点问题，以及一些样式问题是没办法实现。如果是弹窗内容很酷炫的话，那我只能建议让设计改设计稿。<view>\r\n    <canvas canvas-id=\"test\"></canvas>\r\n    // 这是一个遮罩层，为了覆盖住原生组件（ 1.9.0及以上才支持 ）\r\n    <cover-view>\r\n        这是一个遮罩层balabala\r\n    </cover-view>\r\n    \r\n    // 官方给的demo\r\n    <video>\r\n        <cover-view>\r\n            这里也可以覆盖video里的内容\r\n        </cover-view>\r\n    </video>\r\n<view>\r\n复制代码下面是我遇到的相关bug:文本都要套上 cover-view 标签，不然排版错误。cover-view 里的内容不支持设置 渐变，阴影 等样式。自定义组件嵌套 cover-view 时，自定义组件的 slot 及其父节点暂不支持通过 wx:if 控制显隐，否则会导致 cover-view 不显示canvas 不能放在可滚动的列表里，在页面滑动时，在真机效果下， canvas 不能很好的跟着滚动，会出现刚开始滚动不动，再滚动就会卡着突然消失的非常糟糕的效果cover-image 不支持 bindtouchstart 等touch事件总的来说，小程序的原生组件问题还是很多的，具体的实现都要在真机上测试才能看出各种问题。使用echart-for-wx 的坑解决弹窗覆盖canvas的问题，同样的是用上面的方法解决方法：echart使用 cover-view 是要在节点 ec-canvas 后面添加，通过样式控制 cover-view 的对应位置<ec-canvas class=\"canvas\" id=\"mychart-dom-line\" canvas-id=\"mychart-line\" :ec=\"ecLine\">\r\n</ec-canvas>\r\n<cover-view class=\"cover-view\">cover-vdddddddddddddiew</cover-view>\r\n复制代码echart 在使用 rpx 为单位时，出现机型适配问题echart 在不同机型上适配问题，使用单位为 px 时，适配是没问题的，但是使用 rpx 时，就会出现小机型适配问题，而使用mpvue的话，单位为 px 会转换成 rpx ，就会出现如下问题：实际效果：预期效果：解决方法：在 mpvue 里，使用内联样式（内联样式不会把 px 转成 rpx ），最好只固定高 emmmm....结果发现，大屏小屏手机下都会有适配问题，所以不能单纯的用内联样式写死 px 的大小(在GitHub上提了个issue，至今未回，怕死石沉大海啦)canvas生成图片适配问题因为不同手机大小以及其设备像素比devicePixelRatio不一致，再来小程序还出了自己的单位 rpx ，所以如果生成canvas是固定写死其宽高，这样是用问题的。基本算法是：canvas 绘制使用的是 px 单位，但不同设备的 px 是需要换算的，所以在组件中统一使用rpx单位，这里就涉及到单位怎么换算问题。 通过 wx.getSystemInfoSync 获取设备屏幕尺寸，从而得到比例，进而做转换，代码如下：const sysInfo = wx.getSystemInfoSync();\r\nconst screenWidth = sysInfo.screenWidth;\r\nthis.factor = screenWidth / 750; // 获取比例\r\nfunction toPx(rpx) { // rpx转px\r\n    return rpx * this.factor;\r\n}\r\nfunction toRpx(px) { // px转rpx\r\n    return px / this.factor;\r\n},\r\n复制代码但我知道大家都很懒，有轮子干嘛不用实在不想算，可以用现成的轮子 小程序canvas生成图片再来就是， cavans 转图片的问题需要使用 canvasToTempFile 方法，因为 canvas 节点一定要存在才能获取到 canvas 的上下文进行绘图，所以只能把 canvas 放到页面可视区域之外。而且转换成图片时，要加个神奇的 setTimeout 的延时。最小延时为 300ms ，再小就不管用了。（为什么，我也不知道，o(╥﹏╥)o）最后这只是一点挖坑心得记录而已，还有更多的坑需要继续发掘。"}
{"title": "小程序 lazy-load 不生效的问题 ", "author": "Rolan", "pub_time": "2018-9-21 00:17", "content": "最近在开发家里喵喵的小程序（娱乐），本想抽一小部分时间做个懒加载。看了小程序官网 API，给 image 标签加上 lazy-load 就能实现懒加载。但从微信开发者工具看，似乎并没有生效。搜了一下，很多小伙伴似乎都遇到了问题，并没有解决。但经过我的验证， 懒加载确实是生效了 。只不过， 小程序会提前加载当前屏幕和下一屏的图片，导致感知不到懒加载的存在。个人认为，这样的懒加载比传统懒加载的体验更加好。我的验证过程：验证过程wxml部分（用 scroll-view 并且加上 bindload）：<scroll-view class=\"container\" scroll-y>  \r\n  <view wx:for=\"{{list}}\" class=\"list-item\"> \r\n    <image class=\"list-img\" lazy-load src=\"{{item.img}}\" bindload='onLazyLoad'></image>\r\n    <view>{{item.desc}}</view>\r\n  </view>\r\n</scroll-view>js部分：const app = getApp()  \r\nPage({  \r\n  data: {\r\n    list: []\r\n  },\r\n  onLazyLoad(info) {\r\n    console.log(info)\r\n  }\r\n})最终效果首屏输出日志：清空首屏输出日志后，滑动过程中输出的日志：整张页面一共有 13 张图。因此，确实是进行了懒加载。魁拔喵喵喵最后，介绍下我的小程序：魁拔喵喵喵（已经能搜到啦）。功能目前比较简陋，欢迎交流和意见。"}
{"title": "小程序的全栈开发新时代 ", "author": "Rolan", "pub_time": "2018-9-21 00:26", "content": "什么是小程序·云开发小程序·云开发是微信团队和腾讯云团队共同研发的一套小程序基础能力，简言之就是：云能力将会成为小程序的基础能力。整套功能是基于腾讯云全新推出的云开发(Tencent Cloud Base)所研发出来的一套完备的小程序后台开发方案。小程序·云开发为开发者提供完整的云端流程，简化后端开发和运维概念，无需搭建服务器，使用平台提供的 API 进行核心业务开发，即可实现快速上线和迭代。该解决方案目前提供三大基础能力支持：存储：在小程序前端直接上传/下载云端文件，在小程序云控制台可视化管理数据库：一个既可在小程序前端操作，也能在云函数中读写的文档型数据库云函数：在云端运行的代码，微信私有协议天然鉴权，开发者只需编写业务逻辑代码未来，我们还会集成更多的服务能力，为小程序提供更强有力的云端支持。如何使用小程序·云开发上面就是小程序·云开发简单的使用图谱：在小程序端，直接用官方提供的接口，在云函数端，直接用官方提供的 Node SDK，就可以操作你云的资源。以前开发小程序所担忧的数据库搭建、文件系统部署，通通没有。你只需要有在小程序开发 IDE 里面的 云开发，开通一下，填写环境 ID，便可以拥有小程序的云能力！当然，其实用云开发，并不排斥原有的后台架构，通过下面的架构，你也可以无缝与原有的后台服务兼容，也简化了一些小程序鉴权的逻辑：接下来，我会分别从小程序端、服务端讲述如何使用这些云资源。使用云能力小程序端客户端，这里是指在小程序端中。如果要使用云开发能力，请做以下配置：在 app.json / game.json 中， 中增加字段 \"cloud\": trueproject.config.json 中增加了字段 cloudfunctionRoot 用于指定存放云函数的目录初始化云开发能力：//app.js\r\nApp({\r\n  onLaunch: function () {\r\n    wx.cloud.init({\r\n        traceUser: true // 用户信息会显示在云开发控制台的用户面板中\r\n    });\r\n  }\r\n});\r\n小程序端初始化能力文档在用户管理中会显示使用云能力的小程序的访问用户列表，默认以访问时间倒叙排列，访问时间的触发点是在小程序端调用 wx.cloud.init 方法，且其中的 traceUser 参数传值为 true。服务端如果你想在云函数中，操作文件、数据库和云函数资源，你可以使用我们提供的服务端 SDK 进行操作。首先，进入到你的某个云函数中，安装以下依赖包：npm i --save tcb-admin-node\r\n在云函数中初始化// 初始化示例\r\nconst app = require('tcb-admin-node');\r\n\r\n// 初始化资源\r\n// 云函数下不需要secretId和secretKey。\r\n// env如果不指定将使用默认环境\r\napp.init({\r\n  secretId: 'xxxxx',\r\n  secretKey: 'xxxx', \r\n  env: 'xxx'\r\n});\r\n\r\n//云函数下使用默认环境\r\napp.init()\r\n\r\n//云函数下指定环境\r\napp.init({\r\n  env: 'xxx'\r\n});\r\n服务端初始化文档存储云开发提供存储空间、上传文件、下载文件、CDN加速文件访问等能力,开发者可以在小程序端与服务端通过 API 使用这些能力。小程序端// 选择图片\r\nwx.chooseImage({\r\n    success: dRes => {\r\n        // 上传图片\r\n        const uploadTask = wx.cloud.uploadFile({\r\n            cloudPath: `${Date.now()}-${Math.floor(Math.random(0, 1) * 10000000)}.png`, // 随机图片名\r\n            filePath: dRes.tempFilePaths[0], // 本地的图片路径\r\n            success: console.log,\r\n            fail: console.error\r\n        });\r\n    },\r\n    fail: console.error,\r\n});\r\n小程序端存储文档服务端const app = require('tcb-admin-node');\r\napp.init();\r\n\r\napp.uploadFile({\r\n    cloudPath: \"cover.png\",\r\n    fileContent: fs.createReadStream(`${__dirname}/cover.png`)\r\n}).then((res) => {\r\n    console.log(res);\r\n}).catch((err) => {\r\n    console.error(err);\r\n});;\r\n控制台上传好的文件，就会出现在控制台中，如下图。你可以在控制台里删除、下载或者查看图片的详情。你还可以控文件整体的权限，这里还有一些具体的介绍。服务端存储文档数据库小程序云提供文档型数据库 ( document-oriented database )，数据库包含多个集合（相当于关系型数据中的表），集合近似于一个 JSON 数组，数组中的每个对象就是一条记录，记录的格式是 JSON 文档。每条记录都有一个 _id 字段用以唯一标志这条记录、一个 _openid 字段用以标志记录的创建者，即小程序的用户。开发者可以自定义 _id，但不可在小程序端自定义（在服务端可以） _openid 。_openid 是在文档创建时由系统根据小程序用户默认创建的，开发者可使用其来标识和定位文档。数据库 API 分为小程序端和服务端两部分，小程序端 API 拥有严格的调用权限控制，开发者可在小程序内直接调用 API 进行非敏感数据的操作。对于有更高安全要求的数据，可在云函数内通过服务端 API 进行操作。云函数的环境是与客户端完全隔离的，在云函数上可以私密且安全的操作数据库。数据库 API 包含增删改查的能力，使用 API 操作数据库只需三步：获取数据库引用、构造查询/更新条件、发出请求。切记，在操作数据库前，请先在控制台中创建 collection。小程序端const db = wx.cloud.database();\r\n\r\n// 插入数据\r\ndb.collection('photo').add({\r\n    data: {\r\n        photo: 'cloud://tcb-xxx/05ca1d38f86f90d66d4751a730379dfa6584dde05ab4-Ma9vMN_fw658.jpg',\r\n        title: '风景'\r\n    }\r\n});\r\n\r\n// 提取数据\r\ndb.collection('photo').get().then((res) => {\r\n    let data = res.data;\r\n    console.log(data);\r\n});\r\n\r\n// 输出\r\n// 在小程序端， _openid 会自动插入到数据库中\r\n{\r\n    photo: 'cloud://tcb-xxx/05ca1d38f86f90d66d4751a730379dfa6584dde05ab4-Ma9vMN_fw658.jpg',\r\n    title: '风景',\r\n    _openid: 'oLlMr5FICCQJV-QgVLVzKu1212341'\r\n}\r\n小程序端数据库文档服务端const app = require('tcb-admin-node');\r\napp.init();\r\nconst db = app.database();\r\n\r\ndb.collection('photo').limit(10).get().then((res) => {\r\n    console.log(res);\r\n}).catch((err) => {\r\n    console.error(err);\r\n});\r\n\r\n// 输出\r\n// 因为是在服务端，其它用户的也可以提取出来\r\n{\r\n    photo: 'cloud://tcb-xxx/05ca1d38f86f90d66d4751a730379dfa6584dde05ab4-Ma9vMN_fw658.jpg',\r\n    title: '风景',\r\n    _openid: 'oLlMr5FICCQJV-QgVLVzKu1342121'\r\n}\r\n{\r\n    photo: 'cloud://tcb-xxx/0dc3e66fd6b53641e328e091ccb3b9c4e53874232e6bf-ZxSfee_fw658.jpg',\r\n    title: '美女',\r\n    _openid: 'DFDFEX343xxdf-QgVLVzKu12452121'\r\n}\r\n{\r\n    photo: 'cloud://tcb-xxx/104b27e339bdc93c0da15a47aa546b6e9c0e3359c315-L8Px2Y_fw658.jpg',\r\n    title: '动物',\r\n    _openid: 'DFDFEX343xxdf-QgVLVzKu1342121'\r\n}\r\n服务端数据库文档控制台可以在控制台里，看到用户操作的数据，你也可以自己在控制台上添加、更新或删除数据。如果数据量庞大，可以设置索引提供查询的效率。数据库也可以通过设置权限，管控每个 collection。云函数云函数是一段运行在云端的代码，无需管理服务器，在开发工具内一键上传部署即可运行后端代码。开发者可以在云函数内获取到每次调用的上下文（appid、openid 等），无需维护复杂的鉴权机制，即可获取天然可信任的用户登录态（openid）。小程序端wx.cloud.callFunction({\r\n    name: 'addblog', // 云函数名称\r\n    data: { // 传到云函数处理的参数\r\n        title: '云开发 TCB',\r\n        content: '存储、数据库存、云函数'\r\n    }\r\n}).then(res => {\r\n    console.log(res)\r\n}).catch((err) => {\r\n    console.error(err);\r\n});\r\n小程序端云函数文档服务端const app = require(\"tcb-admin-node\");\r\napp.init();\r\n\r\napp.callFunction({\r\n    name: 'addblog', // 云函数名称\r\n    data: { // 传到云函数处理的参数\r\n        title: '云开发 TCB',\r\n        content: '存储、数据库存、云函数'\r\n    }\r\n}).then((res) => {\r\n    console.log(res);\r\n}).catch((err) => {\r\n    console.error(err);\r\n});\r\n服务端云函数文档控制台上传好之后的云函数，都会在这里罗列出来。每次调用云函数，都可以在这里看到日志，还可以构造测试的参数，用于调试。语法糖大部份的接口，目前都支持两种写法，分别是Promise 和 Async/Await，本节以 callFunction作为例子，在云函数中介绍这两种写法。 Async/Await 本质上是基于 Promise 的一种语法糖，它只是把 Promise 转换成同步的写法而已。Promiseconst app = require(\"tcb-admin-node\");\r\napp.init();\r\n\r\nexports.main = (event, context, callback) => {\r\n    app.callFunction({\r\n        name: 'addblog', // 云函数名称\r\n        data: { // 传到云函数处理的参数\r\n            title: '云开发 TCB',\r\n            content: '存储、数据库存、云函数'\r\n        }\r\n    }).then((res) => {\r\n        console.log(res);\r\n        callback(null, res.data);\r\n    }).catch((err) => {\r\n        callback(err);\r\n    });\r\n};\r\nAsync/Awaitconst app = require(\"tcb-admin-node\");\r\napp.init();\r\n\r\nexports.main = async (event, context) => {\r\n    let result = null;\r\n\r\n    try {\r\n        result = await app.callFunction({\r\n            name: 'addblog', // 云函数名称\r\n            data: { // 传到云函数处理的参数\r\n                title: '云开发 TCB',\r\n                content: '存储、数据库存、云函数'\r\n            }\r\n        });\r\n    }\r\n    catch (e) {\r\n        return e;\r\n    }\r\n\r\n    return result;\r\n};\r\n在云函数里使用，由于是 Node 8.9 或以上的环境，因此天然支持 Async/Await 诘法，但在小程端要使用的话，需要额外引入 Polyfill，比如这个开源的项目：regenerator开发者资源由于小程序·云开发是基于腾讯云的云开发开发的功能，因此在腾讯云与小程序两边都有不少的开发者资源，这里供大家参阅读：腾讯云开发者资源及文档腾讯云云开发平台官方 Github微信小程序·云开发文档"}
{"title": "微信小程序 - 选取搜索地点并且显示（map） ", "author": "Rolan", "pub_time": "2018-9-21 00:38", "content": "演示如下，使用时，你也许会配合它：腾讯地图路线规划wxml:1 <view class='address' bindtap='onChangeAddress'>2   <input class='choose-address' placeholder='请选取地点' value='{{chooseAddress}}'></input>3  </view>wxss:1 .choose-address{2   border: 1px solid #000;3 }js 1 Page({ 2   data: { 3     4   }, 5   //移动选点 6   onChangeAddress: function() { 7     var _page = this; 8     wx.chooseLocation({ 9       success: function(res) {10         _page.setData({11           chooseAddress: res.name12         });13       },14       fail: function(err) {15         console.log(err)16       }17     });18   }19 });"}
{"title": "小程序入口构造工具&二维码测试工具 ", "author": "Rolan", "pub_time": "2018-9-25 00:28", "content": "本文将介绍我们小程序中隐藏的两个工具页面。原理虽不复杂，收益却实实在在，或许也能给诸君带来启发。入口构造工具痛点PM&运营 投放链接 PM&运营每次投放新入口时，都需要找FE要页面链接。投放多少链接就要找FE多少次，一方面相互之间的沟通等待会耗掉不少时间，另一方面询问/回复过程会打断对方手头的工作，影响状态。 关键是大多时候这些链接只是需要改个渠道参数，并不涉及结构上的调整，完全可以由PM/运营自行修改。 然而要向所有PM&运营全面科普url构造规则，并没有想象中容易；各种链接构造需求就这样在无形中不断消耗双方的精力。FE&QA 开发/测试线下功能 开发/测试没有线上入口的新功能时，经常需要构造一个临时入口供以访问。 可以修改线下接口配置运营位作为访问入口，但是一则运营位有限，二则不能一站式操作；也可以修改代码加个临时入口，但是会污染代码，难保不会带到线上。 这样的情形反复出现也是挺麻烦的。idea开发一个专门的入口构造页面，直接提供给PM、运营、FE、QA等各方使用。需要什么链接需要什么入口，直接自助生成，无需一次次反复沟通/构造。效果通用入口构造： 如图所示，在入口构造页面中，用户可以直接输入FE提供的url模板并自助修改链接参数，从而获得所需链接。同时支持：直接打开该链接，进行查看、自测；生成以该链接作为落地链接的分享卡片，从而以落地页的形式打开查看；将该链接复制到剪贴板，供以投放；生成以该链接作为落地链接的二维码，供以投放。内嵌M页入口构造： 如图所示，内嵌M页的小程序链接构造同样支持类似功能。实现需求转译 将链接参数以普通用户能理解的形式展现出来，并允许其直接修改，再配以说明文案。以此抹平url构造规则造成的技术门槛。入口构造 页内入口 直接以按钮跳转实现，外部入口 以分享卡片进行模拟。链接输出 使用wx.setClipboardData接口经由剪贴板粘贴使用。初始入口 生成二维码作为入口构造页面自身的初始入口；将工具页面分享出去，保留分享卡片作为初始入口。意义效率入口构造工具使得PM、运营、FE、QA等各方可以自助、高效地构造所需链接/入口，有效节省了重复沟通成本，并在一定程度上提高了开发、测试、投放效率。质量入口构造工具提供的链接生成功能和预览功能可以在一定程度上避免/发现链接拼接失误等人工疏漏，提高整体交付质量。二维码测试工具痛点扫描二维码时会直接进入线上版小程序，导致在开发/测试阶段难以对二维码相关功能进行有效的检测和把控。 早期只能先冒险上线，然后进行线上验证，万一有问题再修复再重新上线，导致二维码相关功能调试效率低、上线风险高。 后来开发者工具支持通过二维码编译，管理后台也支持回滚，相对来说，二维码相关功能可控性强了很多；但是对于QA、PM、运营、第三方接入业务等小伙伴来说，二维码的检查、测试还是很无力。idea开发一个专门的二维码测试页面，支持在当前开发版/体验版/线上版小程序中对二维码进行查看和预览。效果如图所示，在二维码测试页面中，用户可以：直接查看二维码的编码信息，包括落地链接、参数等；在当前开发版/体验版/线上版小程序中打开二维码落地链接；生成与二维码拥有相同落地链接的当前开发版/体验版/线上版小程序的分享卡片。实现查看二维码信息 使用wx.scanCode接口可以读取二维码信息，包括落地页、参数等。在当前开发版/体验版/线上版中打开二维码 使用wx.scanCode接口获取落地链接，使用wx.navigateTo等接口在当前开发版/体验版/线上版小程序中打开目标页面。在当前开发版/体验版/线上版中以落地页的形式打开二维码 使用wx.scanCode接口获取落地链接，生成相同落地链接的分享卡片，访问分享卡片以模拟开发版/体验版下扫码打开小程序。意义效率 查看二维码信息可以有效提高相关功能调试效率； 直接在当前开发版/体验版中打开二维码可以有效提高相关功能测试效率，特别是对于QA等非前端人员。质量 二维码测试工具便于QA在稳定环境充分测试二维码相关功能，从而提高小程序交付质量。值得一提的是，这两个工具都是FE自发思考自发实现的，产出时小伙伴们表示“很惊喜”。 很多时候，主动去思考、发现、分析、解决痛点，能让你贡献出意料之外的价值，共勉。"}
{"title": "小程序·云开发的云函数路由高级玩法 ", "author": "Rolan", "pub_time": "2018-9-25 00:38", "content": "李成熙，腾讯云高级工程师。2014年度毕业加入腾讯AlloyTeam，先后负责过QQ群、花样直播、腾讯文档等项目。2018年加入腾讯云云开发团队。专注于性能优化、工程化和小程序服务。微博 | 知乎 | Github概念回顾在掘金开发者大会上，在推荐实践那里，我有提到一种云函数的用法，我们可以将相同的一些操作，比如用户管理、支付逻辑，按照业务的相似性，归类到一个云函数里，这样比较方便管理、排查问题以及逻辑的共享。甚至如果你的小程序的后台逻辑不复杂，请求量不是特别大，完全可以在云函数里面做一个单一的微服务，根据路由来处理任务。用下面三幅图可以概括，我们来回顾一下：比如这里就是传统的云函数用法，一个云函数处理一个任务，高度解耦。第二幅架构图就是尝试将请求归类，一个云函数处理某一类的请求，比如有专门负责处理用户的，或者专门处理支付的云函数。最后一幅图显示这里只有一个云函数，云函数里有一个分派任务的路由管理，将不同的任务分配给不同的本地函数处理。tcb-router 介绍及用法为了方便大家试用，咱们腾讯云 Tencent Cloud Base 团队开发了 tcb-router，云函数路由管理库方便大家使用。那具体怎么使用 tcb-router 去实现上面提到的架构呢？下面我会逐一举例子。架构一：一个云函数处理一个任务这种架构下，其实不需要用到 tcb-router，像普通那样写好云函数，然后在小程序端调用就可以了。云函数// 函数 router\r\nexports.main = (event, context) => {\r\n    return {\r\n        code: 0,\r\n        message: 'success'\r\n    };\r\n}；小程序端wx.cloud.callFunction({\r\n      name: 'router',\r\n      data: {\r\n        name: 'tcb',\r\n        company: 'Tencent'\r\n      }\r\n    }).then((res) => {\r\n      console.log(res);\r\n    }).catch((e) => {\r\n      console.log(e);\r\n});架构二： 按请求给云函数归类此类架构就是将相似的请求归类到同一个云函数处理，比如可以分为用户管理、支付等等的云函数。云函数// 函数 user\r\nconst TcbRouter = require('tcb-router');\r\n\r\nexports.main = async (event, context) => {\r\n    const app = new TcbRouter({ event });\r\n    \r\n    app.router('register', async (ctx, next) => {\r\n        await next();\r\n    }, async (ctx, next) => {\r\n        await next();\r\n    }, async (ctx) => {\r\n        ctx.body = {\r\n            code: 0,\r\n            message: 'register success'\r\n        }\r\n    });\r\n\r\n    app.router('login', async (ctx, next) => {\r\n        await next();\r\n    }, async (ctx, next) => {\r\n        await next();\r\n    }, async (ctx) => {\r\n        ctx.body = {\r\n            code: 0,\r\n            message: 'login success'\r\n        }\r\n    });\r\n\r\n    return app.serve();\r\n}；\r\n\r\n// 函数 pay\r\nconst TcbRouter = require('tcb-router');\r\n\r\nexports.main = async (event, context) => {\r\n    const app = new TcbRouter({ event });\r\n    \r\n    app.router('makeOrder', async (ctx, next) => {\r\n        await next();\r\n    }, async (ctx, next) => {\r\n        await next();\r\n    }, async (ctx) => {\r\n        ctx.body = {\r\n            code: 0,\r\n            message: 'make order success'\r\n        }\r\n    });\r\n\r\n    app.router('pay', async (ctx, next) => {\r\n        await next();\r\n    }, async (ctx, next) => {\r\n        await next();\r\n    }, async (ctx) => {\r\n        ctx.body = {\r\n            code: 0,\r\n            message: 'pay success'\r\n        }\r\n    });\r\n\r\n    return app.serve();\r\n}；小程序端// 注册用户\r\nwx.cloud.callFunction({\r\n      name: 'user',\r\n      data: {\r\n        $url: 'register',\r\n        name: 'tcb',\r\n        password: '09876'\r\n      }\r\n    }).then((res) => {\r\n      console.log(res);\r\n    }).catch((e) => {\r\n      console.log(e);\r\n});\r\n\r\n// 下单商品\r\nwx.cloud.callFunction({\r\n      name: 'pay',\r\n      data: {\r\n        $url: 'makeOrder',\r\n        id: 'xxxx',\r\n        amount: '3'\r\n      }\r\n    }).then((res) => {\r\n      console.log(res);\r\n    }).catch((e) => {\r\n      console.log(e);\r\n});架构三： 由一个云函数处理所有服务云函数// 函数 router\r\nconst TcbRouter = require('tcb-router');\r\n\r\nexports.main = async (event, context) => {\r\n    const app = new TcbRouter({ event });\r\n    \r\n    app.router('user/register', async (ctx, next) => {\r\n        await next();\r\n    }, async (ctx, next) => {\r\n        await next();\r\n    }, async (ctx) => {\r\n        ctx.body = {\r\n            code: 0,\r\n            message: 'register success'\r\n        }\r\n    });\r\n\r\n    app.router('user/login', async (ctx, next) => {\r\n        await next();\r\n    }, async (ctx, next) => {\r\n        await next();\r\n    }, async (ctx) => {\r\n        ctx.body = {\r\n            code: 0,\r\n            message: 'login success'\r\n        }\r\n    });\r\n\r\n    app.router('pay/makeOrder', async (ctx, next) => {\r\n        await next();\r\n    }, async (ctx, next) => {\r\n        await next();\r\n    }, async (ctx) => {\r\n        ctx.body = {\r\n            code: 0,\r\n            message: 'make order success'\r\n        }\r\n    });\r\n\r\n    app.router('pay/pay', async (ctx, next) => {\r\n        await next();\r\n    }, async (ctx, next) => {\r\n        await next();\r\n    }, async (ctx) => {\r\n        ctx.body = {\r\n            code: 0,\r\n            message: 'pay success'\r\n        }\r\n    });\r\n\r\n    return app.serve();\r\n}；小程序端// 注册用户\r\nwx.cloud.callFunction({\r\n      name: 'router',\r\n      data: {\r\n        $url: 'user/register',\r\n        name: 'tcb',\r\n        password: '09876'\r\n      }\r\n    }).then((res) => {\r\n      console.log(res);\r\n    }).catch((e) => {\r\n      console.log(e);\r\n});\r\n\r\n// 下单商品\r\nwx.cloud.callFunction({\r\n      name: 'router',\r\n      data: {\r\n        $url: 'pay/makeOrder',\r\n        id: 'xxxx',\r\n        amount: '3'\r\n      }\r\n    }).then((res) => {\r\n      console.log(res);\r\n    }).catch((e) => {\r\n      console.log(e);\r\n});借鉴 Koa2 的中间件机制实现云函数的路由管理小程序·云开发的云函数目前更推荐 async/await 的玩法来处理异步操作，因此这里也参考了同样是基于 async/await 的 Koa2 的中间件实现机制。从上面的一些例子我们可以看出，主要是通过 use 和 router 两种方法传入路由以及相关处理的中间件。use 只能传入一个中间件，路由也只能是字符串，通常用于 use 一些所有路由都得使用的中间件// 不写路由表示该中间件应用于所有的路由\r\napp.use(async (ctx, next) => {\r\n\r\n});\r\n\r\napp.use('router', async (ctx, next) => {\r\n\r\n});router 可以传一个或多个中间件，路由也可以传入一个或者多个。app.router('router', async (ctx, next) => {\r\n\r\n});\r\n\r\napp.router(['router', 'timer'], async (ctx, next) => {\r\n    await next();\r\n}, async (ctx, next) => {\r\n    await next();\r\n}, async (ctx, next) => {\r\n\r\n});不过，无论是 use 还是 router，都只是将路由和中间件信息，通过 _addMiddleware 和 _addRoute 两个方法，录入到 _routerMiddlewares 该对象中，用于后续调用 serve 的时候，层层去执行中间件。最重要的运行中间件逻辑，则是在 serve 和 compose 两个方法里。serve 里主要的作用是做路由的匹配以及将中间件组合好之后，通过 compose 进行下一步的操作。比如以下这段节选的代码，其实是将匹配到的路由的中间件，以及 * 这个通配路由的中间件合并到一起，最后依次执行。let middlewares = (_routerMiddlewares[url]) ? _routerMiddlewares[url].middlewares : [];\r\n// put * path middlewares on the queue head\r\nif (_routerMiddlewares['*']) {\r\n    middlewares = [].concat(_routerMiddlewares['*'].middlewares, middlewares);\r\n}组合好中间件后，执行这一段，将中间件 compose 后并返回一个函数，传入上下文 this 后，最后将 this.body 的值 resolve，即一般在最后一个中间件里，通过对 ctx.body 的赋值，实现云函数的对小程序端的返回：const fn = compose(middlewares);\r\n\r\nreturn new Promise((resolve, reject) => {\r\n    fn(this).then((res) => {\r\n        resolve(this.body);\r\n    }).catch(reject);\r\n});那么 compose 是怎么组合好这些中间件的呢？这里截取部份代码进行分析function compose(middleware) {\r\n    /**\r\n     * ... 其它代码 \r\n     */\r\n    return function (context, next) {\r\n        // 这里的 next，如果是在主流程里，一般 next 都是空。\r\n        let index = -1;\r\n\r\n        // 在这里开始处理处理第一个中间件\r\n        return dispatch(0);\r\n\r\n        // dispatch 是核心的方法，通过不断地调用 dispatch 来处理所有的中间件\r\n        function dispatch(i) {\r\n            if (i <= index) {\r\n                return Promise.reject(new Error('next() called multiple times'));\r\n            }\r\n\r\n            index = i;\r\n\r\n            // 获取中间件函数\r\n            let handler = middleware[i];\r\n\r\n            // 处理完最后一个中间件，返回 Proimse.resolve\r\n            if (i === middleware.length) {\r\n                handler = next;\r\n            }\r\n\r\n            if (!handler) {\r\n                return Promise.resolve();\r\n            }\r\n\r\n            try {\r\n                // 在这里不断地调用 dispatch, 同时增加 i 的数值处理中间件\r\n                return Promise.resolve(handler(context, dispatch.bind(null, i + 1)));\r\n            }\r\n            catch (err) {\r\n                return Promise.reject(err);\r\n            }\r\n        }\r\n    }\r\n}看完这里的代码，其实有点疑惑，怎么通过 Promise.resolve(handler(xxxx)) 这样的代码逻辑可以推进中间件的调用呢？首先，我们知道，handler 其实就是一个 async function，next，就是 dispatch.bind(null, i + 1) 比如这个：async (ctx, next) => {\r\n    await next();\r\n}而我们知道，dispatch 是返回一个 Promise.resolve 或者一个 Promise.reject，因此在 async function 里执行 await next()，就相当于触发下一个中间件的调用。当 compose 完成后，还是会返回一个 function (context, next)，于是就走到下面这个逻辑，执行 fn 并传入上下文 this 后，再将在中间件中赋值的 this.body resolve 出来，最终就成为云函数数要返回的值。const fn = compose(middlewares);\r\n\r\nreturn new Promise((resolve, reject) => {\r\n    fn(this).then((res) => {\r\n        resolve(this.body);\r\n    }).catch(reject);\r\n});看到 Promise.resolve 一个 async function，许多人都会很困惑。其实撇除 next 这个往下调用中间件的逻辑，我们可以很好地将逻辑简化成下面这段示例：let a = async () => {\r\n    console.log(1);\r\n};\r\n\r\nlet b = async () => {\r\n    console.log(2);\r\n\r\n    return 3;\r\n};\r\n\r\n\r\nlet fn = async () => {\r\n    await a();\r\n    return b();\r\n};\r\n\r\nPromise.resolve(fn()).then((res) => {\r\n    console.log(res);\r\n});\r\n\r\n// 输出\r\n// 1\r\n// 2\r\n// 3"}
